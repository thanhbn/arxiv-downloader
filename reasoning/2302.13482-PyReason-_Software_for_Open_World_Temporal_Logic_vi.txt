# 2302.13482.pdf
# Chuyển đổi từ PDF sang TXT
# Đường dẫn nguồn: /home/admin88/arxiv-downloader/reasoning/2302.13482.pdf
# Kích thước file: 2403345 bytes

===============================================
NỘI DUNG FILE PDF
===============================================


--- TRANG 1 ---
PyReason: Phần mềm cho Logic Thời gian Thế giới Mở
Dyuman Aditya†, Kaustuv Mukherji*,†, Srikar Balasubramanian, Abhiraj Chaudhary
và Paulo Shakarian*
Đại học Bang Arizona, 699 S Mill Ave, Tempe, AZ, 85281, Hoa Kỳ
Tóm tắt
Sự phổ biến ngày càng tăng của lý luận neuro symbolic đã dẫn đến việc áp dụng các dạng khác nhau của logic bậc nhất có thể vi phân (tức là mờ). Chúng tôi giới thiệu PyReason, một framework phần mềm dựa trên logic chú thích tổng quát vừa nắm bắt nhóm logic có thể vi phân hiện tại và các mở rộng thời gian để hỗ trợ suy luận trong các khoảng thời gian hữu hạn với khả năng lý luận thế giới mở. Hơn nữa, PyReason được triển khai để trực tiếp hỗ trợ lý luận trên các cấu trúc đồ thị (ví dụ: đồ thị tri thức, mạng xã hội, mạng sinh học, v.v.), tạo ra các dấu vết suy luận hoàn toàn có thể giải thích, và bao gồm nhiều tính năng thực tế như kiểm tra kiểu và triển khai tiết kiệm bộ nhớ. Bài báo này xem xét các mở rộng khác nhau của logic chú thích tổng quát được tích hợp vào triển khai của chúng tôi, triển khai hiện đại, hiệu quả dựa trên Python thực hiện suy luận diễn dịch chính xác nhưng có thể mở rộng, và một bộ thí nghiệm. PyReason có sẵn tại: github.com/lab-v2/pyreason .
Từ khóa
Lập trình logic, Lý luận Neuro Symbolic, Logic chú thích tổng quát, Logic thời gian, Logic bậc nhất, Lý luận thế giới mở, Lý luận đồ thị, Công cụ AI
1. Giới thiệu
Các framework neuro symbolic khác nhau sử dụng một logic cơ bản để hỗ trợ các khả năng như logic mờ [1], tham số hóa [2], và cấu trúc có thể vi phân [3]. Thông thường, các triển khai của những framework này tạo ra phần mềm tùy chỉnh cho suy luận cho logic cụ thể được sử dụng, điều này hạn chế tính mô-đun và khả năng mở rộng. Hơn nữa, các trường hợp sử dụng neuro symbolic mới nổi bao gồm logic thời gian trong các khoảng thời gian hữu hạn [4] và lý luận đồ thị tri thức [5] đòi hỏi một framework logic bao gồm một tập hợp khả năng rộng. May mắn thay, logic chú thích tổng quát [6] với các mở rộng khác nhau [7,8,9] nắm bắt nhiều khả năng này. Trong bài báo này, chúng tôi trình bày một gói phần mềm mới gọi là PyReason để thực hiện suy luận sử dụng logic chú thích tổng quát nắm bắt nhiều khả năng mong muốn được thấy trong các framework neuro symbolic khác nhau bao gồm lý luận mờ, thế giới mở, thời gian, và dựa trên đồ thị. Cụ thể, PyReason bao gồm khả năng cốt lõi để lý luận về
Trong A. Martin, K. Hinkelmann, H.-G. Fill, A. Gerber, D. Lenat, R. Stolle, F. van Harmelen (Eds.), Proceedings of the AAAI 2023 Spring Symposium on Challenges Requiring the Combination of Machine Learning and Knowledge Engineering (AAAI-MAKE 2023), Hyatt Regency, San Francisco Airport, California, USA, March 27-29, 2023.
*Tác giả liên hệ.
†Những tác giả này đóng góp ngang nhau.
/envelope-openkmukherji@asu.edu (K. Mukherji); pshak02@asu.edu (P. Shakarian)
/globehttps://search.asu.edu/profile/4179815 (K. Mukherji); https://labs.engineering.asu.edu/labv2/ (P. Shakarian)
/orcid0000-0002-4889-3499 (D. Aditya); 0000-0001-8044-1110 (K. Mukherji)
©2023 Bản quyền cho bài báo này thuộc về các tác giả. Được phép sử dụng theo Giấy phép Creative Commons Attribution 4.0 International (CC BY 4.0).
CEUR
Workshop
Proceedingsceur-ws.org
ISSN 1613-0073
CEUR Workshop Proceedings (CEUR-WS.org)arXiv:2302.13482v3  [cs.LO]  4 Mar 2023

--- TRANG 2 ---
các câu lệnh logic bậc nhất (FOL) và logic mệnh đề có thể được chú thích bằng các phần tử của cấu trúc lattice hoặc hàm trên lattice đó. Hơn nữa, chúng tôi đã cung cấp các mở rộng cú pháp và ngữ nghĩa thực tế bổ sung cho phép lý luận trên đồ thị tri thức, logic thời gian, lý luận về các mô hình khuếch tán mạng khác nhau, và ràng buộc kiểm tra kiểu predicate-constant. Triển khai này cung cấp một triển khai nhanh, tối ưu hóa bộ nhớ của toán tử điểm cố định được sử dụng trong quá trình diễn dịch. Bằng cách triển khai toán tử điểm cố định trực tiếp (thay vì heuristic hộp đen), phần mềm cho phép giải thích đầy đủ kết quả. Do vậy, framework này không chỉ nắm bắt logic cổ điển mà còn nhiều framework logic khác bao gồm logic mờ [10,11,12], logic giá trị thực có trọng số được sử dụng trong mạng neural logic [2], logic của van Emden [13], logic bilattice của Fitting [14], các framework logic khác nhau để lý luận trên đồ thị hoặc mạng xã hội [9,8,15] (cũng như các mô hình khuếch tán mạng khác nhau được nắm bắt bởi những framework đó), và có lẽ quan trọng nhất, các framework logic nơi cấu trúc cú pháp có thể được học sử dụng lập trình logic quy nạp có thể vi phân [3,16] cũng như các framework neuro symbolic khác [17,7]. Những ưu điểm chính của cách tiếp cận của chúng tôi bao gồm:
1.Hỗ trợ trực tiếp cho lý luận trên đồ thị tri thức. Cấu trúc đồ thị tri thức là một trong những biểu diễn dữ liệu symbolic được sử dụng phổ biến nhất. Trong khi các framework hộp đen như [18] cũng cho phép lý luận trên cấu trúc đồ thị, chúng không có khả năng giải thích của cách tiếp cận chúng tôi.
2.Hỗ trợ chú thích. Các triển khai logic cổ điển như Prolog [19] và Epilog [20] vốn không hỗ trợ chú thích hoặc hàm chú thích, do đó thiếu hỗ trợ trực tiếp cho các khả năng như toán tử mờ. Hơn nữa, framework của chúng tôi vượt xa hỗ trợ cho toán tử mờ bằng cách cho phép các hàm tùy ý có thể được sử dụng trên giá trị thực hoặc khoảng của số thực. Đây là một ưu điểm chính để lý luận về các cấu trúc được học với các phương pháp neuro symbolic như [2, 3, 16, 17, 7].
3.Mở rộng Thời gian. Trong khi framework của [6] đã được chứng minh là nắm bắt các logic thời gian khác nhau, các mở rộng như [9] đã cung cấp các tiện ích cú pháp và ngữ nghĩa thể hiện thời gian một cách rõ ràng và cho phép lý luận thời gian trên các chuỗi thời gian hữu hạn. Theo [9], chúng tôi sử dụng cấu trúc ngữ nghĩa đại diện cho nhiều điểm thời gian, nhưng chúng tôi đã triển khai điều này một cách compact để bảo tồn bộ nhớ. Giải pháp của chúng tôi cho phép các phiên bản mờ của các quy tắc như "nếu 𝑞(𝐴)thì𝑟(𝐴)trong𝑡bước thời gian." Lưu ý rằng những khả năng này không có trong hầu hết mọi triển khai hiện tại của logic mờ.
4.Sử dụng diễn giải. Chúng tôi định nghĩa diễn giải như hàm chú thích trên predicate và thời gian cùng nhau. Nó cho phép chúng ta nắm bắt các sự kiện đúng trước 𝑡= 0. Trong khi logic chú thích [6] có thể bao gồm các logic thời gian khác nhau mà không cần cấu trúc bổ sung, chúng tôi đã cho phép lý luận thời gian thông qua việc kết hợp thành phần thời gian trong diễn giải. Bằng cách kết hợp predicate chú thích và biến thời gian, chúng tôi tin rằng framework của chúng tôi linh hoạt hơn và phù hợp cho các ứng dụng neuro symbolic mới nổi liên quan đến thời gian - vì những ứng dụng như vậy sẽ đòi hỏi cả thời gian và chú thích giá trị thực. Ngoài ra, cần lưu ý rằng chúng tôi không đưa ra giả định thế giới đóng tức là bất cứ điều gì không được đề cập trong tập diễn giải ban đầu là 𝑓𝑎𝑙𝑠𝑒. Thay vào đó, chúng tôi coi tất cả các diễn giải khác là không biết ở đầu thời gian.
5.Cấu trúc Tri thức Đồ thị. Chúng tôi cũng triển khai [8] cung cấp các mở rộng cú pháp đồ thị cho [6]. Điều này được bao gồm trong triển khai của chúng tôi, đáng chú ý là thêm các toán tử cú pháp mở rộng để lý luận trong những cấu trúc như vậy (ví dụ: một toán tử tồn tại đòi hỏi sự tồn tại của 𝑘 mục). Một ví dụ về quy tắc như vậy sẽ là phiên bản mờ của "nếu 𝑞(𝐴)và tồn tại 𝑘 số 𝐵 sao cho 𝑏(𝐴, 𝐵)thì𝑟(𝐴)".1

--- TRANG 3 ---
6.Giảm độ phức tạp tính toán do grounding. Phần mềm của chúng tôi tận dụng cả tính thưa thớt vốn có của cấu trúc đồ thị cùng với triển khai mới lạ của ràng buộc kiểm tra kiểu predicate-constant, điều này cải thiện đáng kể tính hữu ích trong nhiều domain ứng dụng khác nhau và cũng cung cấp giảm drastic về độ phức tạp do vấn đề grounding gây ra. Chúng tôi không biết framework nào khác cho logic bậc nhất cung cấp cả hai khả năng như vậy.
7.Khả năng phát hiện và giải quyết các mâu thuẫn trong lý luận. Khi các suy luận logic được suy ra thông qua việc áp dụng toán tử điểm cố định trên các quy tắc logic được xác định trước, các mâu thuẫn logic không chỉ có thể được phát hiện mà còn định vị chính xác nơi trong quá trình suy luận mà mâu thuẫn xảy ra. Chúng tôi giải quyết bất kỳ mâu thuẫn nào như vậy bằng cách tận dụng sự không chắc chắn. Trong triển khai phần mềm, ngay khi một mâu thuẫn được phát hiện, chúng tôi nới lỏng và cố định các ranh giới để hoàn thành sự không chắc chắn. Khả năng kiểm tra và định vị mâu thuẫn tăng cường tính năng giải thích. Các phương pháp neuro symbolic như [2,7] cũng có thể tìm cách tận dụng mâu thuẫn như một phần của loss trong giai đoạn training.

Trong phần 2, chúng tôi phác thảo cú pháp và ngữ nghĩa của [6] cũng như các mở rộng của chúng tôi. Triển khai phần mềm của chúng tôi được mô tả trong phần 3 và được mở rộng trong phần bổ sung chỉ trực tuyến. Trong phần 4, chúng tôi cung cấp kết quả thực nghiệm của framework chúng tôi để chứng minh khả năng lý luận trong hai domain thế giới thực khác nhau. Chúng tôi đã thực hiện thí nghiệm trên dataset chuỗi cung ứng [21] (10𝐾 hằng số) và mạng xã hội [22] (1.6𝑀 hằng số). Để đánh giá, chúng tôi sử dụng các chương trình logic được curated thủ công khác nhau chỉ định các quy tắc cho sự tiến hóa thời gian của đồ thị, hoàn thành đồ thị, và các trường hợp sử dụng thực tế khác (ví dụ: xác định các gián đoạn chuỗi cung ứng tiềm năng) và kiểm tra cách các khía cạnh khác nhau ảnh hưởng đến thời gian chạy và sử dụng bộ nhớ (ví dụ: số lượng hằng số, predicate, timestep, bước suy luận, v.v.). Kết quả cho thấy cả thời gian chạy và bộ nhớ gần như không đổi trong các phạm vi lớn, và sau đó mở rộng sub-linear với sự tăng kích thước mạng.

Tài nguyên Trực tuyến
Thư viện python nguồn mở có sẵn tại: pypi.org/project/pyreason .
Codebase PyReason có thể được tìm thấy tại: github.com/lab-v2/pyreason .
Phần bổ sung chỉ trực tuyến có sẵn tại: github.com/lab-v2/pyreason/tree/main/lit

2. Framework Logic
Trong phần này, chúng tôi cung cấp tổng quan về framework logic chú thích với mô tả cấp cao về các cấu trúc logic, cấu trúc đồ thị tri thức, các tối ưu hóa chính, và hoạt động của thuật toán điểm cố định.

--- TRANG 4 ---
Hình 1: Ví dụ về đồ thị tri thức

Đồ thị tri thức. Chúng tôi giả định sự tồn tại của một cấu trúc đồ thị 𝐺= (𝒞, 𝐸) nơi các nút cũng là hằng số (ký hiệu tập 𝒞) trong framework logic bậc nhất. Các cạnh, ký hiệu 𝐸⊆𝒞×𝒞, chỉ định liệu bất kỳ loại quan hệ nào có thể tồn tại giữa hai hằng số. Tương tự như các framework gần đây kết hợp đồ thị tri thức và logic [3,18], chúng tôi sẽ giả định rằng tất cả predicate trong ngôn ngữ đều là unary (có thể được nghĩ là ghi nhãn các nút) hoặc binary (có thể được nghĩ là ghi nhãn các cạnh). Chúng tôi lưu ý rằng chúng tôi giả định sự tồn tại của một predicate binary đặc biệt rel, mà chúng tôi sẽ coi như một từ dành riêng. Với (𝑎, 𝑏)∈𝐸 chúng tôi sẽ coi rel(𝑎, 𝑏) như một định lý và với (𝑎, 𝑏)/∈𝐸 chúng tôi sẽ coi rel(𝑎, 𝑏) như không chắc chắn. Lưu ý rằng chúng ta có thể hỗ trợ không có hạn chế nào giữa việc ghép đôi các hằng số bằng cách tạo 𝐺 như một đồ thị được kết nối đầy đủ. Tương tự, chúng ta dễ dàng hỗ trợ trường hợp mệnh đề bằng cách sử dụng đồ thị của một nút duy nhất (về cơ bản coi predicate unary như atom ground). Chúng tôi cung cấp một ví dụ chạy trong phần này. Trong Hình 1, chúng tôi minh họa cách một đồ thị tri thức được chỉ định trong framework của chúng tôi.

Ví dụ 2.1 (Đồ thị Tri thức). Xem xét các nút sau: ba sinh viên- Phil, John, Mary và hai lớp- English và Math. Các nút và cạnh có predicate unary và binary như được hiển thị trong Hình 1. Do đó chúng ta có các atom non-ground sau:
student(S), gpa(S), promoted(S)
class(C), difficulty(C)
friend(S,S')
takes(S,C), grade(S,C), expertise(S,C)
Ở đây, S, S', và C là các biến khi được grounded với các hằng số từ đồ thị, tạo ra các atom ground như:
student(john), student(phil), student(mary)
class(math), class(english)
takes(john,math), takes(mary, english)
...

--- TRANG 5 ---
Trong trường hợp mệnh đề, một atom non-ground giảm thành một câu lệnh mệnh đề. Ví dụ predicate "takes(john,math)" có thể được biểu diễn như một câu lệnh mệnh đề: "John takes Math class" và có thể là True hoặc False. Nó đúng trong ví dụ này, như được hiển thị trong Hình 1.

Chú thích Khoảng Giá trị Thực. Một lợi thế chính của logic chú thích [6] là khả năng chú thích các atom trong framework với các phần tử của cấu trúc lattice cũng như các hàm trên lattice đó. Trong phần mềm của chúng tôi, chúng tôi sử dụng cấu trúc lattice thấp hơn bao gồm các khoảng là tập con của [0,1]. Điều này trực tiếp phù hợp với khoảng chân lý cho các toán tử mờ [12], cũng như các paradigm trong lý luận neuro symbolic [2,7], và phân tích mạng xã hội [8,9]. Chúng ta có thể hoàn toàn hỗ trợ chú thích có giá trị vô hướng bằng cách đơn giản hạn chế thao tác với ranh giới dưới của khoảng và giữ ranh giới trên được đặt ở 1. Những chú thích này có thể hỗ trợ logic cổ điển bằng cách hạn chế chú thích là [0,0](false) và [1,1](true). Nó cũng có thể hỗ trợ logic ba giá trị bằng cách cho phép [0,1], đại diện cho không có kiến thức. Tất nhiên, không cần thực hiện hạn chế, đặc biệt nếu mong muốn hỗ trợ các logic sử dụng đầy đủ khoảng [2,8,9]. Ngoài ra, chúng tôi hỗ trợ literal như được chi tiết trong [7]. Chúng tôi xử lý phủ định giống như trong [1] - đối với một atom được chú thích với [ℓ, 𝑢], chúng tôi chú thích phủ định mạnh của nó( ¬) với [1−𝑢,1−ℓ].

Ví dụ 2.2 (Chú thích Khoảng Giá trị Thực). Tiếp tục với ví dụ trước, chúng ta có thể hỗ trợ nhiều chú thích khác nhau như được mô tả ở trên.
Logic mệnh đề:
student(john): [1,1] (ví dụ về câu lệnh True)
takes(mary,math): [0,0] (ví dụ về câu lệnh False)
Logic mờ (sử dụng giá trị vô hướng):
gpa(john): [X,1], X ∈[0,1]
Sử dụng khoảng đầy đủ:
difficulty(english): [0.3,0.7] (cả hai ranh giới đều được sử dụng ở đây để nắm bắt sự biến đổi giữa các sinh viên về độ khó cảm nhận của môn "english").
Mô hình hóa sự không chắc chắn và/hoặc logic ba giá trị:
Giả sử chúng ta không có kiến thức hoàn chỉnh về mạng này - cụ thể, chúng ta không có thông tin nào về tình bạn giữa John và Phil. Vậy, họ có thể là bạn (chú thích [1,1]) hoặc không phải bạn (chú thích [0,0]). Framework của chúng tôi có thể mô hình hóa trường hợp như vậy là:
friend(john,phil): [0,1]

Diễn giải. Thông thường trong các framework logic, một tập hợp sự kiện ban đầu được sử dụng. Chúng tôi sử dụng thuật ngữ "diễn giải ban đầu" để nắm bắt các chú thích đúng ở đầu chương trình. Trong các domain được hình dung - bao gồm những domain mà chúng tôi thực hiện thí nghiệm - những diễn giải ban đầu này sẽ được biểu diễn như một đồ thị tri thức không chỉ bao gồm đồ thị 𝐺 mà còn các thuộc tính trên các nút và cạnh (giống predicate) và chú thích khoảng giá trị thực (chỉ định các chú thích ban đầu cho mỗi phần tử). Ngoài ra, theo trực giác từ các framework logic thời gian khác nhau kết hợp cả chú thích thời gian và giá trị thực khác [9,8,23,24,25], chúng tôi mở rộng cú pháp của mình để cung cấp chú thích thời gian như một phần của diễn giải. Theo công việc liên quan, thời gian được biểu diễn như các điểm thời gian rời rạc hữu hạn. Các diễn giải ban đầu bao gồm những gì được coi là đúng trước thời gian 0. Hơn nữa, với các diễn giải ban đầu, chúng ta có thể chỉ định predicate là static (nói cách khác, các atom ground được hình thành với những predicate đó giữ nguyên chú thích giống nhau qua tất cả các khoảng thời gian) hoặc non-static (được phép thay đổi). Khả năng thêm hạn chế này có lợi ích rõ ràng trong một số domain nhất định, và cũng cho phép hiệu quả triển khai chính cho lý luận qua các khoảng thời gian. Hơn nữa, được lưu ý rằng các paradigm lập trình logic quy nạp khác nhau [3,26] sử dụng predicate "extensional" cũng không thay đổi - có thể được coi là "static" trong PyReason.

Cú pháp:
𝐼(𝐴, 𝑡^) : [𝐿, 𝑈]
trong đó, 𝐴 có thể là một atom (trường hợp mệnh đề) hoặc predicate (logic bậc nhất), 𝑡^ là điểm thời gian 𝑇=𝑡 mà diễn giải 𝐼 có hiệu lực, hoặc nếu diễn giải là static, tức là không thay đổi cho tất cả các điểm thời gian thì 𝑡^=𝑠. Vậy,
𝑡^={︃
𝑠,nếu𝐼(𝐴, 𝑡^)là static
𝑡, 𝑡∈𝑇nếu𝐼(𝐴, 𝑡^)là time-variant(1)
Chú thích [𝐿, 𝑈]→[0,1](hoặc, trong trường hợp mệnh đề [𝐿, 𝑈]∈[0,0],[1,1]). Chúng tôi kết hợp literal trong hệ thống của mình bằng cách có các diễn giải riêng biệt cho một atom và phủ định của nó. Chúng tôi lưu ý rằng, ngoại trừ trường hợp của atom static, các atom ground ở các điểm thời gian khác nhau không cần phụ thuộc lẫn nhau. Ví dụ, atom "a" ở thời gian 1 có thể được chú thích với [0.5,0.7] và chú thích với [0.1,0.2] ở thời gian 2. Không có yêu cầu đơn điệu giữa các điểm thời gian.

--- TRANG 6 ---
Ví dụ 2.3 (Diễn giải). Tiếp tục ví dụ trước,
Tập hợp sự kiện ban đầu về đăng ký sinh viên:
I(student(john),0) = [1,1] (John được đăng ký như một sinh viên)
I(student(mary),0) = [1,1] (Mary được đăng ký như một sinh viên)
I(student(phil),0) = [0,0] (Phil không được đăng ký như một sinh viên)
Diễn giải static có thể được sử dụng cho các sự kiện luôn đúng như:
I(class(english), s) = [1,1] (English là một lớp được cung cấp ở tất cả các điểm thời gian)
Sử dụng chú thích thời gian để nắm bắt biến đổi theo thời gian:
I(takes(john,math),1) = [1,1] (John học lớp Math ở thời gian 𝑡= 1)
I(takes(john,math),5) = [0,0] (Nhưng không còn học Math ở 𝑡= 5)
Tất cả các diễn giải khác, nếu không được chỉ định ở 𝑡= 0, được khởi tạo với [0,1].

Quy tắc Logic. Quy tắc là cấu trúc cú pháp chính cho phép thay đổi đối với các atom được hình thành với predicate non-static. Trong lịch sử, các quy tắc logic chủ yếu được viết bởi các chuyên gia domain, cho đến công việc đầu như Apriori [27] và FOIL [28] để học các quy tắc liên kết từ dữ liệu theo sau bởi sự xuất hiện của các kỹ thuật khai thác quy tắc như khai thác quy tắc nhân quả [29] và logic thời gian xác suất chú thích [24,30,31]. Gần đây hơn, đã có nghiên cứu về Lập trình Logic Quy nạp Có thể Vi phân ( 𝜕ILP) - một phương pháp học quy tắc quy nạp để học các quy tắc logic từ các ví dụ [3,16,32]. Trong danh sách dưới đây 𝑈𝑛𝑎𝑆𝑒𝑡 và 𝐵𝑖𝑛𝑆𝑒𝑡 là các tập hợp tùy ý của predicate unary và binary có liên quan đến các quy tắc trong khi 𝑝𝑟𝑒𝑑 luôn là predicate non-static. Lưu ý rằng tổng số atom trong thân được giả định là 𝑛 (qua tất cả các liên kết khác nhau). Ký hiệu ∃𝑘 có nghĩa là tồn tại ít nhất 𝑘 số hằng số sao cho câu logic kế tiếp được thỏa mãn.

--- TRANG 7 ---
1. Quy tắc ground để lý luận trong một hằng số hoặc cạnh duy nhất:
𝑝𝑟𝑒𝑑(𝑐) :𝑓(𝑥1, . . . , 𝑥 𝑛)←Δ𝑡⋀︀
𝑝𝑟𝑒𝑑 𝑖∈𝑈𝑛𝑎𝑆𝑒𝑡𝑝𝑟𝑒𝑑 𝑖(𝑐) :𝑥𝑖
𝑝𝑟𝑒𝑑(𝑐, 𝑐′) :𝑓(𝑥1, . . . , 𝑥 𝑛)←Δ𝑡⋀︀
𝑝𝑟𝑒𝑑 𝑖∈𝐵𝑖𝑛𝑆𝑒𝑡 𝑝𝑟𝑒𝑑 𝑖(𝑐, 𝑐′) :𝑥𝑖

2. Quy tắc non-ground được lượng hóa toàn bộ để lý luận trong một hằng số hoặc cạnh duy nhất:
∀𝑋:𝑝𝑟𝑒𝑑(𝑋) :𝑓(𝑥1, . . . , 𝑥 𝑛)←Δ𝑡⋀︀
𝑝𝑟𝑒𝑑 𝑖∈𝑈𝑛𝑎𝑆𝑒𝑡𝑝𝑟𝑒𝑑 𝑖(𝑋) :𝑥𝑖
∀𝑋, 𝑋′𝑠.𝑡.(𝑋, 𝑋′)∈𝐸:𝑝𝑟𝑒𝑑(𝑋, 𝑋′) :𝑓(𝑥1, . . . , 𝑥 𝑛)←Δ𝑡⋀︀
𝑝𝑟𝑒𝑑 𝑞∈𝐵𝑖𝑛𝑆𝑒𝑡 𝑝𝑟𝑒𝑑 𝑞(𝑋, 𝑋′) :
𝑥𝑞∧⋀︀
𝑝𝑟𝑒𝑑 𝑟∈𝑈𝑛𝑎𝑆𝑒𝑡𝑝𝑟𝑒𝑑 𝑟(𝑋) :𝑥𝑟∧⋀︀
𝑝𝑟𝑒𝑑 𝑠∈𝑈𝑛𝑎𝑆𝑒𝑡′𝑝𝑟𝑒𝑑 𝑠(𝑋′) :𝑥𝑠

3. Quy tắc non-ground được lượng hóa toàn bộ để lý luận qua một cạnh:
∀𝑋:𝑝𝑟𝑒𝑑(𝑋) :𝑓(𝑥1, . . . , 𝑥 𝑛)←Δ𝑡∃𝑘𝑋′:𝑟𝑒𝑙(𝑋, 𝑋′) : [1,1]∧⋀︀
𝑝𝑟𝑒𝑑 𝑞∈𝐵𝑖𝑛𝑆𝑒𝑡𝑝𝑟𝑒𝑑 𝑞(𝑋, 𝑋′) :
𝑥𝑞∧⋀︀
𝑝𝑟𝑒𝑑 𝑟∈𝑈𝑛𝑎𝑆𝑒𝑡 𝑝𝑟𝑒𝑑 𝑟(𝑋) :𝑥𝑟∧⋀︀
𝑝𝑟𝑒𝑑 𝑠∈𝑈𝑛𝑎𝑆𝑒𝑡′𝑝𝑟𝑒𝑑 𝑠(𝑋′) :𝑥𝑠

4. Quy tắc non-ground với bộ lượng hóa dựa trên quy tắc trong đầu:
𝑝𝑟𝑒𝑑(𝑋) : [𝐴𝑠(𝑙1, 𝑙2, . . . , 𝑙 𝑛), 𝐴𝑠(𝑢1, 𝑢2, . . . , 𝑢 𝑛)]←⋀︀
𝑋𝑖s.t.(𝑋,𝑋 𝑖)∈𝐸𝑝𝑟𝑒𝑑′(𝑋, 𝑋 𝑖) : [𝑙𝑖, 𝑢𝑖]
Ở đây, 𝐴𝑘
𝑠,𝑚(𝑆) có thể là bộ lượng hóa dựa trên quy tắc 𝑚-th được định nghĩa trên tập 𝑆 sao cho,
𝐴𝑘
𝑠,𝑚(𝑆) = giá trị cao thứ 𝑘 trong tập 𝑆.

Ví dụ 2.4 (Quy tắc Logic). Đối với ví dụ tiếp tục, chúng ta có thể hình thành một số quy tắc thú vị dựa trên các định dạng được đưa ra ở trên như:
1.𝑝𝑟𝑜𝑚𝑜𝑡𝑒𝑑 (𝑋) : [𝑇(𝑙1, 𝑙2), 𝑈(𝑢1, 𝑢2)]←Δ𝑡=1𝑠𝑡𝑢𝑑𝑒𝑛𝑡 (𝑋) : [𝑙1, 𝑢1]∧𝑔𝑝𝑎(𝑋) : [𝑙2, 𝑢2]
có nghĩa là, "Nếu 𝑋 là một sinh viên với ranh giới [𝑙1, 𝑢1] và có gpa với ranh giới [𝑙2, 𝑢2], thì 𝑋 có khả năng được thăng cấp, ở timestep tiếp theo, với ranh giới được cho bởi một hàm của [𝑙1, 𝑢1] và [𝑙2, 𝑢2]."
Ở đây, 𝑇 có thể là một T-norm. Một số ví dụ nổi tiếng của T-norm là:
a)Minimum: 𝑇(𝑎, 𝑏) =𝑇𝑚𝑖𝑛(𝑎, 𝑏) =𝑚𝑖𝑛(𝑎, 𝑏)
b)Product: 𝑇(𝑎, 𝑏) =𝑇𝑝𝑟𝑜𝑑(𝑎, 𝑏) =𝑎·𝑏
c)Łukasiewicz: 𝑇(𝑎, 𝑏) =𝑇𝑙𝑢𝑘(𝑎, 𝑏) =𝑚𝑎𝑥(0, 𝑎+𝑏−1)
PyReason cũng hỗ trợ các hàm logic nổi tiếng khác như 𝑇−𝑐𝑜𝑛𝑜𝑟𝑚, các hàm đại số như 𝑚𝑎𝑥, 𝑚𝑖𝑛, 𝑎𝑣𝑒𝑟𝑎𝑔𝑒, trong số các hàm khác.
2.∀𝑋, 𝑌 𝑒𝑥𝑝𝑒𝑟𝑡𝑖𝑠𝑒 (𝑋, 𝑌 ) : [0 .6*𝐿,1]←Δ𝑡=0𝑔𝑟𝑎𝑑𝑒 [𝑋, 𝑌 ] : [𝐿,1]∧𝑠𝑡𝑢𝑑𝑒𝑛𝑡 (𝑋) :
[1,1]∧𝑐𝑙𝑎𝑠𝑠 (𝑌) : [1,1]
có nghĩa là, "Nếu 𝑋 là một sinh viên đạt điểm [𝐿,1] trong lớp 𝑌, thì chúng ta có thể ước tính chuyên môn của 𝑋 về môn 𝑌 bằng cách định nghĩa một hàm chú thích [0.6*𝐿,1] trên một chú thích duy nhất [𝐿,1]."

--- TRANG 8 ---
3.𝑔𝑝𝑎(𝑗𝑜ℎ𝑛 ) : [𝑥1+𝑥2
2,1]←Δ𝑡=0∃𝑖=2𝐶𝑖∈𝒞 :𝑐𝑙𝑎𝑠𝑞 (𝐶𝑖) : [1 ,1]∧𝑡𝑎𝑘𝑒𝑠 (𝑗𝑜ℎ𝑛, 𝐶 𝑖) :
[1,1]∧𝑔𝑟𝑎𝑑𝑒 (𝑗𝑜ℎ𝑛, 𝐶 𝑖) : [𝑥𝑖,1]
có nghĩa là, "Nếu 𝑗𝑜ℎ𝑛 học và kiếm điểm cho hai lớp, thì 𝑔𝑝𝑎 của anh ta có thể được tính toán bằng cách sử dụng hàm đại số 𝑎𝑣𝑔 trong đầu của quy tắc ground được lượng hóa tồn tại đã cho."
4.𝑓𝑟𝑖𝑒𝑛𝑑 (𝑆, 𝑆′) : [1 ,1]←Δ𝑡=2𝑡𝑎𝑘𝑒𝑠 (𝑆, 𝐶) : [1 ,1]∧𝑡𝑎𝑘𝑒𝑠 (𝑆′, 𝐶) : [1 ,1]∧𝑐𝑙𝑎𝑠𝑠 (𝐶) :
[1,1]
một quy tắc mệnh đề với mở rộng thời gian nói rằng, "Nếu hai sinh viên 𝑆 và 𝑆′ học cùng một lớp 𝐶, họ phát triển tình bạn sau hai timestep."
5.∀𝑆, 𝑆′, 𝑆′′𝑓𝑟𝑖𝑒𝑛𝑑 (𝑆, 𝑆′′) : [1,1]←Δ𝑡=1𝑓𝑟𝑖𝑒𝑛𝑑 (𝑆, 𝑆′) : [1,1]∧𝑓𝑟𝑖𝑒𝑛𝑑 (𝑆′, 𝑆′′) : [1,1]
một quy tắc non-ground được lượng hóa toàn bộ tương tự như quy tắc kết hợp trong toán học bao gồm, "Có một người bạn chung 𝑆′ dẫn đến tình bạn giữa hai người 𝑆 và 𝑆′′."

Toán tử Điểm cố định cho Suy luận. Trung tâm của quá trình diễn dịch là một toán tử điểm cố định (ký hiệu bởi Γ) đã được chứng minh trước đây là tạo ra tất cả các atom được entail bởi một chương trình logic (quy tắc và sự kiện) trong [6,7] và những kết quả này đã được mở rộng cho ngữ nghĩa thời gian trong [9,8]. Đáng chú ý là đây là một tính toán chính xác của điểm cố định, và do đó cung cấp mô hình tối thiểu liên quan đến chương trình logic cho phép dễ dàng kiểm tra entailment của các công thức tùy ý. Hơn nữa, kết quả có thể giải thích hoàn toàn: đối với bất kỳ truy vấn entailment nào, chúng ta sẽ có chuỗi các bước suy luận dẫn đến kết quả. Điều này khác biệt đáng kể so với các framework khác không cung cấp giải thích cho kết quả diễn dịch [18] mặc dù một sự khác biệt chính là framework lý luận được triển khai trong PyReason cho phép suy luận chính xác và hiệu quả trong thời gian đa thức, trong khi các framework khác có quá trình suy luận không thể giải quyết được.

Ví dụ 2.5 (Toán tử Điểm cố định( Γ)). Xem xét chúng ta có tập hợp các diễn giải ban đầu sau đây ngoài những cái đã được chỉ định trước đó:
I(takes(john,english),1) = I(takes(john,english),2) = [1,1]
I(takes(mary,english),2) = I(takes(mary,english),3) = [1,1]
(John học English ở t=1,2 và Mary học English ở t=2,3)
I(friend(mary,phil),s) = [1,1]
(Mary và Phil là bạn trong toàn bộ thời gian được xem xét)
Và chúng ta xem xét tập quy tắc 𝑅 được tạo từ quy tắc 4 và 5 từ trên. Chúng ta khởi tạo:
∀S,S' I(friend(S,S'),0) = [0,1] (tất cả các quan hệ 𝑓𝑟𝑖𝑒𝑛𝑑 được khởi tạo như không biết)
và sau đó cập nhật:
I(friend(mary,phil),s) = [1,1] (từ diễn giải ban đầu)
Việc áp dụng Γ ở T=0 và 1 không mang lại thay đổi nào trong 𝐼 vì không có quy tắc nào được kích hoạt.
Ở T=2, quy tắc 4 kích hoạt với các grounding sau:
𝑓𝑟𝑖𝑒𝑛𝑑 (𝑗𝑜ℎ𝑛, 𝑚𝑎𝑟𝑦 ) : [1,1]←Δ𝑡=2𝑡𝑎𝑘𝑒𝑠 (𝑗𝑜ℎ𝑛, 𝑒𝑛𝑔𝑙𝑖𝑠ℎ ) : [1,1]∧𝑡𝑎𝑘𝑒𝑠 (𝑚𝑎𝑟𝑦, 𝑒𝑛𝑔𝑙𝑖𝑠ℎ ) :
[1,1]∧𝑐𝑙𝑎𝑠𝑠 (𝑒𝑛𝑔𝑙𝑖𝑠ℎ ) : [1,1]

--- TRANG 9 ---
𝑓𝑟𝑖𝑒𝑛�� (𝑚𝑎𝑟𝑦, 𝑗𝑜ℎ𝑛 ) : [1,1]←Δ𝑡=2𝑡𝑎𝑘𝑒𝑠 (𝑚𝑎𝑟𝑦, 𝑒𝑛𝑔𝑙𝑖𝑠ℎ ) : [1,1]∧𝑡𝑎𝑘𝑒𝑠 (𝑗𝑜ℎ𝑛, 𝑒𝑛𝑔𝑙𝑖𝑠ℎ ) :
[1,1]∧𝑐𝑙𝑎𝑠𝑠 (𝑒𝑛𝑔𝑙𝑖𝑠ℎ ) : [1,1]
Điều này sẽ dẫn đến một thay đổi trong 𝐼 ở T = 4, vì Δ𝑡= 2 cho quy tắc trên và nó được kích hoạt ở T=2.
I(friend(john,mary),4) = [1,1]
I(friend(mary,john),4) = [1,1]
Ở T=3, vì 𝐼 vẫn không thay đổi, việc áp dụng Γ không dẫn đến việc kích hoạt bất kỳ quy tắc nào.
Ở T=4, việc áp dụng Γ với diễn giải được cập nhật dẫn đến việc kích hoạt quy tắc ground 5 như:
𝑓𝑟𝑖𝑒𝑛𝑑 (𝑗𝑜ℎ𝑛, 𝑝ℎ𝑖𝑙 ) : [1,1]←Δ𝑡=1𝑓𝑟𝑖𝑒𝑛𝑑 (𝑗𝑜ℎ𝑛, 𝑚𝑎𝑟𝑦 ) : [1,1]∧𝑓𝑟𝑖𝑒𝑛𝑑 (𝑚𝑎𝑟𝑦, 𝑝ℎ𝑖𝑙 ) : [1,1]
Và dẫn đến:
I(friend(john, phil),5) = [1,1]
Điều trên minh họa cách PyReason thực hiện suy luận logic bằng cách áp dụng chính xác toán tử điểm cố định( Γ). Trong ví dụ này, chúng ta có thể theo dõi cách diễn giải I(friend(john, phil),t) thay đổi theo thời gian, và những quy tắc nào gây ra những thay đổi này. Điều này cho thấy quá trình này hoàn toàn có thể giải thích, và có thể được tận dụng trong các ứng dụng neuro symbolic mới nổi.

Ràng buộc Kiểm tra Kiểu Constant-Predicate. Chìa khóa để giảm độ phức tạp và tăng tốc quá trình suy luận là kiểm tra kiểu. Chúng tôi tận dụng tính thưa thớt thường có trong đồ thị tri thức để cắt giảm đáng kể không gian tìm kiếm trong quá trình grounding. Chúng tôi nhận thấy rằng thông thường một đồ thị sẽ có các nút thuộc các loại khác nhau, và predicate thường chỉ được định nghĩa trên các hằng số thuộc một loại cụ thể. Trong khi khởi tạo diễn giải, kiểm tra kiểu tính đến điều này và chỉ tạo các atom ground cho tập con của các cặp predicate-constant tương thích với nhau. Tuy nhiên, chúng tôi lưu ý rằng đây là một tùy chọn, vì trong một số ứng dụng, thông tin như vậy có thể không có sẵn.

Ví dụ 2.6 (Kiểm tra Kiểu Constant-Predicate). Trong ví dụ tiếp tục, chúng ta thấy rằng các predicate student, gpa, promoted chỉ giới hạn cho các hằng số thuộc loại student. Tương tự, predicate class, difficulty độc quyền cho các hằng số english và math. Kiểm tra kiểu đảm bảo rằng chúng ta không xem xét các atom ground như student(english) hoặc class(phil).
Tương tự cho predicate binary takes(S,C), biến đầu tiên luôn được grounded với hằng số loại student, và biến thứ hai với hằng số loại class. Ngay cả trong ví dụ nhỏ này, kiểm tra kiểu giảm số lượng atom ground được xem xét từ 25 xuống chỉ 6 - giảm 76%. Những lợi ích như vậy giảm đáng kể độ phức tạp khi kích thước và tính thưa thớt của đồ thị tăng.

Phát hiện và Giải quyết Mâu thuẫn. Mâu thuẫn có thể xảy ra trong các trường hợp sau:
1.Đối với một atom ground nào đó, một diễn giải mới được gán một chú thích [𝐿′, 𝑈′] không phải là tập con của diễn giải hiện tại [𝐿, 𝑈](chúng ta giả định 𝐿≤𝑈). tức là nếu 𝑈 < 𝐿′ hoặc 𝑈′< 𝐿.
2.Khi một mâu thuẫn xảy ra giữa một atom và phủ định của nó như "a" và "not a". Hoặc giữa các predicate bổ sung như " 𝑏𝑎𝑐ℎ𝑒𝑙𝑜𝑟 (𝑋)" và " 𝑚𝑎𝑟𝑟𝑖𝑒𝑑 (𝑋)" không thể cùng tồn tại.
ví dụ Literal A có chú thích [𝐿1, 𝑈1] và Literal B là phủ định của literal A với

--- TRANG 10 ---
chú thích [𝐿2, 𝑈2]. Toán tử điểm cố định cố gắng gán [𝐿′
1, 𝑈′
1] cho Literal A, và [𝐿′
2, 𝑈′
2] cho Literal B. Nhưng các ranh giới mới không nhất quán, tức là 𝐿′
1>1−𝐿′
2 hoặc 𝑈′
1<1−𝑈′
2.
PyReason đánh dấu tất cả những mâu thuẫn như vậy phát sinh trong quá trình thực thi toán tử điểm cố định và báo cáo chúng. Hơn nữa, vì toán tử điểm cố định cung cấp một dấu vết có thể giải thích, người dùng có thể thấy nguyên nhân chính xác của mâu thuẫn. Như một tính năng thực tế bổ sung, PyReason bao gồm một tùy chọn để đặt lại chú thích thành [0,1] cho bất kỳ mâu thuẫn nào được xác định và đặt atom thành static cho phần còn lại của quá trình suy luận. Theo cách này, những mâu thuẫn như vậy không thể lan truyền thêm. Những khả năng ban đầu này cung cấp nền tảng vững chắc cho các kỹ thuật quản lý nhất quán tinh vi hơn như cung cấp tính nhất quán cục bộ hoặc nới lỏng lặp lại của chương trình logic ban đầu.

Ví dụ 2.7 (Phát hiện và Giải quyết Mâu thuẫn.). Xem xét chúng ta có kiến thức trước sau:
I(takes(phil,math), 4) = [1,1]
I(takes(mary,math), 4) = [1,1]
I(friend(phil,mary), 5) = [0,0]
Tuy nhiên, quy tắc logic sau với grounding 𝑆←𝑝ℎ𝑖𝑙,𝑆′←𝑚𝑎𝑟𝑦 ,𝐶←𝑚𝑎𝑡ℎ :
𝑓𝑟𝑖𝑒𝑛𝑑 (𝑆, 𝑆′) : [1,1]←1𝑡𝑎𝑘𝑒𝑠 (𝑆, 𝐶) : [1,1]∧𝑡𝑎𝑘𝑒𝑠 (𝑆′, 𝐶) : [1,1]được kích hoạt ở 𝑡= 4.
dẫn đến:
I(friend(phil,mary), 5) = [1,1]
Nhưng rõ ràng đây là một mâu thuẫn vì I(friend(phil,mary), 5) không thể vừa là [0,0] vừa là [1,1] cùng lúc. Vậy, chúng ta kết luận rằng ít nhất một trong hai diễn giải đó phải sai. Nếu không có cách nào để xác định cái nào đúng, chúng ta có thể giải quyết mâu thuẫn logic này bằng cách đặt:
I(friend(phil,mary), s) = [0,1] ở 𝑡= 5.

3. Triển khai
Chúng tôi đã cố gắng tạo ra một framework hiện đại dựa trên Python để hỗ trợ lý luận có thể mở rộng nhưng chính xác. Chúng tôi cho phép đầu vào đồ thị thông qua định dạng Graphml thuận tiện, được sử dụng phổ biến trong các kiến trúc đồ thị tri thức. Thư viện python Networkx được sử dụng để tải và tương tác với dữ liệu đồ thị. Chúng tôi hiện đang trong quá trình hỗ trợ trực tiếp Neo4j. Các điều kiện ban đầu và quy tắc được nhập ở định dạng YAML và chúng tôi sử dụng các kỹ thuật triển khai tiết kiệm bộ nhớ để nắm bắt chính xác các cấu trúc ngữ nghĩa. Chúng tôi sử dụng trình biên dịch JIT nguồn mở Numba để dịch nhiều phép toán chính thành mã máy nhanh, được tối ưu hóa trong khi cho phép người dùng tương tác với Python và các front-end nói trên. Triển khai của chúng tôi có thể hỗ trợ song song CPU, như được chứng minh bởi các thí nghiệm của chúng tôi chạy trên các máy đa CPU.

Phần mềm của chúng tôi lưu trữ diễn giải trong một dictionary lồng nhau. Để hiệu quả tính toán và dễ sử dụng, phần mềm của chúng tôi cho phép chỉ định một phạm vi các điểm thời gian 𝑇=𝑡1, 𝑡2, . . .thay vì một điểm thời gian duy nhất 𝑡, mà diễn giải 𝐼 vẫn có hiệu lực. Để giảm yêu cầu bộ nhớ, chỉ có một tập hợp diễn giải (hiện tại) được lưu trữ tại bất kỳ thời điểm nào. Tuy nhiên, các diễn giải trong quá khứ có thể được lấy bằng cách sử dụng rule traces, giữ lại lịch sử thay đổi cho mỗi

--- TRANG 11 ---
Bảng 1
Mạng Honda: Cách gián đoạn trên ngành công nghiệp của một quốc gia, do đại dịch gây ra, có thể lan rộng toàn thế giới
Công ty Công ty bị gián đoạn trên thế giới ở thời gian t= % công ty bị gián đoạn
Căn cứ Số lượng 0 1 2 3 4 . . . 38 Ban đầu Cuối Thay đổi
Hoa Kỳ 1599 1599 1965 2057 2203 2313 . . . 3336 14.68 30.75 16.07
Đài Loan 603 603 644 647 647 647 . . . 647 5.54 5.94 0.40
Úc 128 128 131 131 131 131 . . . 131 1.18 1.21 0.03

diễn giải và các quy tắc logic ground tương ứng gây ra mỗi thay đổi. Rule traces làm cho phần mềm của chúng tôi hoàn toàn có thể giải thích, vì mọi suy luận có thể được theo dõi ngược về chuỗi các quy tắc dẫn đến nó.

MANCaLog [9] đã chỉ ra việc sử dụng toán tử điểm cố định cho cả mô hình canonical và non-canonical. Bằng cách tính toán lại các diễn giải ở mỗi bước thời gian, chúng tôi không chỉ yêu cầu ít bộ nhớ hơn đáng kể mà còn hỗ trợ cả trường hợp canonical và non-canonical. Do thiết kế này, sự tăng thời gian tính toán được quan sát là tối thiểu.

Hơn nữa, chúng tôi tạo ra những tiến bộ đáng kể so với [33] bằng cách hỗ trợ predicate static, và có khả năng tích hợp cho lý luận non-graph, và kiểm tra kiểu như được chi tiết trong phần 2. Triển khai của chúng tôi có thể được tìm thấy trực tuyến như được chỉ định trong phần 1 và pseudocode chi tiết có thể được tìm thấy trong thông tin bổ sung.

4. Thí nghiệm
4.1. Dataset Honda Buyer-Supplier
Chúng tôi thực hiện thí nghiệm trên mạng Honda Buyer-Supplier [21]. Dataset (mạng) chứa 10,893 công ty (nút) và 47,247 quan hệ buyer-supplier giữa chúng (cạnh).

Chúng tôi thiết kế một trường hợp sử dụng, nơi chúng tôi giả định rằng hoạt động của tất cả các công ty từ một quốc gia cụ thể bị gián đoạn, và quan sát các tác động mà điều này có thể có đối với các công ty trên toàn thế giới. Chúng tôi cảm thấy điều này giống với các vấn đề chuỗi cung ứng mà toàn thế giới phải đối mặt trong đại dịch COVID-19. Cho các thử nghiệm của chúng tôi, chúng tôi sử dụng quy tắc logic sau mà trong thực tế sẽ được học hoặc đến từ một chuyên gia.

𝑑𝑖𝑠𝑟𝑢𝑝𝑡𝑒𝑑 (𝐵𝑢𝑦𝑒𝑟 ) : [1,1]←Δ𝑡=1∀𝑘𝑠𝑢𝑝𝑝𝑙𝑖𝑒𝑠 (𝑆𝑢𝑝𝑘, 𝐵𝑢𝑦𝑒𝑟 ) : [1,1],∃𝑘/2𝑑𝑖𝑠𝑟𝑢𝑝𝑡𝑒𝑑 (𝑆𝑢𝑝𝑘) : [1,1]
Nó nói rằng, một công ty bị gián đoạn ở một timestep cụ thể nếu ít nhất 50% nhà cung cấp của nó bị gián đoạn hoàn toàn ở timestep trước đó. Chúng tôi thực hiện thí nghiệm này cho ba quốc gia khác nhau (Hoa Kỳ, Đài Loan, và Úc), có một phạm vi rộng tỷ lệ công ty trong dataset. Chúng tôi không cố định số bước suy luận, thay vào đó chúng tôi để quá trình khuếch tán chạy cho đến khi nó hội tụ (in đậm). Kết quả được hiển thị trong Bảng 1.

Để kiểm tra nếu cách tiếp cận của chúng tôi có thể mở rộng, chúng tôi sử dụng hai quy tắc suy luận kết hợp nói rằng, một công ty bị gián đoạn ở một timestep cụ thể nếu bất kỳ nhà cung cấp nào của nó bị gián đoạn hoàn toàn ở timestep trước đó, hoặc nếu ít nhất 50% nhà cung cấp của nó bị gián đoạn ít nhất 50% công suất của chúng. Chúng tôi thực hiện thí nghiệm này cho các kích thước đồ thị khác nhau, và cho số timestep khác nhau để

--- TRANG 12 ---
Bảng 2
Khả năng mở rộng của framework chúng tôi
Nút (N) Cạnh (E) Tổng thuộc tính Mật độ Timestep Thời gian chạy (giây) Bộ nhớ (MB)
1000 410 5012 4.10 x 10−42 0.36 4.9
5 0.42 1.8
15 0.34 0.1
2000 1640 13269 4.10 x 10−42 0.43 1.2
5 0.55 2.1
15 0.81 8.2
5000 10244 57852 4.10 x 10−42 1.54 17.2
5 1.84 16.0
15 3.38 54.6
10000 41034 197752 4.10 x 10−42 4.83 80.3
5 6.29 60.3
15 12.34 210.8

hiển thị khả năng mở rộng của phần mềm chúng tôi trong Bảng 2.
Kết quả cho thấy cả thời gian chạy và bộ nhớ gần như không đổi trong các phạm vi lớn, và sau đó mở rộng sub-linear với sự tăng kích thước mạng.

4.2. Dataset Pokec Social Media
Pokec là một mạng xã hội slovakia phổ biến, và dataset này [22] chứa thông tin cá nhân như giới tính, tuổi, thú cưng (thuộc tính) của 1.6 triệu người (nút), và 30.6 triệu kết nối giữa họ (cạnh).

Chúng tôi lấy cảm hứng từ cộng đồng quảng cáo để thiết kế trường hợp sử dụng của chúng tôi. Chúng tôi xem xét một tỷ lệ nhỏ dân số, những người có thú cưng, là khách hàng của một công ty thức ăn thú cưng. Công ty, sử dụng dữ liệu Pokec, phải xác định các mục tiêu quảng cáo có liên quan trong dân số. Một chiến lược thực tế có thể được nắm bắt bởi hai quy tắc logic:
1.∀𝑋, 𝑌 𝑟𝑒𝑙𝑒𝑣𝑎𝑛𝑐𝑒 (𝑋) : [0.6,1]←Δ𝑡=1𝑟𝑒𝑙𝑒𝑣𝑎𝑛𝑐𝑒 (𝑌) : [1,1]∧𝑓𝑟𝑖𝑒𝑛𝑑 (𝑋, 𝑌 ) : [1,1]
Bạn của một mục tiêu có liên quan hoặc khách hàng hiện tại (luôn có liên quan), ít nhất có mức liên quan 60%.
2.∀𝑋, 𝑌 𝑟𝑒𝑙𝑒𝑣𝑎𝑛𝑐𝑒 (𝑋) : [1 ,1]←Δ𝑡=1𝑟𝑒𝑙𝑒𝑣𝑎𝑛𝑐𝑒 (𝑌) : [1 ,1]∧𝑓𝑟𝑖𝑒𝑛𝑑 (𝑋, 𝑌 ) : [1 ,1]∧
ℎ𝑎𝑠𝑃𝑒𝑡 (𝑋, 𝑃) : [1,1]∧ℎ𝑎𝑠𝑃𝑒𝑡 (𝑌, 𝑃) : [1,1]
Bạn của một mục tiêu có liên quan hoàn toàn có liên quan nếu họ có thú cưng cùng loại - chó, mèo, . . .
Quá trình khuếch tán hội tụ sau 8 timestep, mất 42 phút để hoàn thành và sử dụng 58.36 GB bộ nhớ - điều này tiếp tục thể hiện khả năng mở rộng của framework chúng tôi. Kết quả được hiển thị trong Bảng 3.

Quá trình suy luận hoàn toàn có thể giải thích, và người dùng có thể sử dụng rule traces, một đầu ra tùy chọn của PyReason, để xác định các quy tắc logic dẫn đến thay đổi trong mỗi diễn giải. Một ví dụ về rule trace từ thí nghiệm trước được trình bày trong Bảng 4.

Tất cả thí nghiệm được thực hiện trên container AWS EC2 với 96 vCPU (48 lõi) và bộ nhớ 384GB.

--- TRANG 13 ---
Bảng 3
Pokec social media: Cách các thương hiệu có thể sử dụng dữ liệu người tiêu dùng để xác định khách hàng triển vọng
Mục tiêu quảng cáo
Quy mô dân số Khách hàng hiện tại Timestep Hoàn toàn có liên quan Một phần có liên quan
1,632,803 2,308 0 2,308 0
1 2,596 39,836
2 2,657 47,405
3 2,679 49,174
4 2,690 50,046
5 2,692 50,412
6 2,693 50,455
7, 8, . . . 2,693 50,608

Bảng 4
Rule trace cho một nút duy nhất cho nhãn relevance. Việc áp dụng quy tắc 1 trên gây ra thay đổi đầu tiên từ [0,1] thành [0.6,1], theo sau bởi một cập nhật thành [1,1] do việc kích hoạt quy tắc 2. Một danh sách các ID nút và cạnh được sử dụng để ground các mệnh đề quy tắc cũng được cung cấp.
tOld
BoundNew
BoundRule
firedClause-1 Clause-2 Clause-3 Clause-4
1 [0.0,1.0] [0.6,1.0] rule_1 ['354455'] [('354365', '354455')]
2 [0.6,1.0] [1.0,1.0] rule_2 ['354455', [('354365', '354455'), [('718503', [('354365',
'718503'] ('354365', '718503')] 'cat')] 'cat')]

5. Công việc liên quan
Trong phần 1, chúng tôi đã thảo luận về cách PyReason mở rộng các ngôn ngữ lập trình logic hiện đại đầu tiên như Prolog [19], Epilog [20] và Datalog [34] bằng cách hỗ trợ chú thích. Các framework neuro symbolic gần đây cho thấy tiềm năng lớn trong khả năng học hoặc sửa đổi các chương trình logic để phù hợp với dữ liệu lịch sử và cải thiện độ bền vững với nhiễu. Nhiều framework như vậy dựa trên một logic bậc nhất mờ, có thể vi phân cơ bản. Ví dụ, logical tensor networks [1] sử dụng các phiên bản có thể vi phân của các toán tử mờ để kết hợp các mệnh đề nguyên tử ground và non-ground trong khi logical neural networks [2] liên kết các khoảng số thực với các mệnh đề nguyên tử và sử dụng các toán tử tham số hóa đặc biệt. Trong khi đó, các phương pháp quy nạp như differentiable ILP [3] các chương trình logic mờ (sử dụng product t-norm) được học từ dữ liệu dựa trên các cấu trúc quy tắc template theo cách hỗ trợ đệ quy và suy luận nhiều bước. Trong [17], Logical Neural Networks được sử dụng để diễn giải các quy tắc đã học một cách chính xác. Ở đây cũng vậy, gradient descent được sử dụng để train các tham số của mạng. Trong hai năm qua, hai paradigm đã xuất hiện với sự phổ biến lớn trong văn học neuro symbolic. Logical Tensor Networks (LTN) [1] mở rộng các kiến trúc neural thông qua logic mờ, giá trị thực. Logical Neural Networks (LNN) [2] cung cấp một framework neuro symbolic với các toán tử tham số hóa hỗ trợ lý luận thế giới mở trong logic. Như đã nêu trước đó, cả hai có thể được xem như một tập con của logic chú thích. Do đó, PyReason có thể được sử dụng để thực hiện suy luận trên logic cho cả hai framework, ngoài việc cung cấp các khả năng chính như lý luận dựa trên đồ thị và thời gian, hiện tại không có trong logic của những framework đó.

Trong cả forward pass của các framework neuro symbolic khác nhau [35,2,1], cũng như cho các vấn đề tiếp theo (ví dụ: entailment, suy luận abductive, lập kế hoạch, v.v.), một quá trình suy luận là cần thiết. PyReason được thiết kế để cung cấp khả năng chính xác này. Các chương trình chú thích tổng quát [6] đã được chỉ ra là nắm bắt nhiều logic giá trị thực, thời gian, và mờ khác nhau vì nó liên kết các atom logic với các phần tử của cấu trúc lattice thay vì giá trị vô hướng. Kết quả là nó có thể nắm bắt tất cả các logic nói trên, trong khi vẫn giữ được suy luận thời gian đa thức do tính đơn điệu của lattice. Việc sử dụng cấu trúc lattice cho phép chúng ta liên kết các cấu trúc logic với các khoảng, do đó cho phép lý luận thế giới mở. Trong công việc gần đây của chúng tôi [7], chúng tôi đã cung cấp các mở rộng cho [6] cho phép cấu trúc lattice thấp hơn cho chú thích. Điều này cho phép framework nắm bắt các paradigm như LNN [2] và MANCALog [9] cho lý luận dựa trên đồ thị. Tuy nhiên, công việc đó chỉ chỉ ra rằng các tương tự với các định lý của [7] cho trường hợp lattice thấp hơn và không cung cấp triển khai hoặc kết quả thực nghiệm.

Bằng cách hỗ trợ logic chú thích tổng quát và các mở rộng khác nhau của nó, PyReason cho phép thiết kế hệ thống độc lập với quá trình học. Kết quả là, một khi quá trình học neuro symbolic tạo ra hoặc sửa đổi một chương trình logic dựa trên dữ liệu, PyReason có thể được sử dụng để trả lời hiệu quả các truy vấn diễn dịch (bao gồm entailment và truy vấn nhất quán) cũng như hỗ trợ suy luận tinh vi hơn như suy luận abductive hoặc lập kế hoạch.

Ngày nay đồ thị tri thức rất quan trọng trong việc biểu diễn dữ liệu để lý luận và phân tích. Nghiên cứu gần đây về tạo ra đồ thị tri thức [36,37] đề xuất các phương pháp để tự động chuyển đổi các mô hình khái niệm thành đồ thị tri thức ở định dạng GraphML cho kiến trúc doanh nghiệp và một loạt các ứng dụng. PyReason, hỗ trợ định dạng graphml, có thể là một công cụ hiệu quả để lý luận về đồ thị tri thức thu được từ một trong những platform này.

6. Kết luận và Công việc Tương lai
Trong bài báo này, chúng tôi đã trình bày PyReason: một phần mềm suy luận có thể giải thích hỗ trợ các logic chú thích, thế giới mở, giá trị thực, dựa trên đồ thị, và thời gian. Triển khai hiện đại của chúng tôi mở rộng framework logic chú thích tổng quát đã được thiết lập để hỗ trợ lý luận có thể mở rộng và hiệu quả trên các đồ thị tri thức lớn và mô hình khuếch tán. Chúng tôi hiện đang làm việc trên một loạt các mở rộng cho công việc này. Điều này bao gồm thêm nhiều toán tử logic thời gian cho kiểm tra đặc tả, học quy tắc từ dữ liệu thông qua quy nạp, và sử dụng quá trình suy luận để tạo ra kiến thức mới trong đồ thị non-static (ví dụ: thêm nút và cạnh). Chúng tôi cũng sẽ tìm cách khám phá cách PyReason có thể được sử dụng kết hợp với LTN [1], và LNN [2]. Trong việc hỗ trợ các framework như thế này, chúng tôi sẽ tìm cách thêm khả năng cho symbol grounding [38], tận dụng kết quả của quá trình training từ các framework như LTN. Cuối cùng, chúng tôi cũng có kế hoạch mở rộng PyReason để hoạt động như một simulator cho các agent dựa trên reinforcement learning.

Lời cảm ơn
Các tác giả được hỗ trợ bởi tài trợ nội bộ từ Fulton Schools of Engineering và các phần của công việc này được hỗ trợ bởi Chương trình Chuyển giao Công nghệ Doanh nghiệp Nhỏ của Quân đội Hoa Kỳ

--- TRANG 15 ---
Office hoặc Army Research Office theo Hợp đồng số W911NF-22-P-0066.

Tài liệu tham khảo
[1]S. Badreddine, A. d'Avila Garcez, L. Serafini, M. Spranger, Logic tensor networks, Artificial Intelligence 303 (2022) 103649.
[2]R. Riegel, A. Gray, F. Luus, N. Khan, N. Makondo, I. Y. Akhalwaya, H. Qian, R. Fagin, F. Barahona, U. Sharma, S. Ikbal, H. Karanam, S. Neelam, A. Likhyani, S. Srivastava, Logical neural networks, 2020.
[3]R. Evans, E. Grefenstette, Learning explanatory rules from noisy data, J. Artif. Int. Res. 61 (2018) 1–64.
[4]M. Ma, J. Gao, L. Feng, J. Stankovic, STLnet: Signal temporal logic enforced multivariate recurrent neural networks, in: Advances in Neural Information Processing Systems, volume 33, Curran Associates, Inc., 2020, pp. 14604–14614.
[5]P. Sen, B. W. Carvalho, I. Abdelaziz, P. Kapanipathi, S. Roukos, A. Gray, Logical neural networks for knowledge base completion with embeddings & rules, in: Conference on Empirical Methods in Natural Language Processing, 2022, pp. 3863–3875.
[6]M. Kifer, V. Subrahmanian, Theory of generalized annotated logic programming and its applications, J. Log. Program. 12 (1992) 335–367.
[7]P. Shakarian, G. I. Simari, Extensions to generalized annotated logic and an equivalent neural architecture, in: 2022 TransAI, 2022, pp. 63–70.
[8]P. Shakarian, G. I. Simari, D. Callahan, Reasoning about complex networks: A logic programming approach, Theory Pract. Log. Program. 13 (2013).
[9]P. Shakarian, G. I. Simari, R. Schroeder, Mancalog: a logic for multi-attribute network cascades, in: International conference on Autonomous Agents and Multi-Agent Systems, AAMAS, 2013, pp. 1175–1176.
[10] U. Höhle, Probabilistic uniformization of fuzzy topologies, Fuzzy Sets and Systems (1978).
[11] C. Alsina, E. Trillas, L. Valverde, On some logical connectives for fuzzy sets theory, Journal of Mathematical Analysis and Applications 93 (1983) 15–26.
[12] P. Vojtáš, Fuzzy logic programming, Fuzzy sets and systems 124 (2001) 361–370.
[13] M. H. Van Emden, R. A. Kowalski, The semantics of predicate logic as a programming language, J. ACM 23 (1976) 733–742.
[14] M. Fitting, Bilattices in logic programming, City University of New York, Lehman College, Department of Mathematics and Computer Science, 1990.
[15] P. Shakarian, M. Broecheler, V. Subrahmanian, C. Molinaro, Using generalized annotated programs to solve social network diffusion optimization problems, ACM Transactions on Computational Logic 14 (2013).
[16] H. Shindo, M. Nishino, A. Yamamoto, Differentiable inductive logic programming for structured examples, in: AAAI Conference on Artificial Intelligence, 2021, pp. 5034–5041.
[17] P. Sen, B. W. S. R. d. Carvalho, R. Riegel, A. Gray, Neuro-symbolic inductive logic programming with logical neural networks, AAAI conference on Artificial Intelligence (2022).
[18] P. Hohenecker, T. Lukasiewicz, Ontology reasoning with deep neural networks, in: Journal of Artificial Intelligence Research, volume 68, 2020, pp. 503–540.

--- TRANG 16 ---
[19] A. Colmerauer, Prolog and infinite trees, Logic Programming 16 (1982) 2.
[20] L. K. Schubert, C. H. Hwang, Episodic logic meets little red riding hood: A comprehensive, natural representation for language understanding, Natural language processing and knowledge representation: Language for Knowledge and Knowledge for Language (2000).
[21] T. Yan, T. Y. Choi, Y. Kim, Y. Yang, A theory of the nexus supplier: A critical supplier from a network perspective, Journal of Supply Chain Management 51 (2015) 52–66.
[22] L. Takac, M. Zabovsky, Data analysis in public social networks, in: International scientific conference and international workshop present day trends of innovations, 2012.
[23] A. Dekhtyar, M. I. Dekhtyar, V. S. Subrahmanian, Temporal probabilistic logic programs, in: International Conference on Logic Programming, 1999, p. 109–123.
[24] S. Khuller, M. V. Martinez, D. S. Nau, A. Sliva, G. I. Simari, V. S. Subrahmanian, Computing most probable worlds of action probabilistic logic programs: scalable estimation for 1030, 000worlds, Ann. Math. Artif. Intell. 51 (2007) 295–331.
[25] P. Shakarian, A. Parker, G. Simari, V. V. S. Subrahmanian, Annotated probabilistic temporal logic, ACM Trans. Comput. Logic 12 (2011).
[26] M. V. França, G. Zaverucha, A. S. d'Avila Garcez, Fast relational learning using bottom clause propositionalization with artificial neural networks, Machine learning 94 (2014).
[27] R. Agrawal, H. Mannila, R. Srikant, H. Toivonen, A. I. Verkamo, et al., Fast discovery of association rules., Advances in knowledge discovery and data mining 12 (1996) 307–328.
[28] J. R. Quinlan, Learning logical definitions from relations, Machine learning 5 (1990).
[29] A. Stanton, A. Thart, A. Jain, P. Vyas, A. Chatterjee, P. Shakarian, Mining for causal relationships: A data-driven study of the islamic state, in: ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2015, pp. 2137–2146.
[30] P. Shakarian, A. Parker, G. Simari, V. V. Subrahmanian, Annotated probabilistic temporal logic, ACM Transactions on Computational Logic (TOCL) 12 (2011) 1–44.
[31] P. Shakarian, G. I. Simari, V. Subrahmanian, Annotated probabilistic temporal logic: Approximate fixpoint implementation, ACM Transactions on Computational Logic (TOCL) 13 (2012) 1–33.
[32] P. Sen, B. W. de Carvalho, R. Riegel, A. Gray, Neuro-symbolic inductive logic programming with logical neural networks, in: AAAI Conference on Artificial Intelligence, 2022.
[33] J. N. Paredes, G. I. Simari, M. V. Martinez, M. A. Falappa, Detecting malicious behavior in social platforms via hybrid knowledge- and data-driven systems, Future Generation Computer Systems 125 (2021) 232–246.
[34] S. Abiteboul, R. Hull, V. Vianu, Foundations of databases, volume 8, Addison-Wesley Reading, 1995.
[35] Z. Yang, A. Ishay, J. Lee, Neurasp: Embracing neural networks into answer set programming, in: International Joint Conference on Artificial Intelligence, IJCAI, 2020.
[36] M. Smajevic, D. Bork, From conceptual models to knowledge graphs: a generic model transformation platform, in: 2021 ACM/IEEE International Conference on Model Driven Engineering Languages and Systems Companion (MODELS-C), IEEE, 2021, pp. 610–614.
[37] P.-L. Glaser, S. J. Ali, E. Sallinger, D. Bork, Model-based construction of enterprise architecture knowledge graphs, in: Enterprise Design, Operations, and Computing: 26th International Conference, Springer, 2022, pp. 57–73.
[38] S. Harnad, The symbol grounding problem, Physica D: Nonlinear Phenomena 42 (1990).

--- TRANG 17 ---
[39] J. W. Lloyd, Foundations of logic programming, Springer-Verlag New York, Inc., 1987.

A. Cú pháp và Ngữ nghĩa Chính thức.
Chúng tôi giờ tóm tắt lại định nghĩa của các chương trình Logic Chú thích Tổng quát (từ giờ được gọi là "GAP", viết tắt) từ [6] cũng như các mở rộng mà chúng tôi bao gồm trong phần mềm của mình.

Trong [6], các tác giả giả định sự tồn tại của một semilattice. 𝒯(không nhất thiết phải hoàn chỉnh) với thứ tự ⊑. Để hỗ trợ các ứng dụng đương đại trong lý luận neuro symbolic [2,3,7,16,17] cũng như phân tích mạng xã hội [9,8], chúng tôi đã triển khai điều này như một cấu trúc semilattice thấp hơn. Do đó, chúng ta có một phần tử duy nhất ⊥ và nhiều phần tử top ⊤0, . . .⊤𝑖. . .⊤𝑚𝑎𝑥. Ký hiệu ℎ𝑒𝑖𝑔ℎ𝑡 (𝒯) là số lượng phần tử tối đa trong lattice trong một đường dẫn giữa ⊥ và một phần tử top (bao gồm ⊥ và phần tử top)2. Việc sử dụng cấu trúc semilattice thấp hơn cho phép hai đặc tính mong muốn. Đầu tiên, chúng tôi mong muốn chú thích các atom với các khoảng số thực trong [0,1] như được thực hiện trong công việc trước đây [2,9,25]. Thứ hai, nó cho phép lý luận về các khoảng như vậy theo đó mức độ không chắc chắn (tức là cho khoảng [𝑙, 𝑢] số lượng 𝑢−ℓ) giảm đơn điệu khi một toán tử tiến lên cấu trúc lattice. Do đó, chúng tôi định nghĩa phần tử bottom ⊥= [0,1] và một tập hợp các phần tử top {[𝑥, 𝑥]|[𝑥, 𝑥]⊆[0,1]}(xem ghi chú3). Cụ thể, chúng tôi đặt ⊤0= [0,0] và ⊤𝑚𝑎𝑥= [1,1]. Một ví dụ về cấu trúc semilattice như vậy được hiển thị trong Hình 2.

Hình 2: Ví dụ về cấu trúc semilattice thấp hơn nơi các phần tử là khoảng trong [0,1].

Như với [6], chúng tôi giả định sự tồn tại của một tập AVar của các ký hiệu biến trong phạm vi 𝒯 và một tập ℱ của các ký hiệu hàm, mỗi ký hiệu có một arity liên quan. Chúng tôi bắt đầu bằng cách định nghĩa chú thích.

Định nghĩa A.1 (Chú thích). (i)Bất kỳ thành viên nào của 𝒯 ∪ AVar đều là một chú thích.
(ii)Nếu 𝑓 là một ký hiệu hàm 𝑛-ary trên 𝒯 và 𝑡1, . . . , 𝑡 𝑛 là các chú thích, thì 𝑓(𝑡1, . . . , 𝑡 𝑛) là một chú thích.

2Nói chung, chúng tôi sẽ giả định rằng lattice bao gồm các phần tử hữu hạn, rời rạc.
3N.B. rằng khi sử dụng semilattice của các ranh giới, ký hiệu " ⊑" mất "trực giác tập con" của nó, vì [0,1]⊑[1,1] trong trường hợp này, ví dụ.

--- TRANG 18 ---
Một hàm cụ thể mà chúng tôi định nghĩa là " ¬" được sử dụng trong ngữ nghĩa của [6] cũng như framework dựa trên khoảng gần đây hơn được sử dụng trong [2]. Với một [𝑙, 𝑢] cho trước,¬([𝑙, 𝑢]) = [1−𝑢,1−𝑙]. Lưu ý rằng chúng ta cũng sử dụng ký hiệu ¬ trong ngôn ngữ bậc nhất của chúng ta (theo chủ nghĩa hình thức của [6]). Chúng tôi định nghĩa một ngôn ngữ logic riêng biệt có các hằng số là thành viên của tập 𝒞 và có các ký hiệu predicate được chỉ định bởi tập 𝒫. Chúng tôi cũng giả định sự tồn tại của một tập 𝒱 các ký hiệu biến trong phạm vi các hằng số, rằng không có ký hiệu hàm nào, và các term và atom được định nghĩa theo cách thông thường (cf. [39]). Chúng tôi sẽ giả định rằng 𝒞,𝒫,𝒱 là rời rạc và hữu hạn. Nói chung, chúng tôi sẽ sử dụng chữ cái viết hoa cho các ký hiệu biến và chữ cái viết thường cho các hằng số. Tương tự như công việc trước đây [3,18] sẽ giả định rằng tất cả các phần tử của 𝒫 có arity là 1 hoặc 2 - vì vậy chúng tôi sẽ ký hiệu này 𝒫𝑢𝑛𝑎 cho predicate unary và 𝒫𝑟𝑒𝑙 cho predicate binary. Chúng tôi cũng sẽ ký hiệu một tập con của 𝒫 để bao gồm "target predicate" được viết 𝒫𝑡𝑔𝑡 có thể bao gồm predicate binary hoặc unary ( 𝒫𝑡𝑔𝑡_𝑟𝑒𝑙,𝒫𝑡𝑔𝑡_𝑢𝑛𝑎) miễn là chúng không phải là từ dành riêng. Chúng tôi sẽ sử dụng ký hiệu ℒ để ký hiệu tập hợp tất cả các literal ground và 𝒜 cho tập hợp tất cả các atom ground. Bây giờ chúng tôi định nghĩa cấu trúc cú pháp của GAP sẽ được sử dụng trong công việc này.

Định nghĩa A.2 (Atom chú thích, phủ định, literal). Các cấu trúc cú pháp cốt lõi được định nghĩa như sau:
•Atom chú thích. Nếu 𝑎 là một atom và 𝜇 là một chú thích, thì 𝑎:𝜇 là một atom chú thích.
•Phủ định Chú thích. Nếu 𝑎 là một atom và 𝜇 là một chú thích, thì ¬𝑎:𝜇 là một phủ định chú thích.
•Literal Chú thích. Tổng hợp, các atom và phủ định được gọi là literal chú thích.

Định nghĩa A.3 (Quy tắc GAP). Nếu ℓ0:𝜇0, ℓ1:𝜇1, . . . , ℓ 𝑚:𝜇𝑚 là các literal chú thích (sao cho với tất cả 𝑖, 𝑗∈1, 𝑚,ℓ𝑖̸≡ℓ𝑗), thì
𝑟≡ℓ0:𝜇0←ℓ1:𝜇1∧. . .∧ℓ𝑚:𝜇𝑚
được gọi là một quy tắc GAP. Chúng tôi sẽ sử dụng ký hiệu ℎ𝑒𝑎𝑑 (𝑟) và 𝑏𝑜𝑑𝑦(𝑟) để ký hiệu ℓ0 và {ℓ1, . . . , ℓ 𝑚} tương ứng. Khi 𝑚= 0 (𝑏𝑜𝑑𝑦(𝑟) =∅), quy tắc GAP trên được gọi là một sự kiện. Một quy tắc GAP là ground khi và chỉ khi không có xuất hiện nào của các biến từ AVar hoặc 𝒱 trong nó. Với quy tắc ground 𝑟 và literal ground ℓ,𝑏𝑜𝑑𝑦𝐴𝑛𝑛𝑜 (ℓ, 𝑟) =𝜇 sao cho ℓ:𝜇 xuất hiện trong thân của 𝑟. Một chương trình chú thích tổng quát Π là một tập hợp hữu hạn các quy tắc GAP.

Ngữ nghĩa chính thức của GAP được định nghĩa như sau. Lưu ý rằng chúng tôi mở rộng khái niệm về một diễn giải để cho phép ánh xạ các literal thành chú thích (thay vì atom). Tuy nhiên, chúng tôi thêm một yêu cầu về chú thích giữa mỗi atom và phủ định đảm bảo sự tương đương với cấu trúc ngữ nghĩa của [6].

Định nghĩa A.4 (Diễn giải). Một diễn giải 𝐼 là bất kỳ ánh xạ nào từ tập hợp tất cả literal ground đến 𝒯 sao cho với literal 𝑎,¬𝑎, chúng ta có 𝐼(𝑎) =¬(𝐼(¬𝑎)). Tập ℐ của tất cả diễn giải có thể được sắp xếp từng phần thông qua thứ tự: 𝐼1⪯𝐼2 khi và chỉ khi với tất cả literal ground 𝑎,𝐼1(ℓ)⊑𝐼2(ℓ).ℐ tạo thành một lattice hoàn chỉnh dưới thứ tự ⪯.

Bây giờ chúng tôi trình bày mối quan hệ thỏa mãn:

--- TRANG 19 ---
Định nghĩa A.5 (Thỏa mãn). Một diễn giải 𝐼 thỏa mãn một literal ground ℓ:𝜇, ký hiệu 𝐼|=ℓ:𝜇, khi và chỉ khi 𝜇⊑𝐼(ℓ).𝐼 thỏa mãn quy tắc GAP ground
ℓ0:𝜇0←ℓ1:𝜇1∧. . .∧ℓ𝑚:𝜇𝑚
(ký hiệu 𝐼|=ℓ0:𝜇0←ℓ1:𝜇1∧. . .∧ℓ𝑚:𝜇𝑚) khi và chỉ khi hoặc
1.𝐼 thỏa mãn ℓ0:𝜇0 hoặc
2.Tồn tại một 1≤𝑖≤𝑚 sao cho 𝐼 không thỏa mãn ℓ𝑖:𝜇𝑖.
𝐼 thỏa mãn một literal hoặc quy tắc non-ground khi và chỉ khi 𝐼 thỏa mãn tất cả các instance ground của nó.

Chúng ta nói rằng một diễn giải 𝐼 là một mô hình của chương trình Π nếu nó thỏa mãn tất cả các quy tắc trong Π. Tương tự, chương trình Π là nhất quán nếu tồn tại một 𝐼 nào đó là mô hình của Π. Chúng ta nói Π entail ℓ:𝜇, ký hiệu Π|=ℓ:𝜇, khi và chỉ khi với mọi diễn giải 𝐼 s.t.𝐼|= Π , chúng ta có 𝐼|=ℓ:𝜇. Như được chỉ ra bởi [6], chúng ta có thể liên kết một toán tử điểm cố định với bất kỳ GAP Π nào ánh xạ diễn giải thành diễn giải.

Định nghĩa A.6. Giả sử Π là bất kỳ GAP nào và 𝐼 là một diễn giải. Ánh xạ TΠ ánh xạ diễn giải thành diễn giải được định nghĩa là
TΠ(𝐼)(ℓ0) =sup(𝑎𝑛𝑛𝑜𝑆𝑒𝑡 Π,𝐼(ℓ0)),
trong đó 𝑎𝑛𝑛𝑜𝑆𝑒𝑡 Π,𝐼(ℓ0) ={𝐼(ℓ0)}∪{𝜇0|ℓ0:𝜇0←ℓ1:𝜇1∧. . .∧ℓ𝑚:𝜇𝑚 là một instance ground của một quy tắc trong Π,và với tất cả 1≤𝑖≤𝑚,chúng ta có 𝐼|=ℓ𝑖:𝜇𝑖}

Kết quả chính của [6] cho chúng ta biết rằng lfp(TΠ) chính xác nắm bắt các hệ quả logic nguyên tử ground của Π. Chúng tôi chỉ ra điều này cũng đúng (dưới điều kiện Π là nhất quán) ngay cả khi các chú thích dựa trên lattice thấp hơn. Trong [6], các tác giả cũng định nghĩa sự lặp lại của TΠ như sau:
•TΠ↑0 là diễn giải gán ⊥ cho tất cả literal ground.
•TΠ↑(𝑖+ 1) = TΠ(TΠ↑𝑖).
Với mỗi ground ℓ∈ℒ, tập Π(ℓ) là tập con của các quy tắc ground (bao gồm sự kiện) trong Π nơi ℓ ở trong đầu. Chúng tôi sẽ sử dụng ký hiệu 𝑚ℓ để ký hiệu số lượng quy tắc trong Π(ℓ). Với một quy tắc ground cho trước, chúng tôi sẽ sử dụng ký hiệu 𝑟ℓ,𝑖 để ký hiệu rằng đó là quy tắc thứ 𝑖 với atom ℓ trong đầu.

B. Chứng minh Chính thức cho Kết quả nơi Giả định Lattice Thấp hơn được Đưa ra.
Xin vui lòng xem [7].

--- TRANG 20 ---
Bảng 5
Tổng quan về Mạng Honda Buyer-Supplier
Công ty (Nút) 10,893
Quan hệ Buyer-Supplier (Cạnh) 47,247
Loại Global Industry Classification Standard (GICS) 67
Loại quan hệ Cạnh 4

C. Chi tiết Bổ sung về Thí nghiệm Chuỗi Cung ứng
Bảng 5 tóm tắt nội dung của dataset. 7,396 công ty được liệt kê với GICS duy nhất, trong khi 3,497 không có GICS được liệt kê.

Để hiểu cấu trúc của mạng buyer-supplier sâu hơn, một ngành công nghiệp cùng với các nhà cung cấp Tier đầu tiên và thứ hai được ánh xạ, như được hiển thị trong Hình 3. Mỗi nút được hiển thị trong hình chứa một tên thuộc tính mô tả tên của ngành công nghiệp và mỗi cạnh kết nối những ngành công nghiệp đó chứa một thuộc tính cost mô tả mối quan hệ lợi nhuận giữa hai ngành công nghiệp cụ thể đó được kết nối bởi một cạnh.

Trong Hình 4, một phần dữ liệu được ánh xạ cho thấy độ phức tạp của mạng cung ứng. Hình có thể giúp xác định một vài nút chính kết nối các phần lớn của mạng với các phần chính khác - điều này làm cho chúng quan trọng đối với hoạt động.

Hình 5 cho thấy phân phối các loại ngành công nghiệp khác nhau. Hình 6 đưa ra các loại quan hệ cạnh khác nhau có trong dataset.

D. Chi tiết Bổ sung về Thí nghiệm Mạng Xã hội
Bảng 6 đưa ra tổng quan về dataset, và schema được hiển thị trong Hình 7. Các loại quan hệ cạnh được liệt kê trong hình.

Mật độ đồ thị đại diện cho tỷ lệ giữa các cạnh có trong đồ thị và số lượng cạnh tối đa mà đồ thị có thể chứa. Trong thực tế, đồ thị thường thưa thớt (không dày đặc). Để

Hình 3: Một ảnh chụp của mạng cho thấy các kết nối liên kết với nhãn thuộc tính

--- TRANG 21 ---
Hình 4: Mạng Chuỗi Cung ứng Honda. Mỗi nút và cạnh được tô màu khác nhau dựa trên loại.

Hình 5: Phân phối các nút trong mạng dựa trên loại GICS của nó.

kiểm tra khả năng mở rộng của cách tiếp cận chúng tôi với mật độ đồ thị, chúng tôi chạy lại thí nghiệm trong Bảng 2 trong khi sửa đổi mật độ của dataset. Kết quả, trong Bảng 7, cho thấy các thí nghiệm trên dữ liệu Honda, dày đặc hơn khoảng 40 lần so với mạng Pokec chỉ mất khoảng 3 lần bộ nhớ hơn, và 6 lần thời gian chạy hơn để hoàn thành. Điều này tiếp tục thể hiện khả năng mở rộng của framework chúng tôi.

Cuối cùng, để kiểm tra khả năng mở rộng của cách tiếp cận chúng tôi đối với số lượng thuộc tính (và do đó, số lượng atom ground) trong một đồ thị, chúng tôi chạy một thí nghiệm cho một trường hợp sử dụng đơn giản - một lần với dataset gốc, và sau đó với các thuộc tính được thêm vào. Chúng tôi định nghĩa trường hợp sử dụng trên dữ liệu mạng xã hội là:
∀𝑋, 𝑌 𝑖𝑛𝑓𝑒𝑐𝑡𝑒𝑑 (𝑋) : [1,1]←Δ𝑡=1𝑖𝑛𝑓𝑒𝑐𝑡𝑒𝑑 (𝑌) : [1,1]∧𝑓𝑟𝑖𝑒𝑛𝑑 (𝑋, 𝑌 ) : [1,1]

--- TRANG 22 ---
Hình 6: Quan hệ cạnh trong dataset.

Bảng 6
Tổng quan về dataset Pokec Social Media
Nút 1,632,820
Cạnh 31,633,113
Loại thuộc tính Nút 5
Loại quan hệ Cạnh 4

có nghĩa là, "Một người nhiễm virus nếu bất kỳ bạn nào của họ bị nhiễm virus." Kết quả được hiển thị trong Bảng 8.

E. Rule Trace Mở rộng
Một phiên bản dài hơn của rule trace trong Bảng 4, với 10 atom được trình bày trong Bảng 9.

Hình 7: Schema của mạng Pokec

--- TRANG 23 ---
Bảng 7
Tác động của mật độ đồ thị đến bộ nhớ và thời gian chạy
Honda Pokec
Mật độ→ 4.10 x 10−40.11 x 10−4
Nút (N) Timestep Thời gian chạy (giây) Bộ nhớ (MB) Thời gian chạy (giây) Bộ nhớ (MB)
10000 2 4.83 80.3 0.70 27.4
5 6.29 60.3 0.93 19.9
15 12.34 210.8 1.73 21.2

Bảng 8
Tác động của việc thêm 7 thuộc tính đến bộ nhớ và thời gian chạy cho 5 timestep
Thuộc tính Nút (N) Cạnh (E) Atom ground Thời gian chạy (phút) Bộ nhớ (GB)
Không thêm 1,632,803 30,622,563 3,265,606 19.95 42.44
Đã thêm 1,632,820 31,633,113 36,531,539 28.26 59.39
Thay đổi (+17) (+1,010,550) (+33,265,933) (+8.31) (+16.95)

F. Pseudocode Triển khai
Thuật toán 1 liệt kê các cấu trúc dữ liệu đang sử dụng. Thuật toán 2 hiển thị trạng thái ban đầu, trong khi thuật toán 3 chi tiết quá trình suy luận. Trong quá trình suy luận, các diễn giải được cập nhật như được hiển thị trong thuật toán 4. Tính nhất quán logic được duy trì bằng thuật toán 5 và 6.

Thuật toán 1 Cấu trúc Dữ liệu Được Sử dụng
1:Nested Dictionary 𝐼= [𝑁𝑜𝑑𝑒/𝐸𝑑𝑔𝑒, [𝑃𝑟𝑒𝑑𝑖𝑐𝑎𝑡𝑒, [𝐿𝑜𝑤𝑒𝑟, 𝑈𝑝𝑝𝑒𝑟, 𝑆𝑡𝑎𝑡𝑖𝑐 ]]] để lưu trữ chỉ diễn giải hiện tại. Nếu 𝑆𝑡𝑎𝑡𝑖𝑐 được đặt thành 1, ranh giới: 𝐿𝑜𝑤𝑒𝑟, 𝑈𝑝𝑝𝑒𝑟 không thể thay đổi nữa cho phần còn lại của chương trình.
2:List𝐿= [(𝑁𝑜𝑑𝑒/𝐸𝑑𝑔𝑒, 𝑃𝑟𝑒𝑑𝑖𝑐𝑎𝑡𝑒, 𝐿𝑜𝑤𝑒𝑟, 𝑈𝑝𝑝𝑒𝑟, 𝑆𝑡𝑎𝑡𝑖𝑐, 𝑎𝑡 _𝑡)] để lưu trữ sự kiện và suy luận, trước khi nó được sử dụng để cập nhật dictionary.
3:ListIPL= [(𝑃𝑟𝑒𝑑𝑖𝑐𝑎𝑡𝑒 1, 𝑃𝑟𝑒𝑑𝑖𝑐𝑎𝑡𝑒 2)] chứa các cặp predicate không thể cùng tồn tại, tức là các ranh giới phải bổ sung từng cặp. Trong trường hợp mệnh đề, nếu một trong các predicate là 𝑡𝑟𝑢𝑒, predicate kia phải là 𝑓𝑎𝑙𝑠𝑒. Chúng tôi gọi đây là "danh sách predicate không nhất quán (IPL)".
4:List𝐸= [(𝑁𝑜𝑑𝑒/𝐸𝑑𝑔𝑒, 𝑃𝑟𝑒𝑑𝑖𝑐𝑎𝑡𝑒 )] chứa danh sách predicate trở nên không nhất quán trong quá trình thực thi chương trình.

--- TRANG 24 ---
Thuật toán 2 Khởi tạo chương trình
1:𝐼 như sau:
∀nodes/edges, sử dụng 𝑡𝑦𝑝𝑒_𝑐ℎ𝑒𝑐𝑘𝑖𝑛𝑔 để khởi tạo chỉ predicate hợp lệ.
Tất cả ranh giới được khởi tạo thành [0,1]. 𝑆𝑡𝑎𝑡𝑖𝑐 được đặt thành 0.
2:𝐿←[ ] ◁Danh sách rỗng
Sự kiện (bao gồm diễn giải ban đầu) sau đó được sao chép vào 𝐿
3:𝑡←0
4:𝐸←[ ]
5:Đầu vào: Số timestep khuếch tán 𝑇, Tập quy tắc 𝑅

Thuật toán 3 Luồng chương trình
1:while 𝑡≤𝑇do
2: for𝑖in𝐼, where ( 𝑆𝑡𝑎𝑡𝑖𝑐 is𝑓𝑎𝑙𝑠𝑒 )do
3: đặt lại ranh giới thành [0,1]
4: end for
5: 𝑢𝑝𝑑𝑎𝑡𝑒 _𝑟𝑒𝑞←0
6: for𝑙in𝐿, where ( 𝑙(𝑎𝑡_𝑡) == 𝑡)do
7: ifcheck_consistency( 𝑙∈𝐿,𝑙∈𝐼)then
8: update_req += update_interp( 𝑙∈𝐿,𝑙∈𝐼)
9: else
10: resolve_inconsistency( 𝑙∈𝐼)
11: if(𝑙, 𝑙′)∈IPL,∀𝑙′then
12: resolve_inconsistency( 𝑙′∈𝐼)
13: end if
14: end if
15: end for
16: if𝑢𝑝𝑑𝑎𝑡𝑒 _𝑟𝑒𝑞then
17: Áp dụng toán tử điểm cố định( 𝑔𝑎𝑚𝑚𝑎 ) một lần.
18: foreach kết quả diễn giải do
19: if𝑆𝑡𝑎𝑡𝑖𝑐 is𝑓𝑎𝑙𝑠𝑒 in𝐼then
20: Thêm vào𝐿
21: end if
22: end for
23: Đi đến dòng 5.
24: else
25: 𝑡←𝑡+ 1.
26: end if
27:end while

--- TRANG 25 ---
Bảng 9
Một phiên bản dài hơn của rule trace từ Bảng 4 cho Label:relevance
Bound
tΓNode Old New Rule
firedClause-1 Clause-2 Clause-3 Clause-4
1 1 1273439 [0.0,1.0] [1.0,1.0] rule_2 ['835886'] [('1273439', '835886')] [('835886',
'cat')][('1273439',
'cat')]
1 1 103308 [0.0,1.0] [0.6,1.0] rule_1 ['659792',
'404372'][('103308', '659792'),
('103308', '404372')]
2 2 277684 [0.0,1.0] [1.0,1.0] rule_2 ['305645'] [('277684', '305645')] [('305645',
'fish')][('277684',
'fish')]
2 2 551249 [0.0,1.0] [0.6,1.0] rule_1 ['377195'] [('551249', '377195')]
3 3 861455 [0.0,1.0] [1.0,1.0] rule_2 ['1450147'] [('861455', '1450147')] [('1450147',
'spider')][('861455',
'spider')]
3 3 23197 [0.0,1.0] [0.6,1.0] rule_1 ['25795'] [('23197', '25795')]
3 3 757646 [0.0,1.0] [0.6,1.0] rule_1 ['423053'] [('757646', '423053')]
4 4 86436 [0.0,1.0] [1.0,1.0] rule_2 ['743812'] [('86436', '743812')] [('743812',
'cat')][('86436',
'cat')]
4 4 40242 [0.0,1.0] [0.6,1.0] rule_1 ['407809'] [('40242', '407809')]
4 4 757646 [0.0,1.0] [1.0,1.0] rule_2 ['423053',
'548848'][('757646', '423053'),
('757646', '548848')][('548848',
'cat')][('757646',
'cat')]
5 5 420093 [0.0,1.0] [0.6,1.0] rule_1 ['275269',
'472129'][('420093', '275269'),
('420093', '472129')]
5 5 1334826 [0.0,1.0] [1.0,1.0] rule_2 ['1486432'] [('1334826', '1486432')] [('1486432',
'fish')][('1334826',
'fish')]
5 5 196947 [0.0,1.0] [0.6,1.0] rule_1 ['212129'] [('196947', '212129')]
6 6 348252 [0.0,1.0] [1.0,1.0] rule_2 ['1123497'] [('348252', '1123497')] [('1123497',
'cat')][('348252',
'cat')]
6 6 1144981 [0.0,1.0] [0.6,1.0] rule_1 ['232110'] [('1144981', '232110')]
6 6 420093 [0.0,1.0] [1.0,1.0] rule_2 ['275269',
'472129',
'275337'][('420093', '275269'),
('420093', '472129'),
('420093', '275337')][('275337',
'turtle')][('420093',
'turtle')]
7 7 354365 [0.0,1.0] [1.0,1.0] rule_2 ['354455',
'718503'][('354365', '354455'),
('354365', '718503')][('718503',
'cat')][('354365',
'cat')]
7 7 420093 [0.0,1.0] [1.0,1.0] rule_2 ['275269',
'472129',
'275337'][('420093', '275269'),
('420093', '472129'),
('420093', '275337')][('275337',
'turtle')][('420093',
'turtle')]
7 7 757646 [0.0,1.0] [1.0,1.0] rule_2 ['423053',
'548848'][('757646', '423053'),
('757646', '548848')][('548848',
'cat')][('757646',
'cat')]
7 7 50219 [0.0,1.0] [1.0,1.0] rule_2 ['2067',
'50136'][('50219', '2067'),
('50219', '50136')][('2067',
'cat'),
('50136',
'cat')][('50219',
'cat'),
('50219',
'cat')]
7 7 148995 [0.0,1.0] [0.6,1.0] rule_1 ['140490'] [('148995', '140490')]

--- TRANG 26 ---
Thuật toán 4 Cập nhật diễn giải
1:procedure update_interp (𝑖′, 𝑖)
2: 𝑢𝑝𝑑𝑎𝑡𝑒𝑑←0
3: if𝑖(𝐿𝑜𝑤𝑒𝑟 )! =𝑖′(𝐿𝑜𝑤𝑒𝑟 )(𝑜𝑟)𝑖(𝑈𝑝𝑝𝑒𝑟 )! =𝑖′(𝑈𝑝𝑝𝑒𝑟 )then
4: 𝑖(𝐿𝑜𝑤𝑒𝑟 )←𝑓𝑙(𝑖(𝐿𝑜𝑤𝑒𝑟 ), 𝑖′(𝐿𝑜𝑤𝑒𝑟 ))
◁theo mặc định 𝑓𝑙 là hàm 𝑚𝑎𝑥(), nhưng nó có thể được người dùng định nghĩa.
5: 𝑖(𝑈𝑝𝑝𝑒𝑟 )←𝑓𝑢(𝑖(𝑈𝑝𝑝𝑒𝑟 ), 𝑖′(𝑈𝑝𝑝𝑒𝑟 ))
◁theo mặc định 𝑓𝑢 là hàm 𝑚𝑖𝑛(), nhưng nó có thể được người dùng định nghĩa.
6: 𝑢𝑝𝑑𝑎𝑡𝑒𝑑←1
7: end if
8: if𝑢𝑝𝑑𝑎𝑡𝑒𝑑 (𝑎𝑛𝑑) (𝑖, 𝑖𝑐)∈IPL,∀𝑖𝑐then
9: 𝑖𝑐(𝐿𝑜𝑤𝑒𝑟 )←𝑓𝑙(𝑖𝑐(𝐿𝑜𝑤𝑒𝑟 ),1−𝑖(𝑈𝑝𝑝𝑒𝑟 ))
10: 𝑖𝑐(𝑈𝑝𝑝𝑒𝑟 )←𝑓𝑢(𝑖𝑐(𝑈𝑝𝑝𝑒𝑟 ),1−𝑖(𝐿𝑜𝑤𝑒𝑟 ))
11: end if
12: return 𝑢𝑝𝑑𝑎𝑡𝑒𝑑
13:end procedure

Thuật toán 5 Kiểm tra nhất quán
1:procedure check_consistency (𝑖′, 𝑖)
◁ 𝑖′ là diễn giải mới với [𝐿′, 𝑈′], và, 𝑖 là diễn giải hiện tại với [𝐿, 𝑈]
2: if𝐿′> 𝑈 (𝑜𝑟)𝑈′< 𝐿 then
3: return 𝐹𝑎𝑙𝑠𝑒
4: else
5: return 𝑇𝑟𝑢𝑒
6: end if
7:end procedure

Thuật toán 6 Giải quyết mâu thuẫn
1:procedure resolve_inconsistency (𝑖∈𝐼)
2: 𝑖(𝐿𝑜𝑤𝑒𝑟 )←0
3: 𝑖(𝑈𝑝𝑝𝑒𝑟 )←1
4: 𝑖(𝑆𝑡𝑎𝑡𝑖𝑐 )←1
5:end procedure
