DITTO: Tối ưu hóa T tại Thời điểm Suy luận Khuếch tán cho Tạo sinh Âm nhạc

Zachary Novack1 2 *Julian McAuley1Taylor Berg-Kirkpatrick1Nicholas J. Bryan2

Tóm tắt
Chúng tôi đề xuất Tối ưu hóa T tại Thời điểm Suy luận Khuếch tán (DITTO), một framework đa mục đích để điều khiển các mô hình khuếch tán văn bản-âm nhạc đã được tiền huấn luyện tại thời điểm suy luận thông qua tối ưu hóa các biến tiềm ẩn nhiễu ban đầu. Phương pháp của chúng tôi có thể được sử dụng để tối ưu hóa thông qua bất kỳ hàm mất mát khớp đặc trưng khả vi nào để đạt được đầu ra mục tiêu (được cách điệu hóa) và tận dụng gradient checkpointing để hiệu quả về mặt bộ nhớ. Chúng tôi chứng minh một phạm vi ứng dụng đáng ngạc nhiên rộng lớn cho tạo sinh âm nhạc bao gồm inpainting, outpainting và looping cũng như điều khiển cường độ, giai điệu và cấu trúc âm nhạc - tất cả mà không cần tinh chỉnh mô hình cơ bản. Khi so sánh phương pháp của chúng tôi với các phương pháp liên quan dựa trên huấn luyện, hướng dẫn và tối ưu hóa, chúng tôi thấy DITTO đạt được hiệu suất tiên tiến trên gần như tất cả các nhiệm vụ, bao gồm vượt trội hơn các phương pháp tương đương về khả năng điều khiển, chất lượng âm thanh và hiệu quả tính toán, từ đó mở ra cánh cửa cho việc điều khiển các mô hình khuếch tán chất lượng cao, linh hoạt và không cần huấn luyện. Các ví dụ âm thanh có thể được tìm thấy tại https://ditto-music.github.io/web/.

1. Giới thiệu

Các mô hình khuếch tán quy mô lớn (Ho et al., 2020) đã nổi lên như một mô hình dẫn đầu cho phương tiện truyền thông tạo sinh, với kết quả mạnh mẽ trong các phương thức đa dạng như tạo sinh văn bản-hình ảnh (TTI) (Rombach et al., 2022; Karras et al., 2022; Chen, 2023), tạo sinh video (Ho et al., 2022; Gupta et al., 2023), và tạo sinh đối tượng 3D (Watson et al., 2022; Poole et al., 2022). Gần đây, đã có sự phát triển ngày càng tăng trong việc áp dụng các phương pháp miền hình ảnh cho âm thanh bằng cách coi các phổ đồ tần số của âm thanh như hình ảnh, tạo ra kết quả đầy hứa hẹn trong tạo sinh âm thanh tổng quát văn bản-âm thanh (TTA) (Liu et al., 2023a;b; Huang et al., 2023b) và tạo sinh văn bản-âm nhạc (TTM) (Hawthorne et al., 2022; Forsgren & Martiros, 2022; Chen et al., 2023; Huang et al., 2023a; Schneider et al., 2023). Các phương pháp này hoạt động thông qua khuếch tán pixel hoặc tiềm ẩn (Rombach et al., 2022) trên các phổ đồ với điều khiển thể loại, tâm trạng, và/hoặc từ khóa được thể hiện qua các prompt văn bản.

Tuy nhiên, các phương pháp điều kiện văn bản này thường chỉ cung cấp điều khiển cấp cao (ví dụ: phong cách), thúc đẩy nghiên cứu sâu hơn.

Các nỗ lực hiện tại để thêm điều khiển chính xác hơn (ví dụ: điều kiện thay đổi theo thời gian) cho các mô hình khuếch tán TTM đầy hứa hẹn nhưng có những đánh đổi riêng. Các phương pháp dựa trên tinh chỉnh như ControlNet (Wu et al., 2023a; Saharia et al., 2022a; Zhang et al., 2023) yêu cầu huấn luyện có giám sát quy mô lớn với các ví dụ được gán nhãn cho mỗi phương thức điều khiển mới. Mặt khác, các phương pháp thời gian suy luận hướng dẫn quá trình lấy mẫu khuếch tán lại gặp khó khăn trong việc đạt được khả năng biểu đạt tinh tế do dựa vào các xấp xỉ của đầu ra mô hình trong quá trình lấy mẫu (Levy et al., 2023; Yu et al., 2023).

Để đạt được một mô hình điều khiển biểu đạt cho các mô hình khuếch tán TTM không yêu cầu huấn luyện có giám sát và có thể chấp nhận các tín hiệu điều khiển tùy ý tại thời điểm suy luận, chúng tôi đề xuất DITTO: Tối ưu hóa T tại Thời điểm Suy luận Khuếch tán.

DITTO tối ưu hóa các biến tiềm ẩn nhiễu ban đầu xT đối với một hàm mất mát khớp đặc trưng khả vi tùy ý qua bất kỳ quá trình lấy mẫu khuếch tán nào để điều khiển đầu ra mô hình, và đảm bảo sử dụng bộ nhớ hiệu quả thông qua gradient checkpointing (Chen et al., 2016). Mặc dù thường được coi là mã hóa ít thông tin (Song et al., 2020; Preechakul et al., 2022), chúng tôi chỉ ra sức mạnh và độ chính xác mà các biến tiềm ẩn nhiễu ban đầu có để điều khiển quá trình khuếch tán cho nhiều ứng dụng đa dạng trong sáng tạo âm nhạc, cho phép điều khiển đặc trưng có ý nghĩa âm nhạc và chỉnh sửa âm thanh chất lượng cao. So với các công trình tối ưu hóa trước đây từ bên ngoài miền âm thanh (Wallace et al., 2023a), DITTO đạt được điều khiển SOTA đồng thời cũng hiệu quả gấp 2 lần về thời gian và bộ nhớ. Nhìn chung, các đóng góp của chúng tôi là:

• DITTO: một framework mới, không cần huấn luyện để điều khiển các mô hình khuếch tán TTM đã được tiền huấn luyện bằng cách tối ưu hóa các biến tiềm ẩn nhiễu ban đầu để điều khiển đầu ra mô hình.

• Chúng tôi tận dụng gradient checkpointing để hiệu quả bộ nhớ mà không làm tổn hại quá trình lấy mẫu.

• Ứng dụng DITTO cho nhiều nhiệm vụ tinh tế theo thời gian, bao gồm inpainting âm thanh, outpainting, điều khiển giai điệu, điều khiển cường độ và điều khiển looping và cấu trúc âm nhạc mới được đề xuất.

• Đánh giá cho thấy phương pháp của chúng tôi vượt trội hơn MultiDiffusion (Bar-Tal et al., 2023), FreeDoM (Yu et al., 2023), Guidance Gradients (Levy et al., 2023), Music ControlNet (Wu et al., 2023a), và phương pháp tối ưu hóa tương đương DOODL (Wallace et al., 2023a), đồng thời nhanh hơn 2 lần và sử dụng một nửa bộ nhớ.

2. Công trình liên quan

2.1. Tổng quan về Tạo sinh Âm nhạc

Các công trình đầu tiên về âm nhạc tạo sinh tập trung vào tạo sinh ký hiệu (Dong et al., 2018; Chen et al., 2020; Dai et al., 2021). Gần đây, tạo sinh âm nhạc miền âm thanh đã trở nên phổ biến do những tiến bộ trong các mô hình ngôn ngữ (LMs) như MusicLM (Agostinelli et al., 2023) và các mô hình khuếch tán như AudioLDM (Liu et al., 2023a;b). Các phương pháp dựa trên LM thường hoạt động trên các token âm thanh nén rời rạc (Zeghidour et al., 2021; Kumar et al., 2023), tạo sinh âm thanh theo kiểu tự hồi quy (Borsos et al., 2023a; Agostinelli et al., 2023; Copet et al., 2023) hoặc không tự hồi quy (Garcia et al., 2023; Borsos et al., 2023b), và chuyển đổi các token được tạo sinh trở lại thành âm thanh trực tiếp. Mặt khác, các phương pháp dựa trên khuếch tán thường hoạt động bằng cách tạo sinh các biểu diễn 2D miền tần số của âm thanh hoặc phổ đồ được giải mã thành âm thanh thông qua vocoder (Forsgren & Martiros, 2022; Liu et al., 2023a;b; Schneider et al., 2023).

2.2. Các Mô hình Khuếch tán với Điều khiển Văn bản

Văn bản hiện là phương tiện điều khiển phổ biến nhất cho các mô hình khuếch tán. Ở đây, các chú thích văn bản được mã hóa thành embeddings và được tiêm vào mô hình tạo sinh trong quá trình huấn luyện thông qua cross attention, điều chế cộng dồn, hoặc tương tự như được tìm thấy trong Stable Diffusion (Rombach et al., 2022) hoặc Imagen (Saharia et al., 2022b). Mặc dù phổ biến, điều kiện văn bản toàn cục dựa trên chú thích thiếu điều khiển tinh tế (Zhang et al., 2023), thúc đẩy các lựa chọn thay thế và công trình hiện tại.

2.3. Các Phương pháp Điều khiển Thời gian Huấn luyện Thay thế

Việc tinh chỉnh các mô hình khuếch tán điều kiện văn bản hiện có với các đầu vào bổ sung khi thêm điều khiển nâng cao là phổ biến. Các mô hình kiểu ControlNet (Zhang et al., 2023; Zhao et al., 2023) sử dụng các tập dữ liệu ghép đôi lớn để tinh chỉnh các mô hình khuếch tán TTI bằng cách thêm các bộ điều hợp điều khiển cho các điều khiển được định nghĩa trước cụ thể như phát hiện cạnh hoặc ước lượng tư thế. Để giảm nhu cầu huấn luyện, một số công trình tinh chỉnh các mô hình được tiền huấn luyện trên một số lượng nhỏ ví dụ (Ruiz et al., 2023; Choi et al., 2023; Gal et al., 2022; Kawar et al., 2023). Những công trình khác đã khám phá việc sử dụng các mô hình thưởng bên ngoài để tinh chỉnh, thông qua tinh chỉnh trực tiếp (Clark et al., 2023; Prabhudesai et al., 2023) hoặc học tăng cường (Black et al., 2023). Tuy nhiên, các phương pháp như vậy vẫn yêu cầu một quá trình huấn luyện đắt đỏ và cơ chế điều khiển không thể được sửa đổi sau huấn luyện. Đối với âm nhạc, chỉ có phương pháp kiểu ControlNet đã được áp dụng (Wu et al., 2023a). Ngược lại, DITTO không yêu cầu huấn luyện quy mô lớn và có thể chấp nhận bất kỳ điều khiển khả vi nào tại thời điểm suy luận.

2.4. Điều khiển Dựa trên Hướng dẫn Thời gian Suy luận

Để tránh tinh chỉnh mô hình quy mô lớn, các phương pháp điều khiển thời gian suy luận đã trở nên ngày càng phổ biến. Các phương pháp đầu tiên bao gồm chỉnh sửa hình ảnh prompt-to-prompt (Hertz et al., 2022) và MultiDiffusion (Bar-Tal et al., 2023), cho phép chỉnh sửa đối tượng cục bộ và in/outpainting bằng cách kết hợp nhiều đường dẫn khuếch tán được che mặt lại với nhau. Các phương pháp như vậy dựa vào các mục tiêu điều khiển có thể được cục bộ hóa đến các vùng pixel cụ thể của hình ảnh và ít áp dụng được cho các phổ đồ âm thanh có tương ứng pixel gián tiếp qua tần số và nhiều nguồn chồng chéo cùng một lúc.

Chúng tôi cũng lưu ý đến lớp các phương pháp dựa trên hướng dẫn (Dhariwal & Nichol, 2021; Chung et al., 2023; Levy et al., 2023; Yu et al., 2023), giới thiệu các cập nhật tại mỗi bước lấy mẫu để điều hướng quá trình tạo sinh thông qua gradient của một bộ phân loại được tiền huấn luyện ∇xtLϕ(xt). Các phương pháp này thường yêu cầu một xấp xỉ của đầu ra mô hình trong quá trình lấy mẫu, không chính xác ở mức nhiễu cao và do đó hạn chế khả năng biểu đạt tinh tế. Đối với âm nhạc, các phương pháp dựa trên hướng dẫn chỉ được khám phá trong Levy et al. (2023). Ngược lại, DITTO tính toán gradients đối với nhiễu ban đầu trên đầu ra mô hình thực thông qua lấy mẫu, cho phép gradients chính xác ảnh hưởng đến toàn bộ quá trình tạo sinh.

2.5. Điều khiển Dựa trên Tối ưu hóa Thời gian Suy luận

Công trình gần đây đã cho thấy tối ưu hóa thông qua lấy mẫu khuếch tán là khả thi nếu bộ nhớ GPU được quản lý đúng cách. Tối ưu hóa trực tiếp các biến tiềm ẩn khuếch tán (DOODL) (Wallace et al., 2023a) tận dụng bộ lấy mẫu EDICT được đề xuất gần đây (Wallace et al., 2023b), sử dụng các lớp kết nối affine (ACLs) (Dinh et al., 2014; 2016) để tạo thành một quá trình lấy mẫu hoàn toàn khả nghịch, và lan truyền ngược thông qua EDICT để tối ưu hóa các biến tiềm ẩn nhiễu ban đầu để cải thiện các đặc trưng cấp cao như hướng dẫn CLIP và cải thiện thẩm mỹ trong hình ảnh. DOODL, trái ngược với phương pháp của chúng tôi, gặp khó khăn với các tín hiệu điều khiển tinh tế (Wallace et al., 2023a) và có nhiều nhược điểm do sự phụ thuộc vào EDICT bao gồm 1) nó bị hạn chế chỉ với các thuật toán lấy mẫu khả nghịch; 2) nó yêu cầu gấp đôi các đánh giá mô hình cho cả lấy mẫu thuận và nghịch làm tăng độ trễ và sử dụng bộ nhớ; và 3) nó có thể gặp vấn đề về ổn định và reward hacking do sự phân kỳ giữa các chuỗi khuếch tán ACL.

Karunratanakul et al. (2023) đề xuất lan truyền ngược thông qua lấy mẫu cho tạo sinh chuyển động con người (tức là các chuỗi ngắn của vị trí khớp). Công trình này tận dụng nhiều sửa đổi cụ thể miền để giảm sử dụng bộ nhớ, như sử dụng kiến trúc transformer encoder-only nhỏ (tức là <18M tham số), rất ít bước lấy mẫu, thời gian tối ưu hóa dài, và tạo sinh hoàn toàn không điều kiện. Do đó, phương pháp này không áp dụng được cho các nhiệm vụ tạo sinh tiêu chuẩn hơn với nhu cầu bộ nhớ cao hơn như văn bản-hình ảnh/âm thanh/âm nhạc, trong khi DITTO tránh mọi hạn chế về kiến trúc mô hình hoặc bộ lấy mẫu.

3. Tối ưu hóa T tại Thời điểm Suy luận Khuếch tán

3.1. Nền tảng Khuếch tán

Các mô hình xác suất khuếch tán khử nhiễu (DDPMs) (Sohl-Dickstein et al., 2015; Ho et al., 2020) hoặc các mô hình khuếch tán được định nghĩa bởi một quá trình Markov ngẫu nhiên thuận và nghịch. Quá trình thuận lấy dữ liệu sạch và làm hỏng nó lặp đi lặp lại với nhiễu để huấn luyện một mạng neural ϵθ. Mạng ϵθ thường nhận đầu vào là dữ liệu (nhiễu) xt, bước khuếch tán t, và thông tin điều kiện (văn bản) c. Quá trình nghịch lấy nhiễu ngẫu nhiên xT∼ N(0, I) và tinh chỉnh nó lặp đi lặp lại với mạng đã học để tạo sinh dữ liệu mới x0 qua T bước thời gian (ví dụ: 1000) thông qua quá trình lấy mẫu,

xt−1=1√αt(xt−1−αt√1−¯αtϵθ(xt, t,c))+σtϵ, (1)

trong đó ϵ∼ N (0, I), α0:= 1, αt và ¯αt định nghĩa lịch trình nhiễu, σt là độ lệch chuẩn lấy mẫu. Để giảm thời gian lấy mẫu, lấy mẫu Mô hình Khuếch tán Khử nhiễu Ẩn (DDIM) (Song et al., 2020) sử dụng một mục tiêu tối ưu hóa thay thế tạo ra một quá trình lấy mẫu nhanh hơn (ví dụ: 20−50 bước) có thể là xác định. Một cách rộng rãi, chúng ta có thể ký hiệu bất kỳ thuật toán lấy mẫu nào với ký hiệu xt−1=Sampler (ϵθ,xt, t,c).

Để cải thiện điều kiện văn bản, hướng dẫn không phân loại (CFG) có thể được sử dụng để pha trộn đầu ra tạo sinh có điều kiện và không điều kiện (Ho & Salimans, 2021). Khi huấn luyện với CFG, điều kiện được đặt ngẫu nhiên thành giá trị null một phần thời gian. Trong quá trình suy luận, đầu ra mô hình khuếch tán ϵθ(xt, t,c) được kết hợp tuyến tính với ϵθ(xt, t,c∅) sử dụng thang CFG w, trong đó c∅ là các embeddings null. Lưu ý, CFG trong quá trình suy luận làm tăng gấp đôi các lượt truyền thuận của ϵθ. Để xem lại mô hình khuếch tán, xem Phụ lục A.

3.2. Công thức Bài toán

Thay vì cố gắng điều khiển các mô hình khuếch tán bằng cách sử dụng huấn luyện có giám sát đắt đỏ hoặc các phương pháp dựa trên hướng dẫn thời gian suy luận không chính xác, chúng tôi công thức hóa nhiệm vụ điều khiển như một bài toán tối ưu hóa. Đáng chú ý, chúng ta có thể ký hiệu đầu ra của mô hình sau khi chạy bộ lấy mẫu trong tổng cộng T bước lấy mẫu là x0=Sampler T(ϵθ,xT,c), cho thấy rằng đầu ra cuối cùng là một hàm của các biến tiềm ẩn nhiễu ban đầu xT∼ N (0, I).

Trong khi xT thường chỉ được coi là một hạt giống ngẫu nhiên, chúng ta thay vào đó có thể coi các biến tiềm ẩn nhiễu ban đầu như một tham số tự do để tối ưu hóa tại thời điểm suy luận. Cụ thể, chúng tôi định nghĩa một bộ trích xuất đặc trưng mục tiêu f(·), chỉ cần khả vi, và một hàm mất mát tương ứng L để đo mức độ đầu ra mô hình của đặc trưng cụ thể khớp với điều khiển mục tiêu y. Với điều này, chúng ta sau đó có thể tối ưu hóa trực tiếp xT thông qua quá trình lấy mẫu sao cho đầu ra mô hình x0 tuân theo điều khiển mục tiêu. Chính thức,

x∗T= arg minxT L(f(x0),y) (2)
x0=Sampler T(ϵθ,xT,c) (3)

Bằng cách đóng khung nhiệm vụ điều khiển như một tối ưu hóa khớp đặc trưng tùy ý trên các biến tiềm ẩn nhiễu ban đầu, chúng tôi có thể kết hợp một phạm vi đa dạng các nhiệm vụ điều khiển bằng cách xây dựng f(·) và L tương ứng, chẳng hạn như để f trích xuất đường cong cường độ của âm nhạc và L là khoảng cách bình phương ℓ2 đến một cường độ mục tiêu nào đó (xem Phần 4 để biết thêm chi tiết). Quy trình này không yêu cầu huấn luyện (vì chỉ xT được tối ưu hóa chứ không phải trọng số mô hình) và sử dụng gradients điều khiển chính xác (vì f(·) chỉ được gọi trên đầu ra thực).

Tuy nhiên, việc giải (2) bằng lan truyền ngược thường không khả thi do yêu cầu bộ nhớ cực lớn. Cụ thể, quá trình lấy mẫu khuếch tán là đệ quy theo thiết kế và các gói tự động vi phân tiêu chuẩn thường yêu cầu lưu trữ tất cả kết quả trung gian cho mỗi lần gọi đệ quy T đến ϵθ trong bộ lấy mẫu (2T tập kích hoạt mỗi bước khi CFG được sử dụng). Do đó, ngay cả 2-3 bước lấy mẫu có thể gây ra lỗi bộ nhớ với các kiến trúc khuếch tán U-Net tiêu chuẩn.

3.3. Khuếch tán với Gradient Checkpointing

Để tránh việc sử dụng bộ nhớ lớn trong quá trình tối ưu hóa, chúng tôi sử dụng gradient checkpointing (Chen et al., 2016). Ý tưởng cốt lõi là loại bỏ các giá trị kích hoạt trung gian được lưu trữ trong quá trình truyền thuận của lan truyền ngược gây ra việc sử dụng bộ nhớ cao và tính toán lại chúng trong quá trình truyền ngược khi cần từ các đầu vào được cache. Chúng tôi sử dụng gradient checkpointing trên mỗi lệnh gọi mô hình trong quá trình lấy mẫu, vì bộ nhớ cần thiết để lưu trữ các tensor khuếch tán nhiễu trung gian và thông tin điều kiện là rất nhỏ so với các kích hoạt trung gian của một mô hình khuếch tán điển hình (ví dụ: bản đồ kích hoạt cross-attention trong một UNet lớn). Chi phí bộ nhớ của chúng tôi để tối ưu hóa (2) với checkpointing từng bước lấy mẫu là 1) bộ nhớ cần thiết để chạy lan truyền ngược trên một lệnh gọi mô hình khuếch tán ϵθ cộng với 2) chi phí lưu trữ T tensor khuếch tán nhiễu trung gian xt∀t= 0, ..., T và điều kiện c. Trong khi chúng ta trả giá cho việc giảm bộ nhớ bằng một lượt truyền thuận bổ sung mỗi bước thời gian (như được hiển thị trong Hình 2), thủ thuật đơn giản này cho phép DITTO duy trì hiệu quả mà không thay đổi bất kỳ phần nào của thuật toán lấy mẫu.

Trái ngược với phương pháp của chúng tôi, DOODL đã khám phá gradient checkpointing thông qua thư viện MemCNN (Leemput et al., 2019). Tuy nhiên, việc sử dụng bộ lấy mẫu EDICT của họ làm tăng gấp đôi chi phí bộ nhớ và thời gian chạy so với phương pháp của chúng tôi (xem Phụ lục B) và thêm tính không ổn định vào quá trình lấy mẫu do lấy mẫu chuỗi kép của EDICT (xem Phần 6.4).

3.4. Thuật toán Hoàn chỉnh

Pseudo-code cho thuật toán DITTO của chúng tôi được hiển thị trong Thuật toán 1. Chúng tôi định nghĩa Checkpoint là một hàm gradient checkpointing 1) nhận đầu vào và lưu trữ một mạng khả vi có thể gọi (tức là bộ lấy mẫu) và bất kỳ đối số đầu vào nào cho mạng, 2) ghi đè hành vi cache kích hoạt mặc định của mạng để tắt cache kích hoạt trong quá trình truyền thuận của lan truyền ngược và 3) tính toán lại kích hoạt khi cần trong quá trình truyền ngược. Lưu ý rằng trong thực tế, chúng tôi thường sử dụng một chuỗi con nhỏ các bước lấy mẫu (ví dụ: 20) trải dài từ xT đến x0.

4. Ứng dụng và Framework Điều khiển

Chúng tôi áp dụng mô hình linh hoạt của chúng tôi cho một phạm vi ứng dụng1 bằng cách tham số hóa mỗi framework điều khiển (tức là f và L) để nhắm mục tiêu trực tiếp các đặc trưng có ý nghĩa âm nhạc, cho phép outpainting, inpainting, looping, điều khiển cường độ, điều khiển giai điệu và điều khiển cấu trúc âm nhạc, trong đó cấu trúc âm nhạc và looping chưa được khám phá cho các mô hình khuếch tán TTM. Chúng tao tạo thành cả các hoạt động điều khiển dựa trên tham chiếu (tức là sử dụng âm thanh hiện có) và không tham chiếu (tạo sinh từ đầu, như được hiển thị trong Hình 3). Mục tiêu của chúng tôi ở đây là hiển thị khả năng điều khiển biểu đạt mà các biến tiềm ẩn nhiễu ban đầu có đối với quá trình khuếch tán.

Outpainting – Outpainting là nhiệm vụ mở rộng độ dài của âm thanh hiện có và rất quan trọng cho việc chỉnh sửa âm thanh cũng như tạo sinh nội dung âm nhạc thời lượng dài sử dụng các mô hình khuếch tán. Các phương pháp outpainting trước đây bao gồm MultiDiffusion (Bar-Tal et al., 2023) và Guidance Gradients (Levy et al., 2023) gặp khó khăn trong việc duy trì tính nhất quán dài hạn và làm mịn cục bộ. Chúng tôi thực hiện outpainting bằng cách 1) lấy một tín hiệu âm thanh tham chiếu hiện có xref; 2) định nghĩa một vùng chồng chéo o tính bằng giây ở cuối tham chiếu; 3) sử dụng DITTO để tạo nội dung mới khớp với vùng chồng chéo ở đầu tạo sinh mới; và 4) ghép nối tham chiếu và nội dung mới được tạo sinh lại với nhau. Chính thức hơn, chúng tôi định nghĩa Mref và Mgen như các mặt nạ nhị phân chỉ định vị trí của vùng chồng chéo trong nội dung tham chiếu và được tạo sinh tương ứng, f(x0):=Mgen⊙x0, y=Mref⊙xref, và L ∝ || f(x0)−y||22.

Inpainting – Inpainting là nhiệm vụ thay thế một vùng bên trong của nội dung thực hoặc được tạo sinh trước đó và rất cần thiết cho việc chỉnh sửa âm thanh và remix âm nhạc. Công trình trước đây về inpainting đã được khám phá trong miền hình ảnh và âm thanh với thành công đa dạng (Chung et al., 2023; Levy et al., 2023). Chúng tôi sử dụng DITTO để thực hiện inpainting tương tự như outpainting, với sự sửa đổi duy nhất là Mref=Mgen biểu thị hai vùng chồng chéo (ở mỗi bên của phổ đồ) để sử dụng làm ngữ cảnh cho việc inpainting khoảng trống ở giữa.

Looping – Looping là nhiệm vụ tạo sinh nội dung lặp lại theo mô hình vòng tròn, tạo ra các đoạn âm nhạc có thể lặp lại để tạo thành cơ sở cho một tác phẩm lớn hơn. Đối với looping, chúng tôi sử dụng DITTO tương tự như outpainting, nhưng khi chúng tôi định nghĩa Mref và Mgen, chúng tôi chỉ định hai vùng cạnh chồng chéo của đầu ra (tương tự như inpainting) nhưng tương ứng với các bên đối diện của đầu ra (tương tự như outpainting), sao cho vùng mở rộng chuyển tiếp mượt mà trở lại đầu của clip tham chiếu. Theo hiểu biết của chúng tôi, chúng tôi là người đầu tiên mang lại khả năng điều khiển looping cho các mô hình khuếch tán TTM.

Điều khiển Cường độ – Điều khiển cường độ âm nhạc là nhiệm vụ điều chỉnh độ tương phản động của âm nhạc được tạo sinh theo thời gian. Chúng tôi tuân theo giao thức điều khiển cường độ từ Music ControlNet (xem Wu et al. (2023a) để biết thêm chi tiết), sử dụng phương pháp thời gian huấn luyện để tạo sinh âm nhạc tuân theo đường cong âm lượng decibel (dB) được làm mịn. Trong trường hợp của chúng tôi, chúng tôi sử dụng DITTO theo cách tương tự, mặc dù không cần tinh chỉnh quy mô lớn, bằng cách đặt f(x0):= w∗20 log10(RMS(V(x0))), trong đó w là các hệ số làm mịn được sử dụng trong Music ControlNet, ∗ là toán tử tích chập, RMS là năng lượng Root Mean Squared của âm thanh, y là một đường cong mục tiêu thang dB đã cho, L ∝ || f(x0)−y||22, và V là vocoder của chúng tôi (Lee et al., 2022; Zhu et al., 2024) dịch phổ đồ sang miền âm thanh. Ở đây, chúng tôi cũng lan truyền ngược qua vocoder. Đáng chú ý, dưới tham số hóa này, điều khiển cường độ không chỉ điều khiển độ to của âm thanh được tạo sinh mà còn cả mật độ hài hòa và nhịp điệu của âm nhạc (có tương quan với năng lượng RMS).

Điều khiển Giai điệu – Điều khiển giai điệu âm nhạc là nhiệm vụ điều khiển các tông âm nhạc nổi bật theo thời gian và cho phép các nhà sáng tạo tạo sinh âm nhạc đệm cho các giai điệu hiện có. Theo công trình gần đây (Copet et al., 2023; Wu et al., 2023a), giai điệu xấp xỉ của một bản ghi có thể được trích xuất bằng cách tính toán mức năng lượng được làm mịn của 12 lớp cao độ theo thời gian thông qua hàm chromagram thông cao C(·)(Müller, 2015). Với điều này, chúng tôi sử dụng DITTO với f(x0) = log( C(V(x0))), một giai điệu mục tiêu y∈ {1, . . . , 12}N×1, độ dài phổ đồ N, và L= NLLLoss (f(x0),y) hoặc hàm mất mát log likelihood âm. Xem Wu et al. (2023a) để biết thêm chi tiết triển khai.

Điều khiển Cấu trúc Âm nhạc – Chúng tôi định nghĩa điều khiển cấu trúc âm nhạc như nhiệm vụ điều khiển hình thức âm nhạc cấp cao của âm nhạc được tạo sinh theo thời gian. Để mô hình hóa hình thức âm nhạc, chúng tôi tuân theo công trình phân tích cấu trúc âm nhạc (McFee & Ellis, 2014) rằng, trong trường hợp đơn giản nhất, đo cấu trúc thông qua tính toán ma trận tự tương tự (SS) của các đặc trưng timbre cục bộ trong đó timbre là "mọi thứ về âm thanh không phải là độ to hay cao độ" (Erickson, 1975). Do đó, chúng tôi sử dụng DITTO để điều khiển cấu trúc âm nhạc bằng cách đặt y là ma trận SS mục tiêu đã biết, f(x0) =T(x0)T(x0)⊤, T(·) là hàm trích xuất timbre, và L ∝ || f(x0)−y||22. Cụ thể, chúng tôi sử dụng Mel-Frequency Cepstrum Coefficients (MFCCs) (McFee et al., 2010), bỏ qua hệ số đầu tiên và được chuẩn hóa qua trục thời gian, như hàm trích xuất timbre, và sau đó làm mịn ma trận SS thông qua bộ lọc Savitzky-Golay 2D để không phạt các biến thể nhỏ trong tương tự nội cụm. Các ma trận SS mục tiêu như vậy có thể có dạng mô hình "ABBA" (như được hiển thị trong Hình 3) chẳng hạn. Theo hiểu biết của chúng tôi, chúng tôi là người đầu tiên mang lại khả năng điều khiển cấu trúc cho các mô hình khuếch tán TTM.

Các Ứng dụng Khác – Bên cạnh các ứng dụng được mô tả ở trên, DITTO có thể được sử dụng cho nhiều phần mở rộng mới chưa được khám phá trước đây trong tạo sinh TTM mà chúng tôi mô tả trong Phụ lục, chẳng hạn như điều khiển cường độ dựa trên tương quan (C), đảo ngược âm thanh thực (D), looping không tham chiếu (E), chuyển giao cấu trúc âm nhạc (F), các phương pháp lấy mẫu khác (G), tối ưu hóa đa đặc trưng (H), và tái sử dụng các biến tiềm ẩn đã tối ưu hóa cho suy luận nhanh (I).

5. Thiết kế Thí nghiệm

5.1. Thiết lập DITTO

Chúng tôi sử dụng Adam (Kingma & Ba, 2014) làm bộ tối ưu hóa cho DITTO, với tốc độ học 5×10−3 (vì cao hơn dẫn đến vấn đề ổn định). Chúng tôi sử dụng lấy mẫu DDIM (Song et al., 2020) với 20 bước và dynamic thresholding (Saharia et al., 2022b) cho tất cả thí nghiệm. Không có siêu tham số tối ưu hóa nào được thay đổi qua các ứng dụng ngoài số bước tối ưu hóa tối đa, được tăng gấp đôi từ 70 lên 150 cho các nhiệm vụ giai điệu và cấu trúc.

5.2. Tập dữ liệu

Chúng tôi huấn luyện các mô hình của chúng tôi trên một tập dữ liệu khoảng 1800 giờ âm nhạc nhạc cụ được cấp phép với các thẻ thể loại, tâm trạng và nhịp độ. Tập dữ liệu của chúng tôi không có mô tả văn bản tự do, vì vậy chúng tôi sử dụng điều khiển văn bản điều kiện lớp của phong cách âm nhạc toàn cục, như được thực hiện trong JukeBox (Dhariwal et al., 2020). Đối với tham chiếu điều khiển giai điệu, chúng tôi tổng hợp các bản ghi từ một tập con 380 mẫu miền công cộng của Wikifonia Lead-Sheet Dataset (Simonetta et al., 2018). Giống như trong Wu et al. (2023a), chúng tôi xây dựng một tập nhỏ các đường cong cường độ và ma trận cấu trúc âm nhạc được tạo thủ công (ví dụ: một crescendo mượt mà và dạng "ABA") cho điều khiển cường độ và cấu trúc (xem Phụ lục H để biết thêm ví dụ). Chỉ để đánh giá, chúng tôi cũng sử dụng MusicCaps Dataset (Agostinelli et al., 2023) với khoảng 5K clip 10 giây có mô tả văn bản.

5.3. Các Metrics Đánh giá

Chúng tôi sử dụng Frechet Audio Distance (FAD) với backbone CLAP music (Wu et al., 2023b) (vì backbone VGGish mặc định được ghi nhận là tương quan kém với nhận thức con người (Gui et al., 2023)), đo khoảng cách giữa phân phối embeddings từ một tập các bản ghi cơ sở và từ các bản ghi được tạo sinh (Kilgour et al., 2018). Các metrics FAD được tính toán sử dụng MusicCaps làm phân phối tham chiếu so với 2.5K tạo sinh mô hình cho tất cả thí nghiệm. Đối với các mục tiêu không tham chiếu, chúng tôi cũng sử dụng điểm CLAP (Wu et al., 2023b), đo sự căn chỉnh tổng thể giữa chú thích văn bản và đầu ra âm thanh; lưu ý rằng vì mô hình của chúng tôi chỉ được điều kiện thẻ, chúng tôi chuyển đổi mỗi tập thẻ thành chú thích sử dụng mẫu "Một bài hát [thể loại] [tâm trạng] với [BPM] nhịp mỗi phút". Bổ sung, đối với điều khiển cường độ và cấu trúc âm nhạc, chúng tôi báo cáo mất mát trung bình L qua các đầu ra được tạo sinh (tức là khoảng cách khớp đặc trưng cuối cùng), và báo cáo độ chính xác tổng thể cho điều khiển giai điệu, vì nó được đóng khung như một nhiệm vụ phân loại.

5.4. Baselines

Chúng tôi so sánh với một phạm vi rộng các phương pháp bao gồm:

• Naïve Masking: Ở đây, sau một bước DDIM chúng tôi áp dụng cập nhật xt−1=Mref⊙ N(√¯αtxref,(1−¯αt)I) + Mgen⊙xt−1 (tức là đặt vùng chồng chéo trực tiếp thành hình ảnh tham chiếu ở mức nhiễu thích hợp).

• MultiDiffusion (Bar-Tal et al., 2023): Trường hợp này tương tự như phương pháp naïve, nhưng thay vào đó tính trung bình các đầu ra nhiễu trong vùng chồng chéo thay vì sử dụng mặt nạ cứng. Chúng ta có thể dừng hoạt động tính trung bình này tại các điểm nhất định của quá trình lấy mẫu (chẳng hạn như nửa chừng) và để mô hình lấy mẫu mà không hướng dẫn quá trình; chúng tôi ký hiệu phương pháp trước là MD và phương pháp sau là MD-50 để ngắn gọn.

• FreeDoM (Yu et al., 2023): FreeDoM là một phương pháp dựa trên hướng dẫn, trong đó chúng tôi thực hiện một cập nhật bổ sung trong quá trình lấy mẫu xt=xt−ηt∇xtL(f(ˆx0(xt)),y), trong đó ˆx0(xt) biểu thị thuật ngữ đầu tiên trong Eq. 12. ηt là tốc độ học phụ thuộc thời gian là một hàm của chuẩn gradient tổng thể.

• Guidance Gradients (GG) (Levy et al., 2023): GG lấy phương trình cập nhật từ FreeDoM và thực hiện hai sửa đổi nhỏ. Cụ thể, ηt được cố định trong suốt quá trình lấy mẫu, và GG bao gồm một bước nhất quán dữ liệu bổ sung khi bộ trích xuất đặc trưng f(·) hoàn toàn tuyến tính.

• Music ControlNet (Wu et al., 2023a): Music ControlNet là một phương pháp dựa trên huấn luyện chia sẻ cùng mô hình cơ bản với công trình của chúng tôi nhưng bổ sung tinh chỉnh các mô-đun adaptor trong quá trình huấn luyện quy mô lớn đến tín hiệu điều khiển y như điều kiện.

• DOODL (Wallace et al., 2023a): DOODL2 là một phương pháp dựa trên tối ưu hóa sử dụng bộ lấy mẫu EDICT (Wallace et al., 2023b) và nhiều thay đổi đặc biệt cho quá trình tối ưu hóa như tiêm nhiễu và chuẩn hóa lại xT. Chúng tôi sử dụng cùng tốc độ học như DITTO do các vấn đề ổn định tương tự.

Chúng tôi so sánh với Naïve Masking, MultiDiffusion, và Guidance Gradients cho các thí nghiệm inpainting, outpainting, và looping vì tất cả đều có mục tiêu khớp đặc trưng tuyến tính, Music ControlNet cho các thí nghiệm giai điệu và cường độ, và FreeDoM và DOODL cho tất cả thí nghiệm.

6. Kết quả

6.1. Kết quả Outpainting, Inpainting, và Looping

Chúng tôi hiển thị kết quả đánh giá khách quan cho outpainting và looping trong Bảng 1 và kết quả inpainting trong Bảng 2. Ở đây chúng tôi báo cáo FAD, vì mất mát thấp trên các vùng chồng chéo không đảm bảo rằng âm thanh tổng thể có tính liên kết. Chúng tôi thấy DITTO đạt được FAD thấp nhất so với tất cả baselines qua các kích thước chồng chéo từ 1 đến 3 giây và khoảng trống inpainting từ 2 đến 4 giây. DOODL thực hiện tốt thứ hai sau DITTO, và các phương pháp hướng dẫn thời gian suy luận đặc biệt gặp khó khăn.

Về mặt chất lượng, chúng tôi phát hiện rằng tất cả baselines (ngoài DOODL) có xu hướng tạo ra "đường nối" có thể nghe thấy trong đầu ra âm nhạc bên ngoài vùng chồng chéo như được hiển thị trong Hình 4, trong đó các đầu ra cuối cùng có xu hướng chỉ khớp vùng chồng chéo (tức là tối ưu hóa quá mức cho mục tiêu khớp đặc trưng) và bỏ qua tính nhất quán tổng thể giữa tạo sinh chồng chéo và phần còn lại của tạo sinh. Bằng cách tối ưu hóa xT để tái tạo trên các vùng chồng chéo, DITTO hiệu quả tránh các vấn đề như vậy, vì quá trình này ngầm khuyến khích các phần tạo sinh không chồng chéo bảo tồn nội dung ngữ nghĩa một cách mượt mà.

6.2. Kết quả Cường độ, Giai điệu, và Cấu trúc

Trong Bảng 3, chúng tôi hiển thị các metrics khách quan cho điều khiển cường độ, giai điệu và cấu trúc. Chúng tôi tìm cách hiểu 1) các phương pháp khác nhau áp đặt điều khiển mục tiêu lên mô hình tạo sinh như thế nào thông qua MSE hoặc Accuracy 2) chất lượng âm thanh tổng thể thông qua FAD và 3) điều khiển như vậy ảnh hưởng đến điều kiện văn bản cơ sở như thế nào thông qua CLAP. Chúng tôi thấy DITTO đạt được điều khiển cường độ và giai điệu SOTA, đánh bại Music ControlNet với không cần huấn luyện có giám sát. Chúng tôi khám phá sâu hơn điều khiển cường độ kém của Music ControlNet trong Phụ lục C.

Bổ sung, chúng tôi lưu ý FreeDoM hơi đánh bại DITTO trong điều khiển cấu trúc, nhưng thể hiện hiệu suất kém cho điều khiển cường độ và đặc biệt là điều khiển giai điệu, cho thấy những hạn chế của các phương pháp dựa trên hướng dẫn đối với các bộ trích xuất đặc trưng phức tạp.

Một mối quan tâm đáng chú ý với điều khiển dựa trên tối ưu hóa là khả năng reward hacking (Skalse et al., 2022; Prabhudesai et al., 2023), trong đó mục tiêu điều khiển được tối ưu hóa quá mức dẫn đến suy giảm chất lượng mô hình và hành vi cơ sở. Chúng tôi thấy rằng DOODL thể hiện hành vi reward hacking này một cách nhất quán ngoài việc thường xuyên tệ hơn trong điều khiển so với DITTO, hy sinh chất lượng tổng thể và mức độ liên quan văn bản đáng kể để ưu tiên khớp mục tiêu điều khiển. Mặt khác, DITTO có thể cân bằng điều khiển mục tiêu mà không tối ưu hóa quá mức và duy trì chất lượng và mức độ liên quan văn bản.

Trong Hình 3, chúng tôi hiển thị kết quả điều khiển cường độ, giai điệu và cấu trúc định tính. Bên trái, chúng tôi hiển thị một phổ đồ được tạo sinh với đường cong cường độ tăng rồi giảm. Ở giữa, chúng tôi hiển thị một phổ đồ được tạo sinh với đầu vào mục tiêu và hình ảnh hóa giai điệu được tạo sinh (chromagram). Bên phải, chúng tôi hiển thị một phổ đồ được tạo sinh với ma trận tự tương tự mục tiêu và được tạo sinh với mô hình cấu trúc ABBA.

6.3. Test Nghe Chủ quan

Do chất lượng âm thanh mang tính chủ quan, chúng tôi thực hiện một test nghe quy mô nhỏ để đo hiệu quả của DITTO so với các phương pháp thay thế. Cụ thể, chúng tôi yêu cầu người tham gia test đánh giá chất lượng âm thanh cho ba ứng dụng khác nhau bao gồm Cường độ, Outpainting và Giai điệu qua một số thuật toán. Chúng tôi tạo sinh 10 mẫu ngẫu nhiên cho mỗi ứng dụng sử dụng cùng các prompt văn bản và điều khiển cho mỗi phương pháp. Chúng tôi so sánh DITTO với FreeDoM và Music ControlNet cho điều khiển Cường độ và Giai điệu, và với FreeDoM và MD-50 cho outpainting. Đối với mỗi bộ ba đầu ra cho các điều khiển đã cho, người tham gia được yêu cầu đánh giá chất lượng tổng thể của âm nhạc được tạo sinh cho mỗi đầu ra trên thang điểm 0-100. Chúng tôi tuyển dụng 15 người tham gia cho nghiên cứu nghe, do đó tổng cộng 150 điểm cho mỗi thiết lập và phương pháp điều khiển.

Trong Bảng 4, chúng tôi hiển thị số lần thắng cho DITTO và sự khác biệt trung bình trong điểm đánh giá giữa DITTO và mỗi phương pháp khác (trong đó điểm khác biệt dương biểu thị DITTO cao hơn). Đáng chú ý, chúng tôi thấy rằng DITTO được ưa thích mạnh mẽ so với FreeDoM trên tất cả nhiệm vụ, Music ControlNet trên Cường độ, và MD-50 trên Outpainting. Về điều khiển Giai điệu, chúng tôi thấy thực tế không có sự khác biệt giữa DITTO và Music-ControlNet, với tỷ lệ thắng của DITTO ở 48% nhưng có điểm trung bình cao hơn một chút khi được ưa thích. Điều này cung cấp bằng chứng rằng DITTO có chất lượng vượt trội hoặc bằng nhau so với các phương pháp tạo sinh âm nhạc có thể điều khiển SOTA.

6.4. So sánh Hiệu quả

Bên cạnh việc so sánh DITTO với DOODL về chất lượng tạo sinh và điều khiển, chúng tôi tìm cách hiểu cách chúng khác nhau về cả hiệu quả thực tế và tốc độ hội tụ, vì thời gian chạy chậm mỗi lần lặp có thể được bù đắp bởi hội tụ nhanh, và cách các hành vi như vậy thay đổi khi số bước lấy mẫu tăng. Chúng tôi tập trung vào điều khiển cường độ vì nó đại diện cho điểm giữa giữa các phương pháp painting tuyến tính đơn giản và điều khiển giai điệu phức tạp hơn. Bên cạnh MSE, FAD, và CLAP, chúng tôi cũng báo cáo số bước trung bình để hội tụ (MS2C), tức là số bước tối ưu hóa trung bình cần thiết để đạt MSE dưới một ngưỡng τ nào đó, tốc độ tối ưu hóa trung bình (MOS), tức là số giây trung bình mỗi bước tối ưu hóa, và bộ nhớ được phân bổ trung bình (MAM), đo bộ nhớ GPU trung bình (tính bằng GB) được sử dụng trong quá trình tối ưu hóa bởi mô hình khuếch tán. Xem Phụ lục L để biết thêm chi tiết.

Trong Bảng 5, chúng tôi xác nhận thực nghiệm rằng DOODL chậm hơn khoảng 2 lần so với DITTO và chiếm khoảng 2 lần bộ nhớ GPU hơn, vì DOODL sử dụng bộ lấy mẫu EDICT làm tăng gấp đôi số lượng lệnh gọi mô hình trong cả quá trình truyền thuận và truyền ngược checkpointed và lưu trữ cả hai chuỗi đầu vào trong bộ nhớ. Quan trọng nhất, chúng tôi phát hiện rằng DOODL hiển thị tốc độ hội tụ thực tế giống hệt với DITTO, cho thấy rằng độ phức tạp bổ sung của DOODL không mang lại lợi ích nào trong việc tăng tốc tối ưu hóa. Chúng tôi lưu ý rằng việc tăng số bước lấy mẫu có xu hướng suy giảm tuân thủ điều khiển, có thể do chuỗi lấy mẫu dài hơn làm cho lan truyền ngược khó khăn hơn. Thú vị, khi thời gian lấy mẫu tăng, FAD tổng thể cải thiện đáng kể cho DOODL, đưa ra bằng chứng rằng EDICT đặc biệt gặp khó khăn với ít bước lấy mẫu, và do đó DOODL không thể được tăng tốc bằng cách sử dụng ít bước hơn mà không có reward hacking đáng chú ý.

Chúng tôi lưu ý rằng các kỹ thuật tối ưu hóa dựa trên thời gian suy luận chậm hơn cả các kỹ thuật dựa trên hướng dẫn và các kỹ thuật dựa trên huấn luyện tại thời gian suy luận theo thiết kế, vì chúng về chức năng phân bổ chi phí của các phương pháp dựa trên huấn luyện (yêu cầu hàng trăm giờ GPU để tinh chỉnh) tại thời gian suy luận để cung cấp khả năng biểu đạt nhiều hơn so với các phương pháp dựa trên hướng dẫn (xem Phụ lục L để thảo luận thêm). Do tốc độ của DITTO chủ yếu gắn liền với số bước lấy mẫu được sử dụng để lấy mẫu mô hình (cũng như nhu cầu gradient checkpointing), có những cách rõ ràng để tăng tốc DITTO sử dụng dòng công trình đang phát triển trong các bộ lấy mẫu khuếch tán nhanh (Lu et al., 2022; Luo et al., 2023; Kim et al., 2023), mà chúng tôi để dành cho công trình tương lai.

6.5. Sức mạnh Biểu đạt của Không gian Tiềm ẩn Khuếch tán

Thông thường, biến tiềm ẩn ban đầu xT bị bỏ qua trong các mô hình khuếch tán, vì không gian tiềm ẩn khuếch tán trước đây được cho là mã hóa ít ý nghĩa ngữ nghĩa so với không gian tiềm ẩn GAN (Song et al., 2020; Preechakul et al., 2022). Tuy nhiên, hiệu suất mạnh mẽ của DITTO đưa ra sự thật đáng ngạc nhiên rằng một mảng rộng các đặc trưng tinh tế có ý nghĩa ngữ nghĩa có thể được điều chỉnh hoàn toàn thông qua khám phá không gian tiềm ẩn khuếch tán mà không cần chỉnh sửa mô hình khuếch tán cơ sở được tiền huấn luyện. Chúng tôi khám phá ý tưởng này sâu hơn, và cách các phát hiện của chúng tôi được liên kết lý thuyết với việc mã hóa cấu trúc tần số thấp được ghi nhận bởi Si et al. (2023) trong Phụ lục J.

7. Kết luận

Chúng tôi đề xuất DITTO: Tối ưu hóa T tại Thời điểm Suy luận Khuếch tán, một framework thống nhất không cần huấn luyện để điều khiển các mô hình khuếch tán được tiền huấn luyện để cho phép một phạm vi rộng các nhiệm vụ chỉnh sửa và điều khiển sáng tạo cho tạo sinh âm nhạc. DITTO đạt được khả năng chỉnh sửa SOTA và khớp khả năng điều khiển của các phương pháp hoàn toàn dựa trên huấn luyện, vượt trội hơn phương pháp tối ưu hóa hàng đầu đồng thời hiệu quả gấp 2 lần về thời gian và bộ nhớ, và không áp đặt hạn chế nào về kiến trúc mô hình hóa hoặc quá trình lấy mẫu. Trong công trình tương lai, chúng tôi hy vọng tăng tốc quy trình tối ưu hóa để đạt được tương tác thời gian thực và điều khiển biểu đạt hơn.

Tuyên bố Tác động

Trong khi các mô hình đa phương tiện tạo sinh có thể mở ra những con đường mới cho sáng tạo nghệ thuật, có mối quan tâm về việc tác động tiêu cực đến các nhạc sĩ và nhà sáng tạo đang làm việc hiện tại và sinh kế của họ. Chúng tôi thấy rằng việc xây dựng các hệ thống TTM bảo vệ nghệ sĩ và dữ liệu của họ là cực kỳ quan trọng. Để giảm thiểu tác hại, chúng tôi huấn luyện trên âm nhạc được cấp phép và tập trung cải thiện khả năng điều khiển, cho phép các nghệ sĩ đang làm việc giao tiếp với các hệ thống TTM thông qua các điều khiển được căn chỉnh âm nhạc hơn, thay vì chỉ dựa vào các prompt văn bản cấp cao có thể quá chung chung cho các chuyên gia âm nhạc.
