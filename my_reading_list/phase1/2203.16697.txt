# 2203.16697.pdf
# Converted from PDF to TXT
# Source path: ./2203.16697.pdf
# File size: 1499789 bytes

===============================================
PDF FILE CONTENT
===============================================


--- PAGE 1 ---
Type-Directed Program Synthesis for RESTful APIs
Zheng Guo
UC San Diego
USA
zhg069@ucsd.eduDavid Cao
UC San Diego
USA
dmcao@ucsd.eduDavin Tjong
UC San Diego
USA
dtjong@ucsd.edu
Jean Yang
Akita Software
USA
jean@akitasoftware.comCole Schlesinger
Akita Software
USA
cole@akitasoftware.comNadia Polikarpova
UC San Diego
USA
npolikarpova@ucsd.edu
Abstract
With the rise of software-as-a-service and microservice ar-
chitectures, RESTful APIs are now ubiquitous in mobile and
web applications. A service can have tens or hundreds of
API methods, making it a challenge for programmers to find
the right combination of methods to solve their task.
We present APIphany , a component-based synthesizer
for programs that compose calls to RESTful APIs. The main
innovation behind APIphany is the use of precise semantic
types , both to specify user intent and to direct the search.
APIphany contributes three novel mechanisms to overcome
challenges in adapting component-based synthesis to the
REST domain: (1) a type inference algorithm for augment-
ing REST specifications with semantic types; (2) an efficient
synthesis technique for “wrangling” semi-structured data,
which is commonly required in working with RESTful APIs;
and (3) a new form of simulated execution to avoid executing
APIs calls during synthesis. We evaluate APIphany on three
real-world APIs and 32 tasks extracted from GitHub reposi-
tories and StackOverflow . In our experiments, APIphany
found correct solutions to 29 tasks, with 23 of them reported
among top ten synthesis results.
CCS Concepts: •Software and its engineering →Auto-
matic programming .
Keywords: Program Synthesis, RESTful API, Type Inference
ACM Reference Format:
Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger,
and Nadia Polikarpova. 2022. Type-Directed Program Synthesis for
RESTful APIs. In Proceedings of the 43rd ACM SIGPLAN International
Conference on Programming Language Design and Implementation
Permission to make digital or hard copies of part or all of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. Copyrights for third-
party components of this work must be honored. For all other uses, contact
the owner/author(s).
PLDI ’22, June 13–17, 2022, San Diego, CA, USA
©2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9265-5/22/06.
https://doi.org/10.1145/3519939.3523450(PLDI ’22), June 13–17, 2022, San Diego, CA, USA. ACM, New York,
NY, USA, 27 pages. https://doi.org/10.1145/3519939.3523450
1 Introduction
Software-as-a-service has emerged as a widely-used means
for developers to leverage third-party software. Developers
might send requests to Stripe to handle payments or inte-
grate with Slack to publish notifications, all while making
use of cloud providers to provision various form of storage
and compute. According to recent industry surveys, more
than 80% of respondents’ services offer RESTful APIs [ 26,30],
and these APIs are extensive. Slack , for example, has 174
API methods as of version 1.5.0. Amazon Web Services of-
fers over two hundred products and services, each with
tens or hundreds of API methods. Even with comprehensive
documentation—which is by no means guaranteed—using a
new service can be a daunting proposition.
As an example, consider a question posed on StackOver-
flow about the Slack API: How do I retrieve all member
emails from a Slack channel with a given name? The answer
is surprisingly complicated:
1.First, call conversations _list1to retrieve the array of all
channel objects, and then search for a channel object
with a given name and get its ID;
2.Next, call conversations _members on the channel ID to
get all user IDs of its members;
3.Finally, for each user ID, call users_info to retrieve
a user object u, and then access the user’s email via
u.profile.email .
To come up with this solution, one must be familiar with
channel objects, userobjects, and three different API methods.
Component-based program synthesis [ 8,14,18,21] has
been previously used to help programmers navigate APIs
in Java, Scala, and Haskell. Component-based synthesizers
take as input a type signature and (in most cases) a set of
input-output examples, and return a list of program snippets
that compose API calls and have the desired type and input-
output behavior. This is a powerful approach for navigating
1We shorten method names for brevity and elide the distinction between
REST methods andendpoints , irrelevant in this context.arXiv:2203.16697v2  [cs.PL]  5 Apr 2022

--- PAGE 2 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Figure 1. Overview of APIphany
APIs, because it allows developers to start with information
easily at hand—the types of inputs they have and the out-
puts they desire—and requires no knowledge of which API
methods to apply.
Challenges. Unfortunately, there are three significant chal-
lenges in applying component-based synthesis to RESTful
APIs. First, component-based synthesis relies on types both
for expressing user intent and for efficient search, but types
in REST APIs are quite shallow. For example, in the Slack
API specification, both channel names and emails have type
String , so our example, which transforms a channel name
into an array of emails, would have a very imprecise type
signature String→[String] .
Second, RESTful APIs commonly transmit semi-structured
data,i.e.arrays of objects, which may themselves contain
nested objects and arrays. As a result, using an API is often
not as simple as sequencing together a handful of method
calls; instead, the calls must be interleaved with “data wran-
gling” operations such as projections, maps, and filters. These
data wrangling operations are challenging for component-
based synthesis: they are extremely generic, and hence sig-
nificantly expand the search space.
Finally, to compensate for the inherent ambiguity of types,
component-based synthesis typically relies on executing can-
didate program snippets and matching them against user-
provided input-output examples. In a software-as-a-service
environment, this is a complete non-starter: not only is the
user generally unaware of the internal state of the service
and hence unable to provide accurate examples, but exe-
cuting API calls during synthesis can also be prohibitively
expensive due to rate limits imposed by the services and,
even more importantly, can have unrecoverable side effects,
such as deleting accounts or publishing messages.
APIphany : synthesis with semantic types. Our core in-
sight is that type-based specifications are actually a good fit
for REST APIs, as long as the types are more fine-grained.In our example, if the Slack API had dedicated types for
Channel.name andProfile.email , the programmer could spec-
ify their intent as the type Channel.name→[Profile.email] .
Although this specification is still somewhat ambiguous,
intuitively it has enough information to narrow down the
synthesis results to a manageable number such that the pro-
grammer can manually inspect the remaining solutions. We
refer to such fine-grained types as semantic types .
In this paper, we present APIphany , a component-based
synthesizer for REST APIs guided by semantic types. Fig. 1
shows a high-level overview of our approach, which is struc-
tured into two phases: (1) the analysis phase infers semantic
type annotations for a given API; (2) the synthesis phase uses
these type annotations to perform component-based synthe-
sis. For the Slack API, APIphany is able to infer, for example,
that the method conversations _members has the semantic type
Channel.id→[User.id] . At synthesis time, given the type
queryChannel.name→[Profile.email] ,APIphany returns a
ranked list of programs of this type, where the desired solu-
tion (shown in Fig. 2) appears among the top ten. APIphany ’s
output is expressed in a compact DSL inspired by Haskell’s
monadic do-notation and Scala’s for-comprehensions, which,
however, can be easily translated into the user’s language of
choice for communicating with the API.
Contributions. We present the design, implementation, and
evaluation of APIphany , including:
1.Type mining (Sec. 4), a technique that infers semantic
types from a set of witnesses (observed invocations of
API methods). Witnesses can be generated in a sandbox
or by tapping live production traffic; in either case, they
are collected ahead of time, once per API, which avoids
inducing side effects during synthesis.
2.Efficient synthesis of wrangling operations for semi-
structured data via array-oblivious search (Sec. 5), which
omits challenging array operations during search, and
recovers them later via type-directed lifting.

--- PAGE 3 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
1\channel _name→{
2c←conversations _list()
3 ifc.name =channel_name
4uid←conversations _members(channel=c.id)
5 letu = users _info(user=uid)
6 returnu.profile.email
7}
Figure 2. Solution for retrieving all member emails from a
Slack channel in APIphany DSL.
3.Ranking synthesis results with the help of retrospective
execution (Sec. 6), a type of simulated execution using
previously collected witnesses. Retrospective execu-
tion helps APIphany weed out uninteresting programs
(e.g.programs that always return an empty array), re-
ducing the number of synthesis results the user has to
inspect to find their expected solution.
We evaluate APIphany on three real-world APIs, and 32
tasks extracted from GitHub repositories and StackOver-
flow (Sec. 7). Our evaluation shows that APIphany can
find solutions to the majority of tasks (29/32) within 150
seconds. Moreover, semantic types are crucial to its effec-
tiveness: without type mining, APIphany can only solve
four tasks. Finally, ranking significantly improves the qual-
ity of reported solutions, increasing the number of correct
solutions appearing in top ten results from 12/29 to 23/29.
2APIphany by Example
In this section we use the task of retrieving all member emails
in aSlack channel as a running example to illustrate the
APIphany workflow depicted in Fig. 1.
2.1 API Analysis by Example
API analysis is performed once per API. It takes as input a
spec in the popular OpenAPI format2and a set of witnesses
(successful API method calls); it produces a spec annotated
with semantic types. OpenAPI specs are publicly available
for most popular APIs.3Witnesses can be generated in a
number of ways, for example, by running an integration test
suite in a sandbox or by passively listening to production API
traffic. We envision witness collection and API analysis be-
ing performed by the API maintainer (or another interested
party), not by regular users of the APIphany synthesizer.
OpenAPI specs. Fig. 3 shows a fragment of the OpenAPI
spec provided by Slack . An OpenAPI spec consists of object
definitions and method definitions. We show definitions of
three objects, user,profile andchannel , and two methods,
users_info andconversations _list, relevant to our example.
2https://swagger.io/ .APIphany supports both OpenAPI v2 and v3.
3Slack OpenAPI spec is available at: https://raw.githubusercontent.com/sl
ackapi/slack-api-specs/master/web-api/slack_web_openapi_v2.jsonAs you can see, the spec does provide precise type infor-
mation for some of the locations: for example, the response
ofusers_info clearly has type User (it is annotated with a
reference to the corresponding object definition). The bulk
of the locations, however, such as the field user.id or the
parameter of users_info, are simply annotated with String ,
which is not very helpful for the purposes of type-directed
synthesis. Our goal is to replace these String annotations
with more fine-grained types.
Mining types from witnesses. To this end, we build upon
an algorithm first proposed in [ 1] that infers types by mining
them from execution traces, based on the insight that equal
values observed at different locations likely have the same
type. More specifically, our type mining algorithm starts by
ascribing a unique semantic type to each String location and
then merges locations that share a value anywhere in the
witness set. As an illustration, consider Fig. 4, which lists two
witnesses for the API methods from our running example.
In this witness set we observe the same value "UJ5RHEG4S"
in three locations: (1) the parameter ofusers_info, (2) the id
field of aUser object (we know from the spec that users_info
returns a User), and (3) the creator field of aChannel object (we
know from the spec that conversations _list returns an array
ofChannel s). Hence we merge all three locations into the
same semantic type. For presentation purposes, we assign
the name User.id to this type, which is derived from location
(2) above. The choice of name is not important, however:
the user is free to refer to this semantic type via any of its
representative locations; for example, Channel.creator also
denotes the same type.
2.2 Program Synthesis by Example
The program synthesis phase of APIphany is meant to be
used by regular programmers, any time they need help ac-
complishing a task with one of the supported APIs. The pro-
grammer queries APIphany with a type signature built from
semantic types. Although the UI for constructing queries is
beyond the scope of this paper, we envision the program-
mer browsing object definitions and selecting relevant fields
as semantic types. For our running example, the program-
mer knows that they need to go from a channel name to
an array of user emails; they might first look through the
channel object definition and find the namefield; they might
then search globally for a field called email and find it in-
side the profile object; hence they settle on the type query
Channel.name→[Profile.email].
The program synthesis phase itself comprises two steps,
beginning with a program search step to generate a list of
candidate programs with a given type, followed by a ranking
step to identify promising candidates (described in Sec. 2.3).
Challenge: components meet control flow. Given the type
queryChannel.name→[Profile.email], how would APIphany
go about enumerating all programs of this type? This task

--- PAGE 4 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Figure 3. Fragment of the Slack API’s OpenAPI specification. (left) Definitions of user,profile andchannel objects. (right)
Parameters and responses of the methods users_info andconversations _list.
Figure 4. Witnesses for two Slack API methods. Arrows
connect equal values observed at different locations. Type
mining ascribes the type User.id to all the boxed locations.
presents a challenge to existing synthesis techniques because
our candidate programs have both a large component library
to choose from—from dozens to hundreds of methods— and
non-trivial control flow— e.g.the solution to our running
example has to loop over the members of a channel. One
line of prior work that scales to large component libraries is
graph-based search using type-transition nets (TTNs) [ 8,12];
unfortunately, this approach can only generate sequences of
method calls, and does not support loops.
TheAPIphany DSL. We observe that the loops we need
for manipulating semi-structured data are restricted to it-
erating over (possibly nested) arrays of objects. To capture
this restricted class of programs we have designed a DSL
inspired by Scala’s for-comprehensions, Haskell’s monadic
do-notation, and LINQ[22]. The solution to our running exam-
ple in this DSL is given in Fig. 2. In this language, iteration
over an array is expressed using the monadic bind operation
(written←). For example, the second bind in Fig. 2 has the
effect of performing the subsequent computation for every
element uidof the array returned in line 4:
4uid←conversations _members(channel=c.id);
5letu = users _info(user=uid);
6returnu.profile.email
Array-oblivious search. The main idea behind APIphany ’s
search is that although we cannot directly synthesize the\channel _name→{
c←conversations _list()
ifc.name =channel_name
letuid =c.creator
letu = users _info(user=uid)
returnu.profile.email
}\channel _name→{
c←conversations _open()
ifc.name =channel_name
letuid =c.creator
letu = users _info(user=uid)
returnu.profile.email
}
Figure 5. A sample of incorrect candidate solutions.
program above using existing TTN-based techniques, we can
synthesize an array-oblivious version of this program, where
we pretend that conversations _members returns a single User.id
instead of an array, and hence we can simply sequence the
two method calls, without monadic binding:
4letuid = conversations _members(channel=c.id);
5letu = users _info(user=uid);
6u.profile.email
To transform an array-oblivious program into the final
solution, APIphany liftsit into a comprehension by replac-
ing each letbinding that causes a type mismatch with a
monadic bind. In our example, the letin line 4 causes a type
error (because conversations _members returns [User.id] , while
users_info expects a single User.id ), while the letin line 5
does not (since users_inforeturns a single User); hence lifting
replaces the first let-binding with←but not the second.
2.3 Ranking via Retrospective Execution
Although semantic types are less ambiguous than primi-
tive types for expressing user intent, they are still not precise
enough to exactly identify the desired program. For example,
our synthesizer generates more than 1000 candidates for the
type signature Channel.name→[Profile.email] ; clearly, it is
infeasible for the user to manually go through all of them.
Hence, APIphany must be able to rank the candidates in
order to show the user a small number of likely solutions.
Fortunately, most of the 1000 candidates are easy to weed
out because they produce uninteresting results. Consider

--- PAGE 5 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
two of the candidates depicted in Fig. 5, which differ from
our desired solution (Fig. 2) in the highlighted fragments: the
first program returns the email of the channel’s creator (as
opposed to all of its members), and the second one gets the
list of channels from conversations _open, which is intended
for opening a direct message channel. It turns out that the
second program always fails at run time, because a successful
call toconversations _openrequires providing exactly one of
its two optional arguments (a channel ID or a list of users).
The first program executes successfully, but it always returns
a single email, while the user asked for an array of emails.
For these reasons, both of these programs are less likely to
be the intended solution than the program in Fig. 2, which
successfully returns multiple emails at least sometimes.
A natural idea is to test all candidate programs on ran-
dom inputs and rank them based on the results they produce.
Unfortunately, as we have hinted above, there are several bar-
riers to systematically executing many candidate programs
that make calls to REST APIs. First, most REST APIs set a
rate limit on how frequently a user can make method calls
or how many calls a user can make in a day. Second, many
REST API methods are side-effecting. Unlike a self-contained
binary, a remotely-hosted service cannot be restarted from a
clean state for each execution.
Retrospective execution. We propose retrospective execu-
tion (RE) as an efficient, non-side effecting alternative to
program execution. The main idea is to simulate execution
by “replaying” witnesses collected for the API analysis phase.
When evaluating a candidate program, rather than executing
an API call, RE instead searches for a matching witness and
substitutes its response at the call site. If done naively, how-
ever, this process almost always yields failure or an empty
array; so making RE useful for ranking purposes requires
explicitly biasing execution towards meaningful results.
As an illustration, consider executing the program in Fig. 2
using the witnesses in Fig. 4. As the first step, we simulate the
call toconversations _listusing the first witness; the response
is an array of channels with names "general" ,"private-test" ,
and"team" . The second step is to filter this array, retaining
only those channels whose name is equal to the input parame-
terchannel_name. If we had sampled the value for channel_name
eagerly, before running the program, we could scarcely have
chosen one of the three names actually present in the array,
so the filtering step (and hence the whole program) would
almost always return an empty array. Instead we sample the
value for channel_name lazily , once we encounter the filter,
picking one of the names present in the array.
Assume that we picked channel_name = "general" , and hence
the filter returns the first channel. Next, we simulate the call
toconversations _members on this channel’s ID. Because our
witness set is sparse, we may or may not find an exact match
for this call; in the latter case, we sample the response from
the set of approximate matches ,i.e.witnesses with the same𝑜::=User|Channel|... object names
𝑓::=u_info|... method names
𝑙::=in|out|0|id|name|... field labels
ℓ::=𝑙|?𝑙 record fields
loc::=𝑜.𝑙|𝑓.𝑙 locations
Terms
𝑒::= Expressions
|𝑥|𝑒.𝑙 variable, projection
|𝑓(𝑙𝑖=𝑒𝑖)|let𝑥=𝑒;𝑒method call, pure binding
|if𝑒=𝑒;𝑒|𝑥←𝑒;𝑒 guard, monadic binding
|return𝑒 pure value lifting
E::=𝜆𝑥.𝑒 Top Level Programs
Values
𝑣::="..."|[𝑣]|{𝑙𝑖=𝑣𝑖}strings, arrays, objects
Types
𝑡::= Syntactic types
|String strings
|𝑜|[𝑡]|{ℓ𝑖:𝑡𝑖}named objects, arrays, records
𝑠::=𝑡→𝑡 function types
ˆ𝑡::= Semantic types
|{loc} loc-sets
|𝑜|[ˆ𝑡]|{ℓ𝑖:ˆ𝑡𝑖}named objects, arrays, records
ˆ𝑠::=ˆ𝑡→ˆ𝑡 function types
Libraries
Λ::=𝑜:𝑡;𝑓:𝑠object and method definitions
ˆΛ::=𝑜:ˆ𝑡;𝑓:ˆ𝑠semantic definitions
Figure 6. Syntax of the language 𝜆𝐴
method names and argument names,4but not necessarily
the same argument values. Due to approximate matching,
RE results do not always equal the results of a real execution,
but they are still useful for estimating whether a program
candidate is able to produce meaningful outputs. For each
candidate, we run RE multiple times (with different random
seeds) and use the outputs to assign a rank to each candidate.
3 The Core Language
In this section, we formalize the core of APIphany ’s DSL as
𝜆𝐴, a functional language specialized for manipulating semi-
structured data. The syntax of 𝜆𝐴is summarized in Fig. 6.
Types. The types of 𝜆𝐴include syntactic types 𝑡(those used
in the OpenAPI spec) and semantic types ˆ𝑡, which we infer.
Both categories of types have named objects 𝑜, arrays[𝑡],
and records{ℓ𝑖:𝑡𝑖}.5Records are mappings from field labels
to types; some fields are optional, indicated with a ?before its
label. For example, the record type {id:String,?time_zone:
String}, has a required field idand an optional field time_zone.
4Because in REST some arguments are optional, the same method can be
called with different subsets of arguments.
5We write𝑋to denote zero or more occurrences of a syntactic element 𝑋.

--- PAGE 6 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
The two categories of types differ in their base types: the sole
primitive syntactic type is String ,6while the sole primitive
semantic type is a loc-set ,i.e.a set of locations.
Alocation is an object or method name followed by a
sequence of labels, such as User.id . Apart from field labels
that correspond to object fields in the OpenAPI spec, we
introduce three reserved labels— in,out, and 0—for address-
ing method parameters and responses, and array elements,
respectively. For example, c_list.out.0refers to an element
type of the response array of the method c_list.
Function types are written 𝑡→𝑡, and multiple arguments
are represented as a record whose fields encode argument
names (with optional fields encoding optional arguments).
A library Λmodels an OpenAPI spec. It contains object
definitions, which bind object identifiers to (record) types,
and method definitions, which bind method names to func-
tion types. A semantic library ˆΛ, which is the output of type
mining, binds object identifiers and method names to se-
mantic types. As an example, Fig. 7 shows Λdefinitions that
correspond to a portion of the Slack OpenAPI spec (with
method names shortened for brevity), and their correspond-
ing definitions in the semantic library ˆΛ.
Terms. Values of𝜆𝐴include string literals, arrays, and ob-
jects; objects are mappings from field labels to values. Simi-
larly to Haskell’s do-notation, return e returns an array with
a single element 𝑒, and the monadic binding 𝑥←𝑒1;𝑒2evalu-
ates𝑒2for each element 𝑥of the array𝑒1, and concatenates all
resulting arrays. In contrast, the pure binding let𝑥=𝑒1;𝑒2
binds𝑥to the entire result of 𝑒1and then evaluates 𝑒2. The
guard expression if𝑒1=𝑒2;𝑒evaluates𝑒if the guard holds
and returns an empty array otherwise; guards are restricted
to equalities, since these are the only guards generated by
APIphany . At the top level, a program Eis an abstraction
with a list of arguments 𝑥and body𝑒.
4 Type Mining
In this section we detail APIphany ’s type mining algorithm,
using the library Λin Fig. 7 and the witnesses in Fig. 4 as a
running example. Informally, the idea is to first assign every
String location locinΛa unique type{loc}, and then merge
the types of some locations based on the witnesses.
Assigning location-based types. We formalize the first step
as a judgement Λ⊢loc=⇒ˆ𝑡, which assigns a semantic type
ˆ𝑡to location locbased only on the information present in the
syntactic library Λ. The reader might be wondering why isn’t
the assigned type ˆ𝑡always simply{loc}. This is indeed the
case for String -annotated locations explicitly present in Λ,
such as User.id oru_info.in.user. But in other cases, location-
based type assignment is more involved; for example:
•Λ⊢u_info.out=⇒Userbecause this location is anno-
tated with a named object type.
6In practice, REST APIs also include integers and booleans; these types are
handled slightly differently in APIphany , as discussed in Sec. 7.4.•Λ⊢c_members.out=⇒[{c_members.out.0}]because ar-
ray types do not themselves get replaced with loc-sets;
instead, we recursively assign a location-based type to
an array’s element.
•Λ⊢u_info.out.id=⇒{User.id}because type assign-
ment canonicalizes locations inside types to make sure
they explicitly appear in Λ; to this end, we recursively
assign a type to location’s prefix, Λ⊢u_info.out=⇒
User, and then follow the field idof theUser object.
The formalization of location-based type assignment is mostly
straightforward and relegated to Appendix A (Fig. 15).
Merging types via a disjoint-set. Type mining relies on
a variant of the disjoint-set data structure (also known as
union-find [31]). Our disjoint-set 𝐷𝑆stores disjoint groups
of pairs(loc,𝑣), where locis a location and 𝑣is a string value.
When two pairs are in the same group, their corresponding
locations have the same semantic type.
DSsupports two efficient operations: insert andfind.insert
takes a pair(loc,𝑣)and checks whether either of its compo-
nents already appears in DS; if so, it merges the new pair
into the corresponding group, and otherwise puts it into a
new group. find takes a location locand returns a semantic
type ˆ𝑡; internally, find locates the group to which the pair
(loc,_)belongs in DSand returns the loc-set {loc,loc1,...}
that contains all locations in that group.
Type mining algorithm. Fig. 8 presents the top-level algo-
rithm MineTypes , which takes as input a syntactic library
Λand a set of witnesses W, and returns a semantic library
ˆΛ. Awitness𝑊is a triple⟨𝑓,𝑣𝑖𝑛,𝑣𝑜𝑢𝑡⟩, where𝑓is a method
name and𝑣𝑖𝑛,𝑣𝑜𝑢𝑡are its argument and response value (mul-
tiple arguments are represented as an object). MineTypes
operates in two phases: in lines 2–5 it builds the disjoint-set
DSfromWand in line 6 it build ˆΛfrom DS.
In the first phase, the algorithm iterates over the witnesses,
registering the input value 𝑣𝑖𝑛at the location 𝑓.inand the
output value 𝑣𝑜𝑢𝑡at the location 𝑓.out. To this end, we call a
helper function AddWitness , which drills down into com-
posite values (arrays and objects) to get to string literals,
and then insert s each string into DSwith its location-based
type. For example, when processing the response from the
first witness in Fig. 4, AddWitness iterates over all chan-
nel objects in the array, and over all fields of each chan-
nel object; once it reaches the value "UJ5RHEG4S" , it com-
putes the type of its location as Λ⊢c_list.out.0.creator =⇒
{Channel.creator}, and inserts(Channel.creator ,"UJ...")into
DS. Processing the second witness results in inserting the
pairs(u_info.in.user,"UJ...")and(User.id,"UJ..."), which
share the same string value, and hence all three pairs get
merged into the same group. Once all the witnesses are added
toDS, its groups represent the final set of semantic types.
In the second phase, the algorithm calls AddDefinitions
to iterate over all object and method definitions in Λ, and

--- PAGE 7 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
Syntactic library Λ Semantic library ˆΛObjectsChannel: { id: String,
name: String,
creator: String }
User: { id: String,
name: String,
profile: Profile }Channel: { id: Channel.id ,
name:Channel.name ,
creator: User.id }
User: { id: User.id ,
name:User.name ,
profile: Profile }Methodsc_list:
{}→[Channel]
u_info:
{user: String}→User
c_members:
{channel: String} →[String]c_list:
{}→[Channel]
u_info:
{user: User.id }→User
c_members:
{channel: Channel.id }→[User.id ]
Figure 7. Library Λthat models a portion of the Slack OpenAPI spec and the
corresponding semantic library ˆΛ. Each gray box is a loc-set type inferred by type
mining, depicted for brevity using a single representative location from the set.Input: A library Λand witnessesW
Output: A semantic library ˆΛ
1:function MineTypes (Λ,W)
2:DS←empty disjoint-set
3:for⟨𝑓,𝑣𝑖𝑛,𝑣𝑜𝑢𝑡⟩∈W do
4: AddWitness (DS,𝑓,in,𝑣𝑖𝑛)
5: AddWitness (DS,𝑓,out,𝑣𝑜𝑢𝑡)
6: ˆΛ←AddDefinitions (Λ,DS)
7:return ˆΛ
8:function AddWitness (DS,loc,𝑣)
9:match𝑣
10: case"..." :
11: Λ⊢loc=⇒{loc′}
12: DS←insert (DS,loc′,𝑣)
13: case[𝑣𝑖]:
14: forall𝑖:AddWitness (DS,loc.0,𝑣𝑖)
15: case{𝑙𝑖=𝑣𝑖}:
16: forall𝑖:AddWitness (DS,loc.𝑙𝑖,𝑣𝑖)
Figure 8. Type mining algorithm.
add corresponding definitions to ˆΛ, relying on find to re-
trieve the semantic type for each location. For example, when
adding the method u_info, we query find(DS,u_info.in.user),
which finds the group mentioned above and returns its loc-
set:{User.id,Channel.creator ,...}. If the requested location
is not in DS—becauseWhas no witnesses for the enclos-
ing method or object—it is annotated with the unmerged
location-based type.
5 Type-Directed Synthesis
In this section, we discuss how APIphany generates a set
of well-typed programs given a query type, using the same
running example as in previous sections.
Synthesis problem. Formally, our synthesis problem is de-
fined by a semantic library ˆΛand a semantic query type ˆ𝑠.
For our running example, we use the semantic library from
Fig. 7 and the query type Channel.name→[Profile.email].7A
candidate solution is any programEthat type-checks against
ˆ𝑠. To formalize this notion, we introduce the program typing
judgment ˆΛ⊢E::ˆ𝑠, which is mostly straightforward. We
note only that in a monadic binding 𝑥←𝑒1;𝑒2, both𝑒1and
𝑒2must have array types; in a guard if𝑒1=𝑒2;𝑒,𝑒must
have an array type, while 𝑒1and𝑒2must have (the same) loc-
set type, since equality is only supported over string values.
Full definition can be found in Appendix B (Fig. 16).
Type transition nets. To efficiently enumerate well-typed
programs we follow prior work [ 8,12] and encode the search
space as a special kind of Petri net, called type-transition
net(TTN). Intuitively, a TTN encodes how each API method
7Here and throughout this section, we write loc-set types using an arbitrarily
chosen representative; the user can query APIphany using any locations of
their choosing, and the tool interprets them as the loc-sets they belong to.transforms values of one semantic type into another; e.g.
u_infotransforms a User.id into aUser. Fig. 9 shows a TTN for
our running example. Places (circles) correspond to semantic
types, transitions (rectangles) correspond to methods, and
edges connect methods with their input and output types.
In addition to API methods, the TTN contains transitions
that correspond to 𝜆𝐴projections ( e.g.projUser.profile and
projProfile.email ) and guards ( e.g.filterChannel.name ).
Array-oblivious search. For our search space encoding to
be useful, we need to make sure that every well-typed 𝜆𝐴
program corresponds to a path in the TTN. This is where
we encounter a challenge: there is no straightforward way
to encode𝜆𝐴’s monadic bind operation into the TTN. Al-
though prior work on Hoogle+ [12] supports higher-order
functions, the arguments to those functions are syntactically
restricted to variables ( i.e.inner lambda abstractions are not
supported), which is insufficient for our purposes. To address
this problem, we introduce a new, array-oblivious TTN en-
coding, which does not distinguish between array types and
types of their elements, and hence does not require monadic
binds. For example, in Fig. 9 c_members returns Userinstead of
[User] , and hence its output can be passed directly to u_info,
without iterating over it.
Search in the TTN. Once the TTN is built, we enumerate
paths from the input to the output type (or rather, array-
oblivious versions thereof). In our example, we place a to-
kenin the input type Channel.name and search for a path (a
sequence of transitions) that would get this token to the out-
put type Profile.email , possibly generating and consuming
extra tokens along the way. The bold path in Fig. 9 corre-
sponds to our desired solution from Fig. 2. On this path, we
first fire the transition c_list (which does not consume any

--- PAGE 8 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Figure 9. A fragment of the type-transition net (TTN) for Slack . Places (circles) are
semantic types; transitions (rectangles) are API methods and data transformations.
The bold path represents the solution to our running example.Input: Semantic library ˆΛquery type ˆ𝑠
Output: Set of candidate solutions E
1:function Synthesize (ˆΛ,ˆ𝑠)
2:N← BuildTTN (ˆΛ)
3:𝐼,𝐹←PlaceTokens (ˆ𝑠)
4:for𝜋∈Paths(N,𝐼,𝐹)do
5: forE∈Progs(𝜋)do
6: yield Lift(ˆΛ,ˆ𝑠,E)
Figure 10. Synthesis algorithm
tokens) to produce an extra token in Channel . Next, we fire
filterChannel.name , which consumes the two tokens in Channel
andChannel.name , and produces a single token in Channel . The
remaining five transitions on the bold path simply move this
one token along until it reaches Profile.email .
Like in prior work [ 8,12], a path is only considered valid if
the final state contains exactly one token in the output type
(and no tokens in any other types); this condition ensures
that the generated programs use all their inputs.
Synthesis algorithm. APIphany ’s top-level synthesis algo-
rithm is depicted in Fig. 10. The algorithm first constructs
a TTNNand encodes the query type ˆ𝑠as an initial and
final token placement, 𝐼and𝐹; it then enumerates all paths
from𝐼to𝐹inNin the order of length (until timeout). For
each path𝜋, the algorithm iterates over the corresponding
array-oblivious programs Eandliftsthem into well-typed
𝜆𝐴programs. The reason 𝜋might yield multiple programs is
that the TTN does not distinguish different arguments of the
same type, and hence we must try all their combinations.
Because TTN construction and search for valid paths is
similar to prior work, we omit their detailed description and
refer an interested reader to Appendix B.
One difference worth mentioning, however, is that we use
aninteger linear programming (ILP) solver to find paths in
the TTN, unlike prior approaches, which relied on SAT/SMT
solvers. We found that although both solvers are equally
quick at finding one valid path , when it comes to computing
all valid paths of a given length, the ILP solver is much more
efficient, as it has native support for enumerating multiple
solutions.
Lifting array-oblivious programs. The function Progs(𝜋)
(line 5 in Fig. 10) converts a TTN path 𝜋into a set of array-
oblivious programs in A-Normal Form (ANF). Fig. 11 (left)
shows the full array-oblivious program extracted from the
bold path in Fig. 9. As you can see from this example, array-
oblivious programs can be ill-typed: for example, the projec-
tion𝑥1.namein line 4 does not type-check since 𝑥1actually1\channel _name→
2 letx1 = c_list({});
3
4 letx2 = x1.name;
5 ifx2=channel_name;
6 letx3 = x1.id;
7 letx4 = c_members(channel=x3);
8
9 letx5 = u_info(user=x4);
10 letx6 = x5.profile;
11 letx7 = x6.email;
12
13x7\channel _name→
letx1 = c_list({});
x1'←x1;
letx2 = x1'.name;
ifx2=channel_name;
letx3 = x1'.id;
letx4 = c_members(channel=x3);
x4'←x4;
letx5 = u_info(user=x4');
letx6 = x5.profile;
letx7 = x6.email;
letx7' = returnx7
x7'
Figure 11. Array-oblivious program built from the bold path
in Fig. 9 (left) and its lifted version (right).
has an array type[Channel]. What we really want this pro-
gram to do is to project name (and execute the remaining
steps in the program) for each channel in𝑥1. This can be
accomplished by inserting a monadic binding 𝑥′
1←𝑥1and
using𝑥′
1instead of𝑥1in line 4 (and elsewhere in the program
where a non-array version of 𝑥1is required, such as line 6).
We refer to this process of repairing type errors by inserting
monadic bindings and return s aslifting .8
The function Lift (line 6 in Fig. 10) takes as input a seman-
tic library ˆΛ, a query type ˆ𝑠, and an array-oblivious program
E, and produces a program E′that is well-typed at ˆ𝑠. Fig. 11
(right) depicts the result of lifting the program in Fig. 11
(left) to the query type Channel.name→[Profile.email]with
ˆΛfrom Fig. 7. The full definition of lifting can be found
in Appendix B (Fig. 18). Informally, lifting type-checks the
program “line by line”, and whenever it encounters a type
mismatch (in a projection, guard, or a method argument),
it inserts the appropriate number of monadic bindings or
8A reader familiar with monads might think of the array-oblivious program
as written in the identity monad instead of the list monad, and lifting as
lifting the program back into the list monad.

--- PAGE 9 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
return s in order to fix the mismatch. This is always possible
because the only kind of type mismatch we can encounter is
between an actual type [..[ˆ𝑡]..]and the expected type ˆ𝑡, or
vice versa. One thing worth noting is that we assume that
the top-level return type of the program is an array type:
since the lifted programs have top-level monadic bindings,
they can only return arrays. If the user requests a scalar re-
turn type, we take this into account at the ranking stage by
prioritizing programs that always return singleton arrays.
Completeness. Strictly speaking, array-oblivious search is
incomplete: there are multiple programs that map to the
same array-oblivious program, but lifting only returns a
single, canonical representative. For example, consider the
program in Fig. 11 (right), where we iterate over the array
x1only once (line 3), and reuse the same “iterator" variable
x1'in lines 4 and 6. An alternative would be to iterate over
x1the second time before line 6, effectively retrieving names
and IDs from all pairs of channels (instead of the name and
the ID belonging to the same channel). We consider this a
benign incompleteness because it is much less likely that
the user intended to loop twice over the same array. If they
did, we believe they would be able to repair the program by
hand, as we discuss in Sec. 7.4.
6 Ranking
As we mentioned in Sec. 2, the algorithm Synthesize may
generate hundreds or even thousands of well-typed candi-
date solutions, most of which, however, are uninteresting.
We now formalize how APIphany ranks these candidates
with the help of retrospective execution (RE).
Cost computation. To rank the programs, we assign them
a positive cost, and then order them from lowest to highest
cost. To compute the cost of a program E, we retrospectively
execute it multiple times, accumulating execution results in
a set res; retrospective execution is non-deterministic, and
executing a program more times lead to more precise cost
estimates. We then compute the cost of Ebased on its result
setresand the return type ˆ𝑡of the query as follows:
1. The base cost is the size of Ein AST nodes.
2.Ifres=∅(all executions have failed), the candidate
receives a large penalty.
3.Ifres={[]} (all executions return an empty array),
the candidate receives a medium penalty.
4.Finally, we compare the values 𝑣∈reswith the desired
result type ˆ𝑡; recall that𝜆𝐴programs always return an
array, while ˆ𝑡might or might not be an array type. We
assign a small penalty for a multiplicity mismatch ,i.e.
if either ˆ𝑡is a scalar type and anyvalue𝑣has more
than one element, or ˆ𝑡is an array type and allvalues
𝑣have a single element.Retrospective Execution ⟨W;Γ;Σ|𝑒⟩⇒𝑣
E-If-True-L𝑥1∈Σ𝑥2∉Σ Σ(𝑥1)=𝑣1
⟨W;Γ;𝑥2↦→𝑣1,Σ|𝑒⟩⇒𝑣
⟨W;Γ;Σ|if𝑥1=𝑥2;𝑒⟩⇒𝑣
E-If-True-R𝑥1∉Σ⟨W;Γ;Σ|𝑥2⟩⇒𝑣2
⟨W;Γ;𝑥1↦→𝑣2,𝑥2↦→𝑣2,Σ|𝑒⟩⇒𝑣
⟨W;Γ;Σ|if𝑥1=𝑥2;𝑒⟩⇒𝑣
E-Method-val(𝑓,𝑙𝑖=𝑣𝑖,𝑣𝑜𝑢𝑡)∈W
⟨W;Γ;Σ|𝑓(𝑙𝑖=𝑣𝑖)⟩⇒𝑣𝑜𝑢𝑡
E-Method-name∀(𝑓,𝑙𝑖=𝑣′
𝑖,𝑣𝑜𝑢𝑡)∈W.∃𝑖:𝑣′
𝑖≠𝑣𝑖
(𝑓,𝑙𝑖=𝑣′
𝑖,𝑣𝑜𝑢𝑡)∈W
⟨W;Γ;Σ|𝑓(𝑙𝑖=𝑣𝑖)⟩⇒𝑣𝑜𝑢𝑡
Figure 12. Retrospective execution.
Retrospective execution. We formalize RE as a judgement
⟨W;Γ;Σ|𝑒⟩⇒𝑣, stating that 𝑣is a valid result for exe-
cuting the expression 𝑒in the environment Σ(which maps
variables to values). The judgment is also parameterized by
a type context Γand witness setW, used to replay method
calls and sample program inputs. To run a candidate solution
E, we execute its body in an empty environment Σ=·and
withΓstoring the types of E’s arguments. As we explain in
more detail below, program inputs are selected lazily, during
execution, in order to maximize its chances of producing
meaningful results.
Replaying method calls. Most of the rules for the RE judge-
ment describe standard big-step operational semantics (they
can be found in Fig. 19 in Appendix C), but two groups of
rules, shown in Fig. 12, deserve more attention. The first
group of interest includes E-Method-Val andE-Method-
Name , which replay a method call by looking it up in W.
The rule E-Method-Val applies whenWcontains an exact
match for the current call, i.e.we have previously observed
a call to the same method, with the same parameter names
and parameter values. The rule E-Method-Name applies
when an exact match cannot be found (see first premise);
in this case we pick an approximate match, where only the
method name and parameter names match. Matching param-
eter names is important because many REST API methods
admit optional parameters, and behave very differently based
on which pattern of optional parameters is provided. If an ap-
proximate match cannot be found either, RE fails. Note that
for a given call 𝑓(𝑙𝑖=𝑣𝑖), there might be multiple approx-
imate matches inW, which makes RE non-deterministic
(in fact, there can even be multiple precise matches because
services are stateful). Due to hidden state and approximate
matches, the results of RE are not guaranteed to match actual
execution, but our experiments show that they are precise
enough for the purposes of ranking.

--- PAGE 10 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Table 1. APIs used in our experiments. For each API we
report the number of methods |Λ.𝑓|, min/max number of
arguments per method 𝑛arg, the number of objects |Λ.𝑜|, and
min/max size of the objects 𝑠obj. We also report the number of
witnesses|W| we collected for type mining and the number
of methods covered by those witnesses 𝑛cov.
API size API Analysis
API|Λ.𝑓|𝑛arg|Λ.𝑜|𝑠obj|W|𝑛cov
Slack 174 0 - 15 79 1 - 70 3834 60
Stripe 300 0 - 145 399 1 - 66 25402 124
Sqare 175 0 - 20 716 1 - 34 1749 67
Lazy sampling of program inputs. The remaining two
rules in Fig. 12 are responsible for choosing program inputs
so as to bias guard expressions to evaluate to true. We ob-
serve that when inputs are sampled eagerly ahead of time,
guard expressions almost always evaluate to false, causing
RE to return an empty array; as a result, our ranking heuris-
tic cannot distinguish meaningful candidates from those that
return an empty array regardless of the input. To address
this issue, we postpone adding program inputs to the envi-
ronment Σuntil they are used. If the first usage of a program
input is in a guard, the rules E-If-True-L andE-If-True-R
pick its value to make the guard true: E-If-True-L applies
when only the right-hand side of a guard is undefined, and
E-If-True-R applies when the left-hand side or both are un-
defined. If the first usage of an input is in a method call or a
projection, we instead randomly sample from all values of
the same type observed in W.
7 Evaluation
We implemented APIphany in Python, except for retrospec-
tive execution, where we used Rust for performance reasons.
We used the Gurobi ILP solver [ 13] v9.1 as the back-end for
TTN search. We ran all the experiments on a machine with
an Intel Core i9-10850K CPU and 32GB of memory.
We designed our empirical evaluation to answer the fol-
lowing research questions:
(RQ1) Can APIphany find solutions for a wide range of real-
istic tasks across multiple popular APIs?
(RQ2) Is type mining effective and necessary for enabling
type-directed synthesis?
(RQ3) Is retrospective execution effective and necessary for
prioritizing relevant synthesis results?
API selection. For our evaluation, we selected three popular
REST APIs: the Slack communication platform and two
online payment platforms, Stripe andSqare . We selected
these APIs because they are widely used and have both an
OpenAPI specification and a web interface, which allowed
us to set up the test environment and collect witnesses easily.
As shown in Tab. 1, these APIs are quite complex: each hasover a hundred methods with up to 145 arguments; all three
feature optional arguments. The three APIs also contain a
large number of object definitions, with up to 70 fields.
Experiment setup: type mining. Recall that type mining
relies on a witness set W. Witnesses are straightforward
to collect for API owners, or when an integration test suite
is publicly available; neither was the case in our setting.
Instead, we collected witnesses by observing traffic from
the services’s web interface, and then enhancing this initial
(very sparse) witness set via random testing; this process
is described in more detail in Appendix D. As shown in
Tab. 1, we collected between 1.7K and 25K witnesses per API,
which covered 30–40% of all methods. It is hard to obtain
full coverage for these closed source APIs as an outsider, for
instance, because many methods are only available to paid
accounts; our experiments show, however, that APIphany
performs well with this witness set.
Benchmark selection. For each API, we extracted program-
ming tasks from StackOverflow questions that mention
this API as well as GitHub repositories that use the API.
After excluding the tasks that were out of scope of our DSL,
we manually translated each of the remaining tasks from a
natural-language description or a code snippet into a type
query, resulting in 32 benchmarks (see Tab. 2). Apart from
our running example (benchmark 1.1), these include, for in-
stance: “Send a message to a user given their email” in Slack
(1.2), “Create a product and invoice a customer” in Stripe
(2.3), and “Delete catalog items with given names” in Sqare
(3.10). As noted in Tab. 2, many of these tasks are effectful :
they require creating, modifying, or deleting objects.
Each benchmark comes with a “gold standard” solution:
the accepted solution on StackOverflow or the snippet we
found on GitHub . We manually translated these solutions
into APIphany ’s DSL. As shown in the “Solution Size” por-
tion of Tab. 2, these solutions range in complexity from 7 to
22 AST nodes, containing up to three method calls and guards
and up to seven projections, which makes them non-trivial
for programmers to solve manually. A complete list of tasks,
type queries, and solutions can be found in Appendix E.
Experiment setup: program synthesis. For each of the 32
benchmarks, we ran the synthesizer with a timeout of 150
seconds. For each new candidate generated, we estimated its
cost using 15 rounds of RE and recorded the synthesis time
(including both TTN search and RE time). After the time-
out, we checked whether the gold standard solution appears
among the generated candidates and compared its RE-based
rank vs the original rank at which it was generated (based
on path length). Below we report average time and median
rank over three runs to reduce the impact of randomness.
7.1 RQ1: Overall Effectiveness
The last four columns of Tab. 2 detail APIphany ’s perfor-
mance on the 32 synthesis benchmarks. APIphany finds the

--- PAGE 11 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
Table 2. Synthesis benchmarks and results. Benchmarks
marked with†are effectful. For each benchmark we report
the size of the desired solution: AST, 𝑛𝑓,𝑛𝑝and𝑛𝑔corre-
spond to number of AST nodes, method calls, projections
and guards, respectively. We also report the time to find the
correct solution (in seconds), its rank without RE ( 𝑟orig), and
the lower and upper bound on its rank with RE ( 𝑟REand𝑟TO
RE).
‘-’ means no solution is found in 150 seconds.
API IDSolution Size Time Rank
AST𝑛𝑓𝑛𝑝𝑛𝑔 (sec)𝑟orig𝑟RE𝑟TO
RESlack1.1 17 3 6 1 83.5 25230 5 5
1.2†12 3 5 0 5.6 2224 10 10
1.3 16 3 7 0 - - - -
1.4 14 2 4 1 1.3 489 24 31
1.5†10 2 3 0 3.4 788 5 5
1.6†9 2 2 0 1.7 573 8 19
1.7†12 2 4 1 1.3 757 8 9
1.8 9 2 3 0 42.0 16438 29 30Stripe2.1†9 2 2 0 95.4 4952 3 3
2.2†10 2 2 0 92.4 4854 4 4
2.3†12 3 2 0 121.2 6363 1 1
2.4 8 1 2 1 0.5 3 1 1
2.5 8 2 2 0 1.0 10 4 4
2.6†9 3 2 0 12.2 270 3 3
2.7 5 1 2 0 0.6 4 2 2
2.8 16 2 7 1 20.2 679 17 17
2.9 6 1 2 0 0.5 2 1 1
2.10†10 2 3 0 7.8 187 6 6
2.11†7 2 1 0 17.2 490 6 6
2.12†11 3 2 0 - - - -
2.13†10 3 2 0 - - - -Sqare3.1 4 1 1 0 0.2 2 1 1
3.2 16 1 4 3 0.5 10 4 4
3.3 10 1 3 1 0.4 6 1 1
3.4 5 1 2 0 0.7 2 1 1
3.5†14 2 3 0 2.2 99 2 2
3.6 5 1 2 0 0.2 1 1 1
3.7 6 1 2 0 0.3 7 4 4
3.8 9 1 3 0 0.7 1 1 1
3.9 8 1 2 1 0.2 3 2 2
3.10†16 2 5 1 1.9 174 10 12
3.11†8 2 3 0 1.0 68 16 16
correct solution for 29 benchmarks. The remaining three
benchmarks fail with a timeout because their type queries
are too ambiguous; for example, in benchmark 1.3 (“Get un-
read messages of a user”) the type query has no means to
specify that we are only interested in unread messages; as
a result, the solution is drowned among thousands of other
programs that map a user ID to messages.
We plot the number of benchmarks solved as a function
of time (including RE) in Fig. 13. As the plot shows, majority
of benchmarks (19/32) can be solved within five seconds. On
Figure 13. Comparison of synthesis performance between
APIphany and its two variants that do not use type mining.
average APIphany takes 17.8 seconds to find the desired
solution (median time 1.3 seconds).
Takeaway: APIphany is able to solve 91% of tasks from
three real-world APIs.
7.2 RQ2: Type Mining
Recall that type mining involves replacing primitive syntactic
types in the spec with unique location-based types , and then
merging those based on the witness set to obtain semantic
types . The merging process is not perfect: it might fail to
merge two location that should have the same type because
the witness set lacks evidence to justify the merge; or it
might spuriously merge two locations if they share a value by
chance. It is hard to measure the accuracy of inferred types
directly, since we do not have an oracle for semantic types.
Instead, we evaluate type mining indirectly in two ways:
1) we run an ablation study to measure its impact on the
overall performance of the synthesizer, and 2) we perform a
small-scale qualitative analysis of inferred types.
Ablation study. For this experiment, we compare the perfor-
mance of APIphany and its two variants: (a) APIphany-Syn ,
which builds the TTN directly from syntactic types, and
(b)APIphany-Loc , which builds the TTN from (unmerged)
location-based types. We plot the number of benchmarks
solved by each variant as the function of time in Fig. 13.
As expected, both variants perform poorly: APIphany-
Synonly solves 4/32 benchmarks and APIphany-Loc solves
5. All these benchmarks are “easy” (solved by APIphany in
under a second). Intuitively, the two variants represent two
extremes in terms of type granularity . Syntactic types are
too coarse-grained (allString locations have the same type),
which leads TTN search to return too many well-typed can-
didates. As a result, APIphany-Syn struggles to solve all but
the simplest tasks, with many benchmarks running out of
memory. Location-based types, on the other hand, are too
fine-grained (eachString location has a unique type), which

--- PAGE 12 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
leads to most desired solutions simply being ill-typed, be-
cause there is no way for one method to use values returned
by another. The solutions to all of the five benchmarks solved
byAPIphany-Loc have only one method call with no pa-
rameters, followed by several projections or filters.
As you can see from Fig. 13, APIphany drastically outper-
forms both variants. This result indicates that type mining
strikes a good balance between coarse- and fine-grained
types: all 32 benchmarks have a well-typed solution in terms
of the mined types, and APIphany is able to find most of
them within a reasonable time.
Qualitative analysis. To give a more direct account of the
quality of inferred semantic types, we randomly sampled
five methods from each API (among the methods covered
by the collected witnesses), and manually inspected the in-
ferred types to check if they match our expectations. More
specifically, for each String location in a method spec, we
pick a location type loc∗, which we deem most natural for
a programmer to use in a type query (for example, for the
parameter to users_info,loc∗=User.id ); we consider the in-
ferred loc-set type sufficient if it contains loc∗. The detailed
results appear in Appendix E (Tab. 4).
In the methods we examined, type mining was able to infer
a sufficient semantic type for all responses, required param-
eters, and about half of optional parameters. The remaining
optional parameters were assigned unmerged location types,
because they were never used in our witness set. This is
almost unavoidable, because of the sheer number of obscure
optional parameters in real-world APIs (which, fortunately,
are rarely needed to solve programmer’s tasks).
Recall that the other failure mode of type mining is spuri-
ously merging unrelated locations. We did not observe any
spurious merges among the randomly sampled methods, but
anecdotally we did encounter one such merge elsewhere in
the Slack API: between Channel.name andMessage.name . Note
that spurious merges might slow down the search and pro-
duce some “semantically ill-typed” solutions, but they do not
prevent APIphany from finding the desired solution.
Takeaway: Type mining increases the percentage of
solved benchmarks from 12% to 91%.
7.3 RQ3: Ranking
To measure the effectiveness of RE-based ranking, we com-
pare the last three columns of Tab. 2: 𝑟origdenotes the rank
of the desired solution in the order it was generated by TTN
search (which is based on path length, and hence correlated
with solution size); 𝑟REdenotes the RE-based rank of the
solution at the time it was generated, and 𝑟TO
REdenotes its RE-
based rank by the timeout (which can be lower than 𝑟REas
other candidates generated later might end up being ranked
higher). We report both of these RE-based ranks because we
envision an APIphany user inspecting the candidate solu-
tions some time between they are generated and the timeout,
Figure 14. Number of benchmarks whose solution is re-
ported within a given rank. The filled blue area is the range
of ranks one might get depending on when they inspect the
candidates. The shaded area is the 95% confidence interval.
and hence the relevant rank value is between 𝑟REand𝑟TO
RE.
We plot the number of benchmarks whose solutions lie at or
below each rank in Fig. 14, with the range between 𝑟REand
𝑟TO
RErepresented as a filled area.
As you can see from Fig. 14, RE-based ranking signifi-
cantly increases the chances that the desired solution makes
the short-list of candidates. In particular, without RE-based
ranking only 8 benchmarks (28% of solved) return the correct
solution in top five, and only 12 (41%) return it in top ten; in
contrast, with RE-based ranking , 19 (65%) benchmarks return
the correct solution in top five (after timeout), and 23 (79%)
in top ten. Moreover, as we can see from Tab. 2, the solution’s
rank never gets worse after RE, in all but two cases it strictly
improves, and for all long-running benchmarks it improves
drastically (the average rank improves from 2230.5 to 7.0).
A closer look at the six benchmarks that do not land in top
ten after RE reveals two main reasons for these suboptimal
rankings. In most cases the solution is simply large, and there
are many smaller candidates that are still meaningful. For
example, the query “Delete all catalog items" (3.11) takes no
arguments and returns an array of all deleted items; there are
many valid and simple ways to construct an array of catalog
items without deleting them. In a few cases, APIphany fails
to throw out meaningless programs due to the imprecision
of retrospective execution. For example, in 1.6 it reports a
solution that posts an update to a given channel with a given
timestamp, even though this timestamp might be invalid
for this channel; APIphany instead thinks that this call al-
ways succeeds by relying on approximate matches during
retrospective execution.
We also recorded the time APIphany takes to compute the
cost for all generated candidates (which involves executing
each candidate 15 times). Although APIphany generates
thousands of well-typed candidates for most benchmarks,
cost computation only takes about 1% of total synthesis time.

--- PAGE 13 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
Takeaway: RE-based ranking takes a negligible amount
of time and increases the percentage of correct solutions
reported in top ten from 41% to 79%.
7.4 Discussion and Limitations
Witness generation. One threat to validity of our evalua-
tion is that the results of type minings (and therefore synthe-
sis) depend heavily on the witness set. In particular, if our
benchmarks required methods that are not covered by the
witness set, APIphany most likely would not be able to solve
them, since they would be ill-typed with inferred semantic
types. We ran our experiments using a particular witness
set, which we collected using one methodology (described
in Appendix D); our findings might not generalize to using
APIphany with witness sets collected by other means.
Effectful methods. We observe that effectful methods in
REST APIs have an interesting property: they make the ef-
fect explicit in their response. For example, the method for
posting a message on Slack also returns the message object,
and the method for deleting a catalog item in Sqare returns
the ID of the deleted item (instead of just returning void).
This property makes REST APIs particularly suitable for type-
directed synthesis and expressing user intent with types: for
example, the query “Send a message to a user with a given
email” can be expressed as the type Profile.email→Message
instead of a much less informative type Profile.email→void.
The downside, of course, is that the return type of an ef-
fectful method might not be obvious to the user (for ex-
ample, does deleting a catalog item return an object or its
ID?) One way to overcome this limitation is to let the user
specify the name of the last method they want to call ( e.g.
catalog_object_delete ) instead of the output type; this kind of
specification is straightforward to integrate into TTN search.
DSL restrictions. In our search for benchmarks, we encoun-
tered (very few) snippets that were inexpressible in our DSL
because they required functional transformations on prim-
itive values, as opposed to just structural transformations
on objects and arrays, for example: “Get all members of a
channel and concatenate them together". We consider such
functional transformations beyond the scope of APIphany
because its type-based specifications are too coarse to distin-
guish between different functional transformations. This is
also the reasoning behind our design decision to only support
equality inside guards, as opposed to more general predi-
cates: if the specification cannot distinguish between, say, =
and≤, there is little use in generating programs with both.
More generally, we view programs synthesized by APIphany
as a starting point, which helps the programmer figure out
how to plumb data through a set of API calls; we envision
the user building on top of those programs to add functionalmodifications and more expressive predicates. This inter-
action model motivates both our DSL restrictions and our
type-based specifications.
Value-based location merging. Value-based merging works
well for strings, since their large domain makes it unlikely
that two String locations share a value by chance. It works
less well for other primitive types, such as integers and
booleans. To reduce the risk of spurious merges, our im-
plementation performs value-based merging only for strings
and large integers ( >1000 ), but not for booleans or small
integers. In the future, we plan to investigate more sophis-
ticated approaches to location merging. One idea is to use
probabilistic reasoning to estimate the likelihood of two lo-
cations having the same type based on (1) how common a
value is across locations and (2) what proportion of values is
shared between the two locations. Another approach is to
cluster locations using NLP techniques, such as sentiment
analysis of object and field names, as well as documentation.
User interface. Another important direction for future work
is to investigate usable ways of specifying semantic type
queries and comprehending synthesis results. In particular,
existing work from the HCI community [ 9,10] might help
users quickly explore a large space of related candidate solu-
tions, thereby mitigating the limitations of ranking.
8 Related Work
APIphany is a component-based synthesizer and primarily
compares with related work in this space. It also draws on
techniques from specification mining and type inference.
Type-directed component-based synthesis. The goal of
component-based synthesis is to find a composition of com-
ponents (library functions) that implements a given task. In
type-directed component-based synthesis both the task and
the components are specified using types. The traditional
approach to this problem based on proof search [ 3,15,24]
scales poorly with the size of the component library. An
alternative, more scalable graph-based approach was intro-
duced in Prospector [21] for unary components, and gen-
eralized to 𝑛-ary components in SyPet [8], by replacing
graphs with Petri nets. TYGAR [12] further extends SyPet ’s
search to polymorphic components using the idea of abstract
types , which are inspired by succinct types from another
component-based synthesizer, InSynth [14].APIphany ’s
program search phase is using the Petri net encoding from
SyPet andTYGAR with minor adaptations (support for op-
tional arguments and ILP encoding). Our array-oblivious
encoding is related to abstract and succinct types in that it
helps make the Petri net smaller, but it is also substantially
different in that, unlike prior work, it can efficiently encode
a certain class of higher-order programs (array comprehen-
sions) into the Petri net.
API navigation. Beyond type-directed synthesis, other work
focuses on smart auto-completion [ 20,25,27] but relies on

--- PAGE 14 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
static analysis and mining client code, which APIphany
does not require. Among tools that leverage dynamic analy-
sis,EdSynth [34] uses test executions to generate snippets
that involve both API calls and control structures. Match-
Maker [36] and DemoMatch [35] are similar to APIphany
in that they rely on observed program traces to suggest code
that uses complex APIs (the former from types and the lat-
ter from demonstrations). All these techniques work in the
context of Java, and hence assume that sufficiently precise
types are already present.
SQL synthesis. The problem of generating projections and
filters is related to synthesis of SQL queries [ 32,33]. Exist-
ing SQL synthesis techniques are not directly applicable to
our problem domain, because (1) our programs also contain
arbitrary API method invocations, and (2) we manipulate
semi-structured data instead of relational data.
API discovery and specification mining. A complimen-
tary approach to API navigation using program synthesis is
to infer specifications [ 1,23,28] or example usages [ 4,6,17]
to help the user understand the API better. APIphany ’s type
mining is inspired by Ammons et al . [1], where they build
probabilistic finite state automata representing data and tem-
poral dependencies between API methods. APIphany imple-
ments a simpler form of their algorithm, which discovers
data flows (but not temporal dependencies), but the novelty
lies in using this information to drive program synthesis.
Type mining is also related to prior work on inferring
type annotations for dynamically typed languages from exe-
cutions [ 2,5,7]. However, this work is for structural types,
whereas we infer domain-specific nominal types.
Simulated execution. An alternative to our retrospective
execution is to synthesize a model of the API, and evaluate
program candidates against that model. Previous work [ 16,
19] synthesizes models for complex frameworks and opaque
code; our retrospective execution is simpler: it skips the extra
step of model synthesis.
Ranking solutions. Specifications in program synthesis are
often ambiguous, so synthesizers have to rank their candi-
date solutions and return the top result(s). Existing tools most
commonly rely on hand-crafted [ 11] or learned [ 14,27,29]
ranking functions based on syntactic features of generated
programs. Hoogle+ [18] is most similar to APIphany in that
it ranks programs based on the results of their execution ,
using heuristics like whether the program always fails, and
how similar it is to other candidates.
Acknowledgments
The authors would like to thank the anonymous reviewers,
our shepherd Yuepeng Wang, as well as Hila Peleg and Ilya
Sergey for their valuable feedback on earlier drafts of this
paper. This work was supported by the National Science
Foundation under Grants No. 1943623, 1911149, and 2107397.References
[1]Glenn Ammons, Rastislav Bodík, and James R. Larus. 2002. Mining
Specifications. In Proceedings of the 29th ACM SIGPLAN-SIGACT Sym-
posium on Principles of Programming Languages (Portland, Oregon)
(POPL ’02) . Association for Computing Machinery, New York, NY, USA,
4–16. https://doi.org/10.1145/503272.503275
[2]Jong-hoon (David) An, Avik Chaudhuri, Jeffrey S. Foster, and Michael
Hicks. 2011. Dynamic inference of static types for ruby. In POPL.
Austin, TX, USA, January 26-28, 2011 , Thomas Ball and Mooly Sagiv
(Eds.). ACM, 459–472.
[3]Lennart Augusstson. 2005. Djinn. https://github.com/augustss/djinn .
[4]Celeste Barnaby, Koushik Sen, Tianyi Zhang, Elena Glassman, and
Satish Chandra. 2020. Exempla Gratis (E.G.): Code Examples for Free.
InProceedings of the 28th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software
Engineering (Virtual Event, USA) (ESEC/FSE 2020) . Association for
Computing Machinery, New York, NY, USA, 1353–1364. https://doi.
org/10.1145/3368089.3417052
[5]Ambrose Bonnaire-Sergeant. 2019. Typed Clojure in Theory and Practice .
Ph.D. Dissertation. Indiana University, Bloomington.
[6]Raymond P. L. Buse and Westley Weimer. 2012. Synthesizing API
Usage Examples. In Proceedings of the 34th International Conference
on Software Engineering (Zurich, Switzerland) (ICSE ’12) . IEEE Press,
782–792.
[7]Ravi Chugh, Sorin Lerner, and Ranjit Jhala. 2011. Type Inference with
Run-time Logs. In Workshop on Scripts to Programs (STOP) .
[8]Yu Feng, Ruben Martins, Yuepeng Wang, Isil Dillig, and Thomas W.
Reps. 2017. Component-based synthesis for complex APIs. In POPL .
[9]Elena L. Glassman, Jeremy Scott, Rishabh Singh, Philip J. Guo, and
Robert C. Miller. 2015. OverCode: Visualizing Variation in Student
Solutions to Programming Problems at Scale. ACM Trans. Comput.-
Hum. Interact. 22, 2, Article 7 (mar 2015), 35 pages. https://doi.org/10
.1145/2699751
[10] Elena L. Glassman, Tianyi Zhang, Björn Hartmann, and Miryung
Kim. 2018. Visualizing API Usage Examples at Scale . Association for
Computing Machinery, New York, NY, USA, 1–12. https://doi.org/10
.1145/3173574.3174154
[11] Sumit Gulwani. 2011. Automating string processing in spreadsheets
using input-output examples. In Proceedings of the 38th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, POPL
2011, Austin, TX, USA, January 26-28, 2011 . 317–330. https://doi.org/
10.1145/1926385.1926423
[12] Zheng Guo, Michael James, David Justo, Jiaxiao Zhou, Ziteng Wang,
Ranjit Jhala, and Nadia Polikarpova. 2020. Program synthesis by type-
guided abstraction refinement. Proc. ACM Program. Lang. 4, POPL
(2020), 12:1–12:28.
[13] Gurobi Optimization, LLC. 2021. Gurobi Optimizer Reference Manual.
https://www.gurobi.com
[14] Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica Piskac. 2013.
Complete completion using types and weights. In PLDI .
[15] George T. Heineman, Jan Bessai, Boris Düdder, and Jakob Rehof. 2016.
A Long and Winding Road Towards Modular Synthesis. In Leveraging
Applications of Formal Methods, Verification and Validation: Founda-
tional Techniques - 7th International Symposium, ISoLA 2016, Impe-
rial, Corfu, Greece, October 10-14, 2016, Proceedings, Part I . 303–317.
https://doi.org/10.1007/978-3-319-47166-2_21
[16] Stefan Heule, Manu Sridharan, and Satish Chandra. 2015. Mimic:
Computing Models for Opaque Code. In Proceedings of the 2015 10th
Joint Meeting on Foundations of Software Engineering (Bergamo, Italy)
(ESEC/FSE 2015) . Association for Computing Machinery, New York,
NY, USA, 710–720. https://doi.org/10.1145/2786805.2786875
[17] Abbas Heydarnoori, Krzysztof Czarnecki, and Thiago Tonelli Bar-
tolomei. 2009. Supporting Framework Use via Automatically Ex-
tracted Concept-Implementation Templates. In Proceedings of the

--- PAGE 15 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
23rd European Conference on ECOOP 2009 — Object-Oriented Program-
ming (Italy) (Genoa) . Springer-Verlag, Berlin, Heidelberg, 344–368.
https://doi.org/10.1007/978-3-642-03013-0_16
[18] Michael B. James, Zheng Guo, Ziteng Wang, Shivani Doshi, Hila Peleg,
Ranjit Jhala, and Nadia Polikarpova. 2020. Digging for fold: synthesis-
aided API discovery for Haskell. Proc. ACM Program. Lang. 4, OOPSLA
(2020), 205:1–205:27.
[19] Jinseong Jeon, Xiaokang Qiu, Jonathan Fetter-Degges, Jeffrey S. Foster,
and Armando Solar-Lezama. 2016. Synthesizing Framework Models for
Symbolic Execution. In Proceedings of the 38th International Conference
on Software Engineering (Austin, Texas) (ICSE ’16) . Association for
Computing Machinery, New York, NY, USA, 156–167. https://doi.or
g/10.1145/2884781.2884856
[20] Sifei Luan, Di Yang, Celeste Barnaby, Koushik Sen, and Satish Chandra.
2019. Aroma: Code Recommendation via Structural Code Search. Proc.
ACM Program. Lang. 3, OOPSLA, Article 152 (Oct. 2019), 28 pages.
https://doi.org/10.1145/3360578
[21] David Mandelin, Lin Xu, Rastislav Bodík, and Doug Kimelman. 2005.
Jungloid Mining: Helping to Navigate the API Jungle. In PLDI .
[22] Erik Meijer, Brian Beckman, and Gavin Bierman. 2006. LINQ: Reconcil-
ing Object, Relations and XML in the .NET Framework. In Proceedings
of the 2006 ACM SIGMOD International Conference on Management of
Data (Chicago, IL, USA) (SIGMOD ’06) . Association for Computing
Machinery, New York, NY, USA, 706. https://doi.org/10.1145/1142473.
1142552
[23] Alon Mishne, Sharon Shoham, and Eran Yahav. 2012. Typestate-Based
Semantic Code Search over Partial Programs. In Proceedings of the
ACM International Conference on Object Oriented Programming Systems
Languages and Applications (Tucson, Arizona, USA) (OOPSLA ’12) .
Association for Computing Machinery, New York, NY, USA, 997–1016.
https://doi.org/10.1145/2384616.2384689
[24] Ulf Norell. 2008. Dependently Typed Programming in Agda. In Ad-
vanced Functional Programming, 6th International School, AFP 2008,
Heijen, The Netherlands, May 2008, Revised Lectures . 230–266. https:
//doi.org/10.1007/978-3-642-04652-0_5
[25] Daniel Perelman, Sumit Gulwani, Thomas Ball, and Dan Grossman.
2012. Type-directed completion of partial expressions. In ACM SIG-
PLAN Conference on Programming Language Design and Implemen-
tation, PLDI ’12, Beijing, China - June 11 - 16, 2012 . 275–286. https:
//doi.org/10.1145/2254064.2254098
[26] Inc. Postman. 2020. 2020 State of The API Report. https://www.post
man.com/state-of-api/api-technologies/ .[27] Veselin Raychev, Martin Vechev, and Eran Yahav. 2014. Code Comple-
tion with Statistical Language Models. SIGPLAN Not. 49, 6 (June 2014),
419–428. https://doi.org/10.1145/2666356.2594321
[28] Sharon Shoham, Eran Yahav, Stephen Fink, and Marco Pistoia. 2007.
Static specification mining using automata-based abstractions. In Pro-
ceedings of the ACM/SIGSOFT International Symposium on Software
Testing and Analysis, ISSTA 2007, London, UK, July 9-12, 2007 . 174–184.
[29] Rishabh Singh and Sumit Gulwani. 2015. Predicting a Correct Program
in Programming by Example. In CAV - 27th International Conference,
2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part I . 398–
414.
[30] Inc. SmartBear. 2020. The State of API Report 2020.
https://static1.smartbear.co/smartbearbrand/media/pdf/smartb
ear_state_of_api_2020.pdf .
[31] Robert Endre Tarjan. 1975. Efficiency of a Good But Not Linear Set
Union Algorithm. J. ACM 22, 2 (April 1975), 215–225. https://doi.or
g/10.1145/321879.321884
[32] Chenglong Wang, Alvin Cheung, and Rastislav Bodik. 2017. Synthe-
sizing Highly Expressive SQL Queries from Input-Output Examples.
InProceedings of the 38th ACM SIGPLAN Conference on Programming
Language Design and Implementation (Barcelona, Spain) (PLDI 2017) .
Association for Computing Machinery, New York, NY, USA, 452–466.
https://doi.org/10.1145/3062341.3062365
[33] Navid Yaghmazadeh, Yuepeng Wang, Isil Dillig, and Thomas Dillig.
2017. SQLizer: Query Synthesis from Natural Language. Proc. ACM
Program. Lang. 1, OOPSLA, Article 63 (Oct. 2017), 26 pages. https:
//doi.org/10.1145/3133887
[34] Z. Yang, J. Hua, K. Wang, and S. Khurshid. 2018. EdSynth: Synthesiz-
ing API Sequences with Conditionals and Loops. In 2018 IEEE 11th
International Conference on Software Testing, Verification and Validation
(ICST) . 161–171. https://doi.org/10.1109/ICST.2018.00025
[35] Kuat Yessenov, Ivan Kuraj, and Armando Solar-Lezama. 2017. De-
moMatch: API Discovery from Demonstrations. In Proceedings of
the 38th ACM SIGPLAN Conference on Programming Language De-
sign and Implementation (Barcelona, Spain) (PLDI 2017) . Associa-
tion for Computing Machinery, New York, NY, USA, 64–78. https:
//doi.org/10.1145/3062341.3062386
[36] Kuat Yessenov, Zhilei Xu, and Armando Solar-Lezama. 2011. Data-
Driven Synthesis for Object-Oriented Frameworks. In Proceedings of
the 2011 ACM International Conference on Object Oriented Programming
Systems Languages and Applications (Portland, Oregon, USA) (OOPSLA
’11). Association for Computing Machinery, New York, NY, USA, 65–82.
https://doi.org/10.1145/2048066.2048075

--- PAGE 16 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Expression Typing ˆΛ;Γ⊢𝑒::ˆ𝑡 ˆΛ⊢E::ˆ𝑠
T-Var𝑥:ˆ𝑡∈Γ
ˆΛ;Γ⊢𝑥::ˆ𝑡T-ProjˆΛ;Γ⊢𝑒::{𝑙:ˆ𝑡,...}
ˆΛ;Γ⊢𝑒.𝑙::ˆ𝑡
T-RetˆΛ;Γ⊢𝑒::ˆ𝑡
ˆΛ;Γ⊢return𝑒::[ˆ𝑡]
T-Call𝑓:{ℓ𝑗:ˆ𝑡𝑗}→ ˆ𝑡𝑜∈ˆΛ ˆΛ;Γ⊢𝑒𝑖::ˆ𝑡𝑖
∀𝑗.ℓ𝑗=𝑙𝑗⇒∃𝑖.𝑙𝑗=𝑙𝑖∧ˆ𝑡𝑗=ˆ𝑡𝑖
∀𝑗,𝑖.ℓ𝑗=?𝑙𝑗∧𝑙𝑗=𝑙𝑖⇒ˆ𝑡𝑗=ˆ𝑡𝑖
ˆΛ;Γ⊢𝑓(𝑙𝑖=𝑒𝑖)::ˆ𝑡𝑜
T-IfˆΛ;Γ⊢𝑒𝑥::{loc} ˆΛ;Γ⊢𝑒𝑦::{loc} ˆΛ;Γ⊢𝑒::[ˆ𝑡]
ˆΛ;Γ⊢if𝑒𝑥=𝑒𝑦;𝑒::[ˆ𝑡]
T-LetˆΛ;Γ⊢𝑒1::ˆ𝑡1ˆΛ;Γ,𝑥:ˆ𝑡1⊢𝑒2::ˆ𝑡2
ˆΛ;Γ⊢let𝑥=𝑒1;𝑒2::ˆ𝑡2
T-BindˆΛ;Γ⊢𝑒1::[ˆ𝑡1] ˆΛ;Γ,𝑥:ˆ𝑡1⊢𝑒2::[ˆ𝑡2]
ˆΛ;Γ⊢𝑥←𝑒1;𝑒2::[ˆ𝑡2]
T-ObjˆΛ;Γ⊢𝑒::𝑜 𝑜 :ˆ𝑡∈ˆΛ
ˆΛ;Γ⊢𝑒::ˆ𝑡
T-TopˆΛ;𝑥𝑖:ˆ𝑡𝑖⊢𝑒::ˆ𝑡
ˆΛ⊢𝜆𝑥𝑖.𝑒::{𝑥𝑖:ˆ𝑡𝑖}→ ˆ𝑡
Figure 16.𝜆𝐴: typing judgment.
Location-Based Type Inference Λ⊢loc=⇒ˆ𝑡
ObjStartΛ,𝑜⊢𝑙=⇒ˆ𝑡
Λ⊢𝑜.𝑙=⇒ˆ𝑡FunStartΛ,𝑓⊢𝑙=⇒ˆ𝑡
Λ⊢𝑓.𝑙=⇒ˆ𝑡
ObjBaseΛ,𝑜⊢[]=⇒𝑜PathBaseloc≠𝑜
Λ,loc⊢[]=⇒{loc}
ObjFollowΛ(loc.𝑙1)=𝑜Λ,𝑜⊢𝑙=⇒ˆ𝑡
Λ,loc⊢𝑙1.𝑙=⇒ˆ𝑡
ArrΛ(loc.𝑙)=[𝑡]Λ,loc.𝑙⊢0=⇒ˆ𝑡
Λ,loc⊢𝑙=⇒[ˆ𝑡]
AdHocΛ(loc.𝑙)={𝑙𝑖:𝑡𝑖}Λ,loc.𝑙⊢𝑙𝑖=⇒ˆ𝑡𝑖
Λ,loc⊢𝑙=⇒{𝑙𝑖:ˆ𝑡𝑖}
PathFollowΛ(loc.𝑙1)=String∨(Λ(loc.𝑙1)≠𝑜∧𝑙≠[])
Λ,loc.𝑙1⊢𝑙=⇒ˆ𝑡
Λ,loc⊢𝑙1.𝑙=⇒ˆ𝑡
Figure 15. Rules for location-based type inference.
A Type Mining
Location-based type inference. The location-based type in-
ference judgement Λ⊢loc=⇒ˆ𝑡is defined in Fig. 15. In thisfigure, the notation Λ(loc)=𝑡denotes looking up the syntac-
tic type of location locin the library Λ,e.g.Λ(User.profile)=
Profile andΛ(c_members.out.0)=String . At the same time,
Λ(User.profile.email)is undefined because it does not di-
rectly appear in Λ(instead we need to ask for Profile.email ).
The full definition of syntactic lookup is straightforward and
therefore omitted.
The main complication during location-based type infer-
ence is that we need to “fold” locations that denote named
objects, replacing them with object names; e.g.
Λ⊢users_info.out.id=⇒{User.id}
To this end we introduce an auxiliary judgment Λ,loc⊢𝑙=⇒
ˆ𝑡, where intuitively locand𝑙correspond to a prefix and a
suffix of the location of interest, except that locis sufficiently
“folded”. For example, to derive the judgment above, we will
start with
Λ,users_info⊢out.id=⇒···
but then use ObjFollow to fold the path and rewrite the
judgment it into
Λ,User⊢id=⇒···
and then by PathBase we can establish
Λ,User⊢id=⇒{User.id}
Note that because locin this judgment is always sufficiently
folded, all applications of Λ(loc.𝑙)in our rules are actually
well-defined.
The rules Arr and AdHoc deal with inference of array
types and record types. The rule Arr applies when the syn-
tactic type of the top-level location of interest is an array; in
this case we infer the semantic type ˆ𝑡of the array element
and return[ˆ𝑡]for the location. Note that this rule is not used
when an array-typed location occurs in the middle of a path
and not at the top level: in this case the default rule Path-
Follow applies. The rule AdHoc takes care of locations that
have ad-hoc record types in Λ(as opposed to names object
types); for example, we infer the type {user :User.id}for
the location users_info.in. Just like Arr, AdHoc only applies
when the top-level location has a record type, and otherwise
PathFollow suffices.
B Program Synthesis
Expression typing. The (semantic) typing rules for pro-
grams of𝜆𝐴are presented in Fig. 16. The typing judgement
ˆΛ;Γ⊢𝑒::ˆ𝑡states that a term 𝑒has the semantic type ˆ𝑡
under context Γand the semantic library ˆΛ. The rule T-Call
check that all required arguments are provided and all pro-
vided arguments have correct types. In a monadic binding
𝑥←𝑒1;𝑒2, both𝑒1and𝑒2must have array types ( T-Bind ).
In a guard if𝑒1=𝑒2;𝑒,𝑒must have an array type, while 𝑒1
and𝑒2cannot have an array or record type, since equality
is only supported over string values ( T-If). Finally, typing

--- PAGE 17 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
TTN Construction ˆΛ⊢N𝑐− →N′ˆΛ⊢N𝑐:ˆ𝑡−−→N′
C-Method𝑓:{ℓ𝑖:ˆ𝑡𝑖}→ ˆ𝑡𝑜∈ˆΛ ˆ𝑡𝑖𝑛={ℓ𝑖:⌊ˆ𝑡𝑖⌋}
𝑂′=𝑂[(𝑝,𝑓)↦→|{𝑙𝑖|?𝑙𝑖:𝑝∈ˆ𝑡𝑖𝑛}|]
𝐸′=𝐸[(𝑝,𝑓)↦→|{𝑙𝑖|𝑙𝑖:𝑝∈ˆ𝑡𝑖𝑛}|][(𝑓,⌊ˆ𝑡𝑜⌋)↦→ 1]
ˆΛ⊢(𝑃,𝑇,𝐸,𝑂)𝑓− →(𝑃∪{⌊ˆ𝑡𝑖⌋,⌊ˆ𝑡𝑜⌋},𝑇∪{𝑓},𝐸′,𝑂′)
C-Object𝑜:{ℓ𝑖:ˆ𝑡𝑖}∈ˆΛ ˆΛ⊢Nproj𝑜.𝑙𝑖:⌊ˆ𝑡𝑖⌋
−−−−−−−−−−→N′
𝑖
ˆΛ⊢ÐN′
𝑖filter 𝑜.𝑙𝑖:⌊ˆ𝑡𝑖⌋
−−−−−−−−−−→N′′
𝑖
ˆΛ⊢N𝑜− →ÐN′′
𝑖
C-Proj𝐸′=𝐸[(𝑜,proj𝑜.𝑙)↦→ 1,(proj𝑜.𝑙,ˆ𝑡)↦→ 1]
ˆΛ⊢(𝑃,𝑇,𝐸,𝑂)proj𝑜.𝑙:ˆ𝑡−−−−−−→(𝑃′∪{𝑜,ˆ𝑡},𝑇′∪{proj𝑜.𝑙},𝐸′,𝑂)
C-Filterˆ𝑡not obj. id
𝐸′=𝐸[(𝑜,filter𝑜.𝑙)↦→ 1,(ˆ𝑡,filter𝑜.𝑙)↦→ 1,(filter𝑜.𝑙,𝑜)↦→ 1]
Λ⊢(𝑃,𝑇,𝐸,𝑂)filter𝑜.𝑙:ˆ𝑡
−−−−−−−→(𝑃∪{𝑜,ˆ𝑡},𝑇∪{filter𝑜.𝑙},𝐸′,𝑂)
C-Filter-Obj𝑜′:{ℓ𝑖:ˆ𝑡𝑖}∈ˆΛ ˆΛ⊢Nfilter𝑜.𝑙.𝑙𝑖:⌊ˆ𝑡𝑖⌋
−−−−−−−−−−−→N′
𝑖
Λ⊢Nfilter𝑜.𝑙:𝑜′
−−−−−−−−→ÐN′
𝑖
Figure 17. TTN construction from a semantic library.
follows object definitions in ˆΛ: if𝑒has type𝑜and𝑜:ˆ𝑡∈Λ,
then𝑒also has the type ˆ𝑡(T-Obj ).
B.1 TTN Construction
A TTNNis a 4-tuple(𝑃,𝑇,𝐸,𝑂), where𝑃is a set of places ,
𝑇is a set of transitions , and𝐸:(𝑃×𝑇)∪(𝑇×𝑃)→N
is a matrix of edge multiplicities .𝐸(𝑝,𝜏)denotes how many
required arguments of type 𝑝component 𝜏consumes, and
𝐸(𝜏,𝑝)denotes how many responses of type 𝑝it produces.
𝐸(𝑝,𝜏)=0means that there is no edge from 𝑝to𝜏(and
symmetrically for 𝐸(𝜏,𝑝)=0). To model optional arguments,
in this work we augment the TTN with the matrix of optional
multiplicities 𝑂:𝑃×𝑇→N, which denotes the number of
optional arguments of a given type.
Amarking is a mapping 𝑀:𝑃→Nthat assigns a non-
negative number of tokens to every place. A transition firing
is a triple𝑀1𝜏− →𝑀2, such that for all places 𝑝: (a)𝑀1con-
tains at least as many tokens as 𝜏’s incoming edges require:
𝑀1(𝑝)≥𝐸(𝑝,𝜏), and (b)𝑀2loses tokens consumed by the
incoming edge, but gains tokens produced by the outgoing
edge:∃𝑐.𝐸(𝑝,𝜏)≤𝑐≤𝐸(𝑝,𝜏)+𝑂(𝑝,𝜏)∧𝑀2(𝑝)=𝑀1(𝑝)−
𝑐+𝐸(𝜏,𝑝). Apath between𝑀and𝑀′is a sequence of transi-
tions𝜏1,...,𝜏𝑛such that𝑀𝜏1−→𝑀1𝜏2−→...𝜏𝑛−1−−−→𝑀𝑛−1𝜏𝑛−→𝑀′
is a sequence of transition firings.
Array-oblivious encoding. Procedure BuildTTN(ˆΛ)(line
2 in Fig. 10) constructs a TTN Ngiven a semantic library.
Intuitively, its goal is to add transitions for all methods in ˆΛ,as well as other operations of 𝜆𝐴, such as projections and fil-
tering, such that any well-typed 𝜆𝐴program can be encoded
as a path inN. There is one major issue, however: 𝜆𝐴pro-
grams also contain the higher-order monadic bind operations
(aka “flat maps”), which cannot be easily encoded in a TTN;
moreover, the presence of array types in the TTN increases
the number of places and transitions, and slows down the
search. To combat this issue we propose the array-oblivious
encoding of𝜆𝐴programs into the TTN, which replaces array
types with types of their elements and monadic bindings
with regular let-bindings (which in the TTN corresponds to
simple sequencing of transitions). Formally, we define the
downgrading operation on semantic types ⌊ˆ𝑡⌋as follows:
⌊ˆ𝑡⌋=(
⌊ˆ𝑡′⌋ifˆ𝑡=[ˆ𝑡′]
ˆ𝑡otherwise
Construction rules. We formalize TTN construction using
the step relation ˆΛ⊢N𝑐− →N′defined in Fig. 17. A construc-
tion step adds an encoding of a library component 𝑐(method
or object) toNand produces a new TTN N′; to encode the
entire library ˆΛ, we compose steps for all methods and ob-
jects in the library. For example, Fig. 9 depicts (a fragment
of) the TTN built from the semantic library in Fig. 7; in this
figure, all edges have multiplicity 1 (since no method in ˆΛ
takes multiple arguments of the same type), and there are no
optional edges. In general, there are three kinds of transitions
in a TTN: method transitions, such as conversations _members ,
projection transitions, such as projUser.id , and filter transi-
tions, such as filterChannel.name . We now describe the construc-
tion rules for the three kinds of transitions in more detail.
The rule C-Method adds a transition for a method 𝑓and
connects it to the 𝑓’s (downgraded) input and output types.
For example, let 𝑓=conversations _members , whose down-
graded type is{channel :Channel.id}→User.id . In this case,
the rule C-Method extends the TTN with a transition 𝑓and
places{Channel.id,User.id}; it also sets 𝐸[(Channel.id,𝑓)]=
1,𝐸[(𝑓,User.id)]=1(and all other incoming and outgoing
edge multiplicities to 0). Fig. 17 uses the notation 𝐸[𝑘↦→𝑣],
to denote a map that is equal to 𝐸except for mapping 𝑘to
𝑣. Note that C-Method is the only rule that modifies op-
tional multiplicities 𝑂, since only methods can have optional
arguments.
The rule C-Object adds projection and filter transitions
for every field 𝑙of an object identifier 𝑜, merging the resulting
TTNs component-wise. The rule C-Proj adds a projection
transition proj𝑜.𝑙between an on object identifier 𝑜and the
type of𝑙.
Filter transitions are a little more involved, as they do not
mirror the structure of 𝜆𝐴guards one-to-one. Guards in their
general form are higher-order operations, and hence cannot
be directly encoded in the TTN. Fortunately, APIphany only
uses guards for one purpose: filtering objects from an array
𝑥𝑠if their constituent is equal to some 𝑦(in code:𝑥←

--- PAGE 18 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
𝑥𝑠;if𝑥.𝑙=𝑦;return𝑥). We encode this filtering operation
in the TTN as a filter transition filter𝑜.𝑙, which consumes 𝑜
(the downgraded type of 𝑥𝑠) and the type of 𝑦, and produces
𝑜. For example, the filter transition filterChannel.name in Fig. 9
consumes a Channel and aChannel.name and produces a Channel .
When𝑜.𝑙is an object, the rule C-Filter-Obj recursively
creates filter transitions for all its fields (recall that 𝜆𝐴only
supports guards on primitive values). For example, for the
object ID User, we will add a transition filterUser.profile.email ,
but not filterUser.profile .
B.2 TTN Search
Once the TTNNhas been constructed, the algorithm Syn-
thesize proceeds to enumerate paths from the initial mark-
ing𝐼to the final marking 𝐹inN.𝐼and𝐹are constructed
from the query type ˆ𝑡𝑖𝑛→ˆ𝑡𝑜as follows:
𝐼(𝑝)=|{𝑙𝑖|𝑙𝑖:𝑝∈⌊ˆ𝑡𝑖𝑛⌋}|
𝐹(𝑝)=if𝑝=⌊ˆ𝑡𝑜⌋then 1else0
For example, for the query Channel.name→[Profile.email],
the initial marking contains a single token in Channel.name
and the final marking contains a single token in Profile.email .
Hence, any valid path from 𝐼to𝐹must consume all inputs
and produce the output of the query type. Note that the TTN
as defined in Sec. B.1 encodes a linear type system ,i.e.can
only generate programs where each input is used exactly
once. Following prior work [ 8,12], our implementation adds
copy transitions to the TTN, which results in a relevant type
system ,i.e.one where every input has to be used at least once .
Prior work shows that this relevancy requirement is crucial
to filtering out meaningless solutions during search.
ILP encoding. To find paths in the TTN, prior work has re-
lied on a SAT/SMT encoding of TTN reachability. We have
found that although the SMT encoding from [ 12] works well
to find a handful of paths, in our domain we often need to
enumerate thousands of paths, which becomes very inef-
ficient. To address this problem, we instead use an integer
linear programming (ILP) solver, which provides native func-
tionality for computing all solutions to a constraint.
Given a TTNN=(𝑃,𝑇,𝐸,𝑂)with the initial marking
𝐼and the final marking 𝐹, we show how to build an ILP
formula that encodes all valid paths of a given length 𝐿. The
overall search proceeds by iteratively increasing the path
length𝐿. We encode the number of tokens in each place
𝑝∈𝑃at each time step 𝑘∈[0,𝐿]as a variable tok𝑝
𝑘. We
encode firing of transition 𝜏∈𝑇at time step 𝑘∈[0,𝐿−1]as
a variable fire𝜏
𝑘∈{0,1}, such that fire𝜏
𝑘=1indicates that 𝜏is
fired at time step 𝑘. For any𝜏∈𝑇, we define the pre-image
of𝜏aspre(𝜏)={𝑝∈𝑃|𝐸(𝑝,𝜏)>0∨𝑂(𝑝,𝜏)>0}and the
post-image of 𝜏aspost(𝜏)={𝑝∈𝑃|𝐸(𝜏,𝑝)>0}.
The formula for TTN reachability is a conjunction of the
following constraints:(1)If a transition 𝜏is fired at time step 𝑘, then all re-
quired places 𝑝∈pre(𝜏)have sufficiently many to-
kens:Ó𝐿−1
𝑘=0Ó
𝜏∈𝑇Ó
𝑝∈pre(𝜏)tok𝑝
𝑘≥𝐸(𝑝,𝜏)×fire𝜏
𝑘
(2)If a transition 𝜏is fired at time step 𝑘, then all places
𝑝∈pre(𝜏)∪post(𝜏)will have their marking updated
at time step 𝑘+1:Ó𝐿−1
𝑘=0Ó
𝜏∈𝑇Ó
𝑝∈pre(𝜏)∪post(𝜏)tok𝑝
𝑘−
(𝐸(𝑝,𝜏)+𝑂(𝑝,𝜏)−𝐸(𝜏,𝑝))×fire𝜏
𝑘≤tok𝑝
𝑘+1≤tok𝑝
𝑘−
(𝐸(𝑝,𝜏)−𝐸(𝜏,𝑝))×fire𝜏
𝑘
(3) At each time step, only one transition is fired:Ó𝐿−1
𝑘=0Í
𝜏∈𝑇fire𝜏
𝑘=1
(4)Variable domains are respected:Ó𝐿
𝑘=0Ó
𝑝∈𝑃0≤tok𝑝
𝑘
andÓ𝐿−1
𝑘=0Ó
𝜏∈𝑇0≤fire𝜏
𝑘≤1
(5) The initial marking 𝐼is valid:Ó
𝑝∈𝑃tok𝑝
0=𝐼(𝑝)
(6) The final marking is valid:Ó
𝑝∈𝑃tok𝑝
𝐿=𝐹(𝑝)
Note that constraint (2) approximates consumption of op-
tional arguments as a range between consuming all of them
(𝐸(𝑝,𝜏)+𝑂(𝑝,𝜏)) and consuming none of them ( 𝐸(𝑝,𝜏)). This
encoding is unsound when an optional argument has the
same type as the output. Consider firing a transition 𝜏at step
𝑘such that tok𝑝
𝑘=0,𝐸(𝑝,𝜏)=0,𝑂(𝑝,𝜏)=1,𝐸(𝜏,𝑝)=1;
our encoding 0≤tok𝑝
𝑘+1≤1, whereas the TTN definition
in Sec. B.1 requires tok𝑝
𝑘+1=1(the optional argument could
not be consumed since there was no token to consume). We
use the approximate encoding because in our experience
it is significantly more efficient than the exact alternatives,
which require additional variables and/or constraints. In our
evaluation, the unsoundness arises very rarely, and when it
does, the path is simply rejected by the type checker when
converted into a program.
B.3 Program Lifting
From paths to programs. The function Progs(𝜋)(line 5 in
Fig. 10) converts a TTN path 𝜋into a set of array-oblivious
programs in A-Normal Form (ANF). An ANF program is se-
quence of statements𝜎followed by a variable; the syntax of
ANF terms is given in Fig. 18. Progs converts each transition
in𝜋into a sequence of statements with a dedicated output
variable𝑥𝑜: a method transition becomes let𝑥𝑜=𝑓(𝑙𝑖=𝑥𝑖),
a projection transition becomes let𝑥𝑜=𝑥.𝑙, and a filter tran-
sition becomes let𝑥1=𝑥𝑜.𝑙1;...let𝑥𝑛=𝑥𝑛−1.𝑙𝑛;if𝑥𝑛=
𝑦. All emitted statements are then concatenated into an ANF
term𝜎1;...;𝜎𝑛;𝑥𝑛, where𝑥𝑛is the output variable of the
last transition. Fig. 11 (left) shows the full array-oblivious
program extracted from the bold path in Fig. 9. The reason
we use ANF as the intermediate representation instead of
generating𝜆𝐴terms directly is that ANF has a more direct
correspondence with TTN paths and also is more convenient
to work with during lifting; and ANF term can be translated
into a regular 𝜆𝐴term by recursing through the sequence
of statements and replacing sequential composition with 𝜆𝐴
letbindings, monadic bindings, or guard expressions.
Lifting rules. We formalize lifting of ANF terms as a term
lifting judgement Γ⊢𝑎↑ˆ𝑡{𝑎′⊣Γ′, defined in Fig. 18.

--- PAGE 19 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
ANF Syntax
𝜎::= let𝑥=𝑓(𝑙𝑖=𝑥𝑖)|let𝑥=𝑥.𝑙 Statements
|if𝑥=𝑥|𝑥←𝑥|let𝑥=return𝑥
𝑎::=𝜎;𝑥 ANF terms
Statement Lifting Γ⊢𝜎{𝜎′⊣Γ′
L-Call𝑓:{𝑙𝑖:ˆ𝑡𝑖}→ ˆ𝑡𝑜∈ˆΛ Γ𝑖−1⊢𝑥𝑖↑ˆ𝑡𝑖{𝜎𝑖;𝑥′
𝑖⊣Γ𝑖
Γ0=Γ𝜎′=(𝜎1;...;𝜎𝑛;let𝑥=𝑓(𝑙𝑖=𝑥′
𝑖))
Γ⊢let𝑥=𝑓(𝑙𝑖=𝑥𝑖){𝜎′⊣Γ𝑛,𝑥:ˆ𝑡𝑜
L-ProjΓ⊢𝑦::ˆ𝑡Γ⊢𝑦↑⌊ˆ𝑡⌋{𝜎;𝑦′⊣Γ′Γ′⊢𝑦′.𝑙::ˆ𝑡′
Γ⊢let𝑥=𝑦.𝑙{𝜎;let𝑥=𝑦′.𝑙⊣Γ′,𝑥:ˆ𝑡′
L-GuardΓ⊢𝑥::ˆ𝑡𝑥 Γ⊢𝑥↑⌊ˆ𝑡𝑥⌋{𝜎𝑥;𝑥′⊣Γ′
Γ⊢𝑦::ˆ𝑡𝑦Γ′⊢𝑦↑⌊ˆ𝑡𝑦⌋{𝜎𝑦;𝑦′⊣Γ′′
Γ⊢if𝑥=𝑦{𝜎𝑥;𝜎𝑦;if𝑥′=𝑦′⊣Γ′′
ANF Term Lifting Γ⊢𝑎↑ˆ𝑡{𝑎′⊣Γ′
L-SeqΓ⊢𝜎0{𝜎′
0⊣Γ′Γ′⊢𝜎;𝑥↑ˆ𝑡{𝜎′;𝑥′⊣Γ′′
Γ⊢𝜎0;𝜎;𝑥↑ˆ𝑡{𝜎′
0;𝜎′;𝑥′⊣Γ′′
L-VarΓ⊢𝑥::ˆ𝑡
Γ⊢𝑥↑ˆ𝑡{𝑥⊣Γ
L-Var-DownΓ⊢𝑥::[ˆ𝑡′] ˆ𝑡≠[ˆ𝑡′] _:𝑥ˆ𝑡′∉Γ fresh(𝑥′)
Γ,𝑥′:𝑥ˆ𝑡′⊢𝑥′↑ˆ𝑡{𝜎;𝑦⊣Γ′
Γ⊢𝑥↑ˆ𝑡{𝑥′←𝑥;𝜎;𝑦⊣Γ′
L-Var-RepeatΓ⊢𝑥::[ˆ𝑡′] ˆ𝑡≠[ˆ𝑡′]𝑥′:𝑥ˆ𝑡′∈Γ
Γ⊢𝑥′↑ˆ𝑡{𝜎;𝑦⊣Γ′
Γ⊢𝑥↑ˆ𝑡{𝜎;𝑦⊣Γ′
L-Var-UpΓ⊢𝑥::ˆ𝑡′ˆ𝑡′≠[ˆ𝑡] fresh(𝑥′)
Γ,𝑥′:[ˆ𝑡′]⊢𝑥′↑ˆ𝑡{𝜎;𝑦⊣Γ′
Γ⊢𝑥↑[ˆ𝑡]{let𝑥′=return𝑥;𝜎;𝑦⊣Γ′
Figure 18. Lifting rules.
Here𝑎is the array-oblivious term to be lifted, whose free
variables are defined in Γ,ˆ𝑡is the target type, 𝑎′is the lifted
term, and Γ′isΓextended with all the variables bound in 𝑎′.
The definition of term lifting relies on the auxiliary statement
lifting judgment Γ⊢𝜎{𝜎′⊣Γ′, which lifts a single state-
ment𝜎that appears in the environment Γinto a sequence of
statements𝜎′; again Γ′isΓextended with variables bound
in𝜎′. Both judgments implicitly rely on the semantic library
ˆΛ, which we omit for brevity since it is not modified. For
example, the statement in line 4 of Fig. 11 is lifted as follows:
𝑥1:[Channel]⊢let𝑥2=𝑥1.name{
𝑥′
1←𝑥1;let𝑥2=𝑥′
1.name⊣
𝑥1:[Channel],𝑥′
1:𝑥1Channel,𝑥2:Channel.name
Note that the binding for 𝑥′
1inΓ′is annotated with 𝑥1; we
introduce these annotations to keep track of mapping vari-
ables : here𝑥′
1is the mapping variable for the array 𝑥1, and it
will be reused later in the program whenever an element of
𝑥1is required again (see line 6).Let us now describe the rules in Fig. 18 in more detail.
The statement lifting rules enforce well-typing for the three
kinds of statements that appear in array-oblivious programs:
L-Call enforces that the arguments of a method call agree
with it definition in ˆΛ, while L-Proj andL-Guard make sure
their operands are scalars. The heavy lifting is done by the
rules L-Var-Down andL-Var-Up , both of which handle the
case of lifting a variable whose type ˆ𝑡′inΓdoes not match
the target type ˆ𝑡.L-Var-Down applies when ˆ𝑡′=[..[ˆ𝑡]..]:
in this case we generate a monadic binding 𝑥′←𝑥(and
then lift𝑥′again in case the array type was nested); this
rule is responsible for the monadic bindings in lines 3 and 8
of Fig. 11. Note that in the last premise we add the binding
𝑥′:𝑥ˆ𝑡′toΓto record that 𝑥′is the mapping variable for 𝑥.
IfΓalready has a mapping variable for 𝑥, we want to reuse
that variable instead of generating a new binding; this is
accomplished by the rule L-Var-Repeat . Finally, L-Var-Up
applies when the opposite is true, i.e.ˆ𝑡=[..[ˆ𝑡′]..]; in this
case we simply need to wrap 𝑥in a return . This rule generates
line 12 of Fig. 11: here the target return type of the program
isˆ𝑡=[Profile.email]and the type of 𝑥7isˆ𝑡′=Profile.email .
C Retrospective Execution
The full definition of the RE judgement is presented in Fig. 19.
D Witness Collection
For each API, we manually created a test environment via the
corresponding web interface and filled in some arbitrary test
data. We then ran several operations in the test environment,
using Google Chrome to record the web traffic in an HTTP
Archive (HAR) file: a JSON-formatted file that logs browser
interactions with a server. We then extracted initial witnesses
W0from the HAR file and ran the algorithm MineTypes
(Fig. 8) on these witnesses, resulting in an initial semantic
library ˆΛ0.
Unfortunately, the set W0obtained this way is sparse,
which may prevent the mining algorithm from merging
equivalent locations or even inferring types for some meth-
ods altogether. For example, if we only have initial wit-
nesses as shown in Fig. 4, APIphany is unable to infer the
semantic type of users_lookupByEmail that is required by one
of our benchmarks, and hence fail to solve this task. At
the same time, generating useful tests for this method is
challenging, because it only succeeds on inputs that corre-
spond to existing users’ emails. To improve the quality and
coverage of inferred types, APIphany generates additional
witnesses, using a combination of type-directed random
testing and a small amount of manual annotations. Specifi-
cally, APIphany draws test inputs from the bank of values
it has observed in the existing witnesses; in our example,
one of the strings that appear in Fig. 4 is "xyz@gmail.com" .
Calling users_lookupByEmail with this string succeeds and re-
turns"UJ5RHEG4S" . Based on the previously mined types of

--- PAGE 20 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Retrospective Execution ⟨W;Γ;Σ|𝑒⟩⇒𝑣
E-VarΣ(𝑥)=𝑣
⟨W;Γ;Σ|𝑥⟩⇒𝑣
E-Var-Lazy𝑥∉Σ Γ⊢𝑥::ˆ𝑡 𝑣∈W( ˆ𝑡)
⟨W;Γ;Σ|𝑥⟩⇒𝑣
E-Bind-Pure⟨W;Γ;Σ|𝑒1⟩⇒𝑣
⟨W;Γ;𝑥↦→𝑣,Σ|𝑒2⟩⇒𝑣′
⟨W;Γ;Σ|let𝑥=𝑒1;𝑒2⟩⇒𝑣′
E-Bind-Monad⟨W;Γ;Σ|𝑒1⟩⇒[𝑣𝑖]
⟨W;Γ;𝑥↦→𝑣𝑖,Σ|𝑒2⟩⇒𝑣′
𝑖
𝑣′=Ò𝑣′
𝑖
⟨W;Γ;Σ|𝑥←𝑒1;𝑒2⟩⇒𝑣′
E-Return⟨W;Γ;Σ|𝑥⟩⇒𝑣
⟨W;Γ;Σ|return𝑥⟩⇒[𝑣]
E-Projection⟨W;Γ;Σ|𝑥⟩⇒𝑣 hasField(𝑣,𝑙)
⟨W;Γ;Σ|𝑥.𝑙⟩⇒𝑣.𝑙
E-If-True-L𝑥1∈Σ𝑥2∉Σ Σ(𝑥1)=𝑣1
⟨W;Γ;𝑥2↦→𝑣1,Σ|𝑒⟩⇒𝑣
⟨W;Γ;Σ|if𝑥1=𝑥2;𝑒⟩⇒𝑣
E-If-True-R𝑥1∉Σ⟨W;Γ;Σ|𝑥2⟩⇒𝑣2
⟨W;Γ;𝑥1↦→𝑣2,𝑥2↦→𝑣2,Σ|𝑒⟩⇒𝑣
⟨W;Γ;Σ|if𝑥1=𝑥2;𝑒⟩⇒𝑣
E-If-True-LR𝑥1∈Σ𝑥2∈Σ Σ(𝑥1)=Σ(𝑥2)
⟨W;Γ;Σ|𝑒⟩⇒𝑣
⟨W;Γ;Σ|if𝑥1=𝑥2;𝑒⟩⇒𝑣
E-If-False𝑥1∈Σ 𝑥2∈Σ
Σ(𝑥1)=𝑣1Σ(𝑥2)=𝑣2𝑣1≠𝑣2
⟨W;Γ;Σ|if𝑥1=𝑥2;𝑒⟩⇒[]
E-Method⟨W;Γ;Σ|𝑥𝑖⟩⇒𝑣𝑖
⟨W;Γ;Σ|𝑓(𝑙𝑖=𝑣𝑖)⟩⇒𝑣𝑜𝑢𝑡
⟨W;Γ;Σ|𝑓(𝑙𝑖=𝑥𝑖)⟩⇒𝑣𝑜𝑢𝑡
E-Method-val(𝑓,𝑙𝑖=𝑣𝑖,𝑣𝑜𝑢𝑡)∈W
⟨W;Γ;Σ|𝑓(𝑙𝑖=𝑣𝑖)⟩⇒𝑣𝑜𝑢𝑡
E-Method-name∀(𝑓,𝑙𝑖=𝑣′
𝑖,𝑣𝑜𝑢𝑡)∈W.∃𝑖:𝑣′
𝑖≠𝑣𝑖
(𝑓,𝑙𝑖=𝑣′
𝑖,𝑣𝑜𝑢𝑡)∈W
⟨W;Γ;Σ|𝑓(𝑙𝑖=𝑣𝑖)⟩⇒𝑣𝑜𝑢𝑡
Figure 19. Retrospective execution.
these two strings, APIphany infers the type Profile.email→
User.id for the new method.
The top-level API analysis algorithm of APIphany is de-
picted in Fig. 20 (top). The algorithm alternates between calls
toMineTypes (to compute the best semantic library ˆΛit can
mine from the current witnesses W) and GenerateTests (to
augmentWusing the current ˆΛ). Analysis terminates either
ifˆΛandWreach a fixpoint, or when a timeout is reached.The algorithm returns both ˆΛ, which is used to build the
TTN during the synthesis step, and W, which is used for
retrospective execution during the ranking step; hence aug-
mentingWalso improves the quality of ranking.
Before we introduce the algorithm GenerateTests , we
augment the semantic library ˆΛwith a value bankV, which
is a mapping from semantic types to sets of values. The value
bank gets populated during type mining and contains all val-
ues that appear inW; for arrays and objects, it also contains
their constituents. With the value bank at hand, let us explain
the algorithm GenerateTests presented in Fig. 20 (bottom).
GenerateTests iterates through the method signatures in
ˆΛ, and for every method 𝑓:ˆ𝑡𝑖→ˆ𝑡𝑜, it samples a random
input of type ˆ𝑡𝑖, makes an API call to 𝑓with that input, and
if the call succeeds, yields the corresponding witness. It uses
the value bank (denoted ˆΛ.V) at line 7 to randomly sam-
ple an input from all values stored at semantic type ˆ𝑡. We
also observe that many API methods have optional argu-
ments and behave differently depending on which subset
of optional arguments is provided. To cover a wide range
of method behaviors, GenerateTests partitions the record
of all arguments ˆ𝑡𝑖into two records, each containing either
only required or only optional arguments (line 3). The algo-
rithm then iterates over all subsets of optional arguments
(line 4), attempting to make a call for each subset (our im-
plementation only iterates over subsets up to a pre-defined
size).
Fully automatic test generation helps us bootstrap seman-
tic type inference for methods that already appear in W0,
but it cannot add witnesses for methods that are missing en-
tirely. To address this problem, we manually add consumer-
producer annotations to those methods missing from W0.
In the evaluation, we collect witnesses by running the al-
gorithm AnalyzeAPI (Fig. 20) until it converges, alternating
test generation and type mining, which resulted in the final
set of witnessesWand library ˆΛ. The total running time
for API analysis depends on the number of methods and
their arguments, and ranged from several minutes to several
hours in our experiments.
E Benchmarks and Solutions
Tab. 3 contains benchmark descriptions and detailed results.
Tab. 4 contains the results of the qualitative analysis of mined
semantic types.
The rest of this section includes type queries and “gold
standard” solutions for all benchmarks. Note that the type
queries used here correspond directly to the OpenAPI spec;
earlier in the paper, type and method names were simplified
for readability.

--- PAGE 21 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
Input: Library Λ, initial witnessesW0
Output: Semantic library ˆΛ
Output: Augmented witnesses W
1:function AnalyzeAPI (Λ,W0)
2:W←W 0
3:repeat
4: ˆΛ←MineTypes (Λ,W)
5:W←W∪ GenerateTests(ˆΛ)
6:until fixpoint or timeout
7:return ˆΛ,WInput: Semantic library ˆΛ
Output: Generated witnesses W
1:function GenerateTests (ˆΛ)
2:for𝑓:{𝑙𝑖:ˆ𝑡𝑖,?𝑙𝑗:ˆ𝑡𝑗}→ ˆ𝑡𝑜∈ˆΛdo
3: ˆ𝑡𝑟𝑒𝑞,ˆ𝑡𝑜𝑝𝑡←{𝑙𝑖:ˆ𝑡𝑖},{?𝑙𝑗:ˆ𝑡𝑗}
4: forˆ𝑡𝑠𝑢𝑏⊂ˆ𝑡𝑜𝑝𝑡do
5:𝑣𝑖𝑛←{}
6: for𝑙:ˆ𝑡∈ˆ𝑡𝑟𝑒𝑞∪ˆ𝑡𝑠𝑢𝑏do
7:𝑣𝑖𝑛.𝑙←random(ˆΛ.V[ˆ𝑡])
8:𝑣𝑜𝑢𝑡←call(𝑓,𝑣𝑖𝑛)
9: if𝑣𝑜𝑢𝑡≠⊥then yield⟨𝑓,𝑣𝑖𝑛,𝑣𝑜𝑢𝑡⟩
Figure 20. Top-level API analysis algorithm and test generation.
Table 3. Synthesis benchmarks and results. Benchmarks marked with †are effectful. For each benchmark we report the size of
the desired solution: AST, 𝑛𝑓,𝑛𝑝and𝑛𝑔correspond to number of AST nodes, method calls, projections and guards, respectively.
We also report the time spent on RE-based ranking 𝑡REand the total synthesis time 𝑡Totalin seconds. In the last four columns,
we report the rank before RE 𝑟orig, the rank after RE among candidates that we find before the desired solution 𝑟RE, the total
number of candidates we get within timeout, and the rank after RE among all candidates within timeout 𝑟TO
RE. ‘-’ means no
solution is found in 150 seconds.
APIBenchmark Solution Size Timing Rank
ID Description AST𝑛𝑓𝑛𝑝𝑛𝑔𝑡Total𝑡RE𝑟orig𝑟RE #cands𝑟TO
RESlack1.1 Retrieve emails of all members in a channel 17 3 6 1 83.5 0.5 25230 5 38212 5
1.2†Send a message to a user given their email 12 3 5 0 5.6 0.1 2224 10 30437 10
1.3 Get the unread messages of a user 16 3 7 0 - - - - - -
1.4 Get all messages associated with a user 14 2 4 1 1.3 0.2 489 24 28012 31
1.5†Create a channel and invite a list of users 10 2 3 0 3.4 0.1 788 5 22426 5
1.6†Reply to a message and update it 9 2 2 0 1.7 0.1 573 8 39276 19
1.7†Send a message to a channel with the given name 12 2 4 1 1.3 <0.1 757 8 39078 9
1.8 Get the unread messages of a channel 9 2 3 0 42.0 0.8 16438 29 50757 30Stripe2.1†Subscribe to a product for a customer 9 2 2 0 95.4 0.6 4952 3 6312 3
2.2†Subscribe to multiple items 10 2 2 0 92.4 0.6 4854 4 6167 4
2.3†Create a product and invoice a customer 12 3 2 0 121.2 2.6 6363 1 6644 1
2.4 Retrieve a customer by email 8 1 2 1 0.5 <0.1 3 1 1751 1
2.5 Get a list of receipts for a customer 8 2 2 0 1.0 <0.1 10 4 4548 4
2.6†Get a refund for a subscription 9 3 2 0 12.2 0.1 270 3 4584 3
2.7 Get the emails of all customers 5 1 2 0 0.6 <0.1 4 2 1382 2
2.8 Get the emails of the subscribers of a product 16 2 7 1 20.2 0.2 679 17 3407 17
2.9 Get the last 4 digits of a customer’s card 6 1 2 0 0.5 <0.1 2 1 1812 1
2.10†Update payment methods for a user’s subscriptions 10 2 3 0 7.8 0.1 187 6 3068 6
2.11†Delete the default payment source for a customer 7 2 1 0 17.2 0.1 490 6 1373 6
2.12†Save a card during payment 11 3 2 0 - - - - - -
2.13†Send an invoice to a customer 10 3 2 0 - - - - - -Sqare3.1 List invoices that match a location id 4 1 1 0 0.2 <0.1 2 1 9544 1
3.2 List subscriptions by location, customer, and plan 16 1 4 3 0.5 <0.1 10 4 2526 4
3.3 Get all items a tax applies to 10 1 3 1 0.4 <0.1 6 1 11039 1
3.4 Get a list of discounts in the catalog 5 1 2 0 0.7 <0.1 2 1 11704 1
3.5†Add order details to order 14 2 3 0 2.2 <0.1 99 2 7222 2
3.6 Get payment notes of a payment 5 1 2 0 0.2 <0.1 1 1 9590 1
3.7 Get order ids of current user’s transactions 6 1 2 0 0.3 <0.1 7 4 8669 4
3.8 Get order names from a transaction id 9 1 3 0 0.7 <0.1 1 1 12323 1
3.9 Find customers by name 8 1 2 1 0.2 <0.1 3 2 3177 2
3.10†Delete catalog items with names 16 2 5 1 1.9 <0.1 174 10 11336 12
3.11†Delete all catalog items 8 2 3 0 1.0 <0.1 68 16 7429 16

--- PAGE 22 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
Table 4. A sample of API methods, with their expected and inferred semantic types. Non-string parameters and responses are
omitted since we do not perform inference for those.
API Method Field Type Required Name Expected Type Inferred TypeSlack/stars.add _POST ParameterNo channel defs_channel defs_group_id,defs _dm_id
No file defs_file_id /stars.add.in.file
No file_comment defs_comment_id /stars.add.in.file _comment
No timestamp defs_ts /stars.add.in.timestamp
/conversations.list _GET Parameter No types objs_conversation.types /conversations.list.in.types
/users.profile.get _GETParameter No user defs_user_idobjs_file.user, defs _bot_id, defs _topic_purpose_creator,
defs _user _id
Response - profile objs_user_profile objs _user _profile
/reminders.list _GET Response - reminders objs_reminder objs _reminder
/users.conversations _GET ParameterNo user defs_user_idobjs_file.user, defs _bot_id, defs _topic_purpose_creator,
defs _user _id
No types objs_conversation.types /users.conversations.in.typesStripe/v1/invoiceitems/{invoiceitem} _POSTParameterYes invoiceitem invoiceitem.id invoiceitem.id, line_item.invoice _item
No description invoiceitem.descriptionproduct.name, invoiceitem.description,
credit_note_line_item.description,
line_item.description
No discounts[0][coupon] discounts.coupon /v1/invoiceitems/{invoiceitem}.in.discounts.0.coupon
No discounts[0][discount] discounts.discount /v1/invoiceitems/{invoiceitem}.in.discounts.0.discount
No price price.id price.id , plan.id
No price_data[currency] invoice.lines.data.price.currency /v1/invoiceitems/{invoiceitem}.in.price _data.currency
No price_data[product] invoice.lines.data.price.product /v1/invoiceitems/{invoiceitem}.in.price _data.product
No tax_rates[0] tax_rate.id /v1/invoiceitems/{invoiceitem}.in.tax _rates.0
/v1/webhook _endpoints _GET Response - object N/A(Method returns constant string).radar.value _list.list _items.object,
credit_note.lines.object, customer.sources.object,
subscription.items.object, payment _intent.charges.object,
charge.refunds.object, file.links.object,
customer.subscriptions.object, invoice.lines.object
/v1/transfers _GETParameterNo destination account.id /v1/transfers.in.destination
No transfer _group transfer.transfer _group /v1/transfers.in.transfer _group
Response - object N/A(Method returns constant string).radar.value _list.list _items.object,
credit_note.lines.object, customer.sources.object,
subscription.items.object, payment _intent.charges.object,
charge.refunds.object, file.links.object,
customer.subscriptions.object, invoice.lines.object
/v1/subscription _items_GETParameter Yes subscription subscription.idinvoiceitem.subscription, invoice.subscription,
discount.subscription, subscription _item.subscription,
line_item.subscription, subscription.id
Response - object subscription.items.objectradar.value _list.list _items.object,
credit_note.lines.object, customer.sources.object,
subscription.items.object , payment _intent.charges.object,
charge.refunds.object, file.links.object,
customer.subscriptions.object, invoice.lines.object
/v1/tax_rates/{tax _rate}_POST ParameterYes tax_rate tax_rate.id tax_rate.id, invoice _tax_amount.tax _rate
No country tax_rate.country /v1/tax_rates/{tax _rate}.in.country
No description tax_rate.description tax_rate.description
No display_name tax_rate.display _name tax_rate.display _name
No jurisdiction tax_rate.jurisdictionaddress.state, invoice.account _country,
card.country, tax_rate.jurisdiction ,
tax_rate.country, source _type_card.country,
account.country, payment _method_card.country,
payment_method_details_card.country,
country_spec.supported _transfer _countries.[?],
card.address _state, country _spec.id,
address.country
No state tax_rate.state /v1/tax_rates/{tax _rate}.in.stateSqare/v2/customers_POST ParameterNo given_name Customer.given _name Customer.given _name, InvoiceRecipient.given _name
No family_name Customer.famile _name Customer.family _name, InvoiceRecipient.family _name
No company_name Customer.company _name Customer.company _name
No nickname Customer.nickname Customer.nickname
No email_address Customer.email _address /v2/customers.in.email _address
No address Address Address
No phone_number Customer.phone _number Customer.phone _number
No reference _id Customer.reference _id Customer.reference _id
No note Customer.note Customer.note
No birthday Customer.birthday /v2/customers.in.birthday
/v2/orders/{order _id}_GET Parameter Yes order_id Order.idTransaction.id, Payment.order _id,Order.id ,
Transaction.order _id, Invoice.order _id,
Tender.transaction _id, OrderEntry.order _id
/v2/catalog/list _GET ParameterNo types CatalogObject.type CatalogObject.type
No catalog_version CatalogObject.version /v2/catalog/list.in.catalog _version
/v2/labor/break-types _GET Parameter No location _id Location.id /v2/labor/break-types.in.location _id
/v2/inventory/batch-retrieve-counts _POST ParameterNo catalog_object_ids[0] CatalogObject.id /v2/inventory/batch-retrieve-counts.in.catalog _object_ids.0
No location _ids[0] Location.id /v2/inventory/batch-retrieve-counts.in.location _ids.0
No updated_after Counts.updated _at /v2/inventory/batch-retrieve-counts.in.updated _after
No states[0] Counts.states /v2/inventory/batch-retrieve-counts.in.states.0

--- PAGE 23 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
E.1 Slack
1.1. Retrieve emails of all members in a channel
Type query:
{ channel _name: objs _conversation.name } →[objs_user_profile.
↩→email]
Solution:
\channel _name→{
letx0 = /conversations _list_GET()
x1←x0.channels
ifx1.name = channel _name
letx2 = /conversations _members_GET(channel=x1.id)
x3←x2.members
letx4 = /users _profile_get_GET(user=x3)
returnx4.profile.email
}
Source: https://stackoverflow.com/questions/41564027/slack-api-retrieve-
all-member-emails-from-a-slack-channel
1.2. Send a message to a user given their email
Type query:
{ email: objs _user_profile.email }→objs_message
Solution:
\email→{
letx0 = /users _lookupByEmail _GET(email=email)
letx1 = /conversations _open_POST(users=x0.user.id)
letx2 = /chat _postMessage _POST(channel=x1.channel.id)
returnx2.message
}
Source: https://stackoverflow.com/questions/43733375/slack-api-post-me
ssage-via-user-email
1.3. Get the unread messages of a user
Type query:
{ user_id: defs _user_id }→[[objs_message]]
Solution:
\user_id→{
letx0 = /users _conversations _GET(user=user _id)
x1←x0.channels
letx2 = /conversations _info_GET(channel=x1.id)
letx3 = /conversations _history_GET(channel=x2.channel.id,
↩→oldest=x2.channel.last _read)
returnx3.messages
}
Source: https://stackoverflow.com/questions/64561594/is-it-possible-to-kn
ow-the-number-of-unread-slack-messages-a-user-has-with-the-s
1.4. Get all messages associated with a user
Type query:
{ user_id: defs _user_id,
ts: defs _ts
}→[objs_message]
Solution:
\user_id ts→{
letx0 = /conversations _list_GET()
x1←x0.channelsletx2 = /conversations _history_GET(channel=x1.id, oldest=ts)
x3←x2.messages
ifx3.user = user _id
returnx3
}
Source: https://github.com/hisabimbola/slack-history-export/blob/e53868
d8820ba65e5e726bd5968c80d5eb54c0db/src/utils.js
1.5. Create a channel and invite a list of users
Type query:
{ user_ids: [defs _user_id],
channel_name: objs _conversation.name
}→[objs_conversation]
Solution:
\user_ids channel _name→{
letx0 = /conversations _create_POST(name=channel _name)
x1←user_ids
letx2 = /conversations _invite_POST(channel=x0.channel.id,
↩→users=x1)
returnx2.channel
}
Source: https://stackoverflow.com/questions/48328380/slack-api-channels-
create-followed-by-channels-invite-info-returns-channel-not
1.6. Reply to a message and update it
Type query:
{ channel: defs _channel,
ts: defs _ts
}→objs_message
Solution:
\channel ts→{
letx1 = /chat _postMessage _POST(channel=channel, thread _ts=ts
↩→)
letx2 = /chat _update_POST(channel=channel, ts=x1.ts)
returnx2.message
}
1.7. Send a message to a channel with the given name
Type query:
{ channel: objs _conversation.name } →objs_message
Solution:
\channel→{
letx0 = /conversations _list_GET()
x1←x0.channels
ifx1.name = channel
letx2 = /chat _postMessage _POST(channel=x1.id)
returnx2.message
}
Source: https://github.com/backspace/slack-statsbot/blob/primary/src/st
atsbot.js
1.8. Get the unread messages of a channel
Type query:
{ channel _id: defs _channel }→[[objs_message]]
Solution:

--- PAGE 24 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
\channel _id→{
letx2 = /conversations _info_GET(channel=channel _id)
letx3 = /conversations _history_GET(channel=channel _id,
↩→oldest=x2.channel.last _read)
returnx3.messages
}
Source: https://stackoverflow.com/questions/64561594/is-it-possible-to-kn
ow-the-number-of-unread-slack-messages-a-user-has-with-the-s
E.2 Stripe
2.1. Subscribe to a product for a customer
Type query:
{ customer _id: customer.id,
product_id: product.id
}→[subscription]
Solution:
\customer _id product _id→{
letx1 = /v1/prices _GET(product=product _id)
x2←x1.data
letx3 = /v1/subscriptions _POST(customer=customer _id, items
↩→[0][price]=x2.id)
returnx3
}
Source: https://github.com/stripe-samples/charging-for-multiple-plan-su
bscriptions/blob/master/server/node/server.js
2.2. Subscribe to multiple items
Type query:
{ customer _id: customer.id,
product_ids: [product.id]
}→[subscription]
Solution:
\customer _id product _ids→{
x0←product_ids
letx1 = /v1/prices _GET(product=x0)
x2←x1.data
letx3 = /v1/subscriptions _POST(customer=customer _id, items
↩→[0][price]=x2.id)
returnx3
}
Source: https://github.com/stripe-samples/charging-for-multiple-plan-su
bscriptions/blob/master/server/node/server.js
2.3. Create a product and invoice a customer
Type query:
{ product _name: product.name,
customer _id: customer.id,
currency: fee.currency,
unit_amount: plan.amount
}→invoiceitem
Solution:
\product _name customer _id currency unit _amount→{
letx0 = /v1/products _POST(name=product _name)
letx1 = /v1/prices _POST(currency=currency, product=x0.id,
↩→unit_amount=unit _amount)
letx2 = /v1/invoiceitems _POST(customer=customer _id, price=x1
↩→.id)
returnx2}
Source: https://stripe.com/docs/invoicing/prices-guide
2.4. Retrieve a customer by email
Type query:
{ email: customer.email } →customer
Solution:
\email→{
letx0 = /v1/customers _GET()
x1←x0.data
ifx1.email = email
returnx1
}
Source: https://stackoverflow.com/questions/26767150/stripe-is-it-possib
le-to-search-a-customer-by-their-email
2.5. Get a list of receipts for a customer
Type query:
{ customer _id: customer.id } →[charge]
Solution:
\customer _id→{
letx1 = /v1/invoices _GET(customer=customer _id)
x2←x1.data
letx3 = /v1/charges/{charge} _GET(charge=x2.charge)
returnx3
}
Source: https://stackoverflow.com/questions/24335268/stripe-api-receipts-
listing
2.6. Get a refund for a subscription
Type query:
{ subscription: subscription.id } →refund
Solution:
\subscription→{
letx0 = /v1/subscriptions/{subscription _exposed_id}_GET(
↩→subscription _exposed_id=subscription)
letx1 = /v1/invoices/{invoice} _GET(invoice=x0.latest _invoice
↩→)
letx2 = /v1/refunds _POST(charge=x1.charge)
returnx2
}
Source: https://stackoverflow.com/questions/62403075/stripe-api-get-up
coming-invoice-for-cancelled-subscription
2.7. Get the emails of all customers
Type query:
{ }→[customer.email]
Solution:
\→{
letx0 = /v1/customers _GET()
x1←x0.data
returnx1.email
}
Source: https://stackoverflow.com/questions/65545997/python3-stripe-api-
to-get-all-customer-email
2.8. Get the emails of the subscribers of a product
Type query:

--- PAGE 25 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
{ product _id: product.id }→[customer.email]
Solution:
\product _id→{
letx1 = /v1/subscriptions _GET()
x2←x1.data
x3←x2.items.data
ifx3.price.product = product _id
letx4 = /v1/customers/{customer} _GET(customer=x2.customer)
returnx4.email
}
Source: https://stackoverflow.com/questions/35882771/use-stripe-api-to-
return-a-list-of-valid-subscribers
2.9. Get the last 4 digits of a customer’s card
Type query:
{ customer _id: customer.id } →bank_account.last4
Solution:
\customer _id→{
letx0 = /v1/customers/{customer}/sources _GET(customer=
↩→customer _id)
x1←x0.data
returnx1.last4
}
Source: https://stackoverflow.com/questions/30447026/getting-last4-digits-
of-card-using-customer-object-stripe-api-with-php
2.10. Update payment methods for a user’s subscriptions
Type query:
{ payment _method: payment _method,
customer _id: customer.id
}→[subscription]
Solution:
\payment _method customer _id→{
letx0 = /v1/subscriptions _GET(customer=customer _id)
x1←x0.data
letx2 = /v1/subscriptions/{subscription _exposed_id}_POST(
↩→subscription _exposed_id=x1.id,
↩→default_payment_method=payment _method.id)
returnx2
}
Source: https://stackoverflow.com/questions/58270828/update-credit-card-
details-of-user-for-all-subscriptions-in-stripe-using-api
2.11. Delete the default payment source for a customer
Type query:
{ customer _id: customer.id } →payment_source
Solution:
\customer _id→{
letx0 = /v1/customers/{customer} _GET(customer=customer _id)
letx1 = /v1/customers/{customer}/sources/{id} _DELETE(
↩→customer=customer _id, id=x0.default _source)
returnx1
}Source: https://stackoverflow.com/questions/17807881/stripe-api-throwi
ng-error-when-trying-to-delete-a-card
2.12. Save a card during payment
Type query:
{ cur: fee.currency,
amt: plan.amount,
pm: payment _method.id
}→payment_intent
Solution:
\cur amt pm→{
letx1 = /v1/customers _POST()
letx2 = /v1/payment _intents_POST(customer=x1.id,
↩→payment_method=pm, currency=cur, amount=amt)
letx3 = /v1/payment _intents/{intent}/confirm _POST(intent=x2.
↩→id)
returnx3
}
Source: https://github.com/stripe-samples/saving-card-after-payment/bl
ob/master/without-webhooks/server/node/server.js
2.13. Send an invoice to a customer
Type query:
{ customer _id: customer.id,
price_id: plan.id
}→invoice
Solution:
\customer _id price _id→{
letx1 = /v1/invoiceitems _POST(customer=customer _id, price=
↩→price_id)
letx2 = /v1/invoices _POST(customer=x1.customer)
letx3 = /v1/invoices/{invoice}/send _POST(invoice=x2.id)
returnx3
}
Source: https://stripe.com/docs/invoicing/integration#send-invoice
E.3 Sqare
3.1. List invoices that match a location id
Type query:
{ location _id: Location.id } →[Invoice]
Solution:
\location _id→{
letx0 = /v2/invoices _GET(location _id=location _id)
returnx0.invoices
}
Source: https://github.com/square/connect-api-examples/blob/4283ac967c
31b75dc17aceebd84f649093477e9a/connect-examples/v2/node_invoices/ro
utes/management.js
3.2. List subscriptions by location, customer, and plan
Type query:
{ customer _id: Customer.id,
location _id: Location.id,
plan_id: CatalogObject.id
}→[Subscription]
Solution:

--- PAGE 26 ---
PLDI ’22, June 13–17, 2022, San Diego, CA, USA Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova
\customer _id location _id plan_id→{
letx0 = /v2/subscriptions/search _POST()
x1←x0.subscriptions
ifx1.customer _id = customer _id
ifx1.location _id = location _id
ifx1.plan_id = plan _id
returnx1
}
Source: https://github.com/square/connect-api-examples/blob/4283ac967c
31b75dc17aceebd84f649093477e9a/connect-examples/v2/node_subscriptio
n/routes/subscription.js
3.3. Get all items a tax applies to
Type query:
{ tax_id: CatalogObject.id } →[CatalogObject]
Solution:
\tax_id→{
letx0 = /v2/catalog/search _POST()
x1←x0.objects
x2←x1.item_data.tax _ids
ifx2 = tax _id
returnx1
}
Source: https://github.com/square/catalog-api-demo/blob/85b6754c90fa7b
66fc5e605ee7a344314537eade/src/main/java/com/squareup/catalog/demo/e
xample/ApplyTaxToAllIItemsExample.java
3.4. Get a list of discounts in the catalog
Type query:
{ }→[CatalogDiscount]
Solution:
\→{
letx0 = /v2/catalog/list _GET()
x1←x0.objects
returnx1.discount _data
}
Source: https://github.com/square/catalog-api-demo/blob/master/src/mai
n/java/com/squareup/catalog/demo/example/ListDiscountsExample.java
3.5. Add order details to order
Type query:
{ location _id: Location.id,
order_ids: [Order.id],
updates: [OrderFulfillment]
}→[Order]
Solution:
\location _id order _ids updates→{
x0←order_ids
letx1 = /v2/orders/batch-retrieve _POST(location _id=
↩→location _id, order _ids[0]=x0)
x2←x1.orders
letx3 = {fulfillments=updates}
letx4 = /v2/orders/{order _id}_PUT(order _id=x2.id, order=x3)
returnx4.order
}
Source: https://github.com/square/connect-api-examples/blob/4283ac967c
31b75dc17aceebd84f649093477e9a/connect-examples/v2/node_orders-paym
ents/routes/checkout.js3.6. Get payment notes of a payment
Type query:
{ }→[Payment.note]
Solution:
\→{
letx0 = /v2/payments _GET()
x1←x0.payments
returnx1.note
}
Source: https://stackoverflow.com/questions/23252751/square-connect-api-
list-payments-endpoint-not-showing-description
3.7. Get order ids of current user’s transactions
Type query:
{ location _id: Location.id } →[Order.id]
Solution:
\location _id→{
letx0 = /v2/locations/{location _id}/transactions _GET(
↩→location _id=location _id)
x1←x0.transactions
returnx1.order _id
}
Source: https://stackoverflow.com/questions/46910044/getting-compact-
information-from-square-connect-api
3.8. Get order names from a transaction id
Type query:
{ location _id: Location.id,
transaction _id: Order.id
}→[Invoice.title]
Solution:
\location _id transaction _id→{
letx0 = /v2/orders/batch-retrieve _POST(location _id=
↩→location _id, order _ids[0]=transaction _id)
x1←x0.orders
x2←x1.line_items
returnx2.name
}
Source: https://stackoverflow.com/questions/58047894/square-connect-ho
w-to-retrieve-product-information-from-transaction-id
3.9. Find customers by name
Type query:
{ name: Customer.given _name }→Customer
Solution:
\name→{
letx0 = /v2/customers _GET()
x1←x0.customers
ifx1.given _name = name
returnx1
}
Source: https://developer.squareup.com/forums/t/search-customers-by-na
me/1567
3.10. Delete catalog items with names
Type query:

--- PAGE 27 ---
Type-Directed Program Synthesis for RESTful APIs PLDI ’22, June 13–17, 2022, San Diego, CA, USA
{ item_type: CatalogObject.type,
names: [CatalogItem.name]
}→[CatalogObject.id]
Solution:
\item_type names→{
letx0 = /v2/catalog/search _POST(object _types[0]=item _type)
x1←x0.objects
x2←names
ifx1.item_data.name = x2
letx3 = /v2/catalog/object/{object _id}_DELETE(object _id=x1.
↩→id)
x4←x3.deleted _object_ids
returnx4
}
Source: https://github.com/square/catalog-api-demo/blob/85b6754c90fa7b
66fc5e605ee7a344314537eade/src/main/java/com/squareup/catalog/demo/e
xample/DeleteCategoryExample.java3.11. Delete all catalog items
Type query:
{ }→[CatalogObject.id]
Solution:
\→{
letx0 = /v2/catalog/list _GET()
x1←x0.objects
letx2 = /v2/catalog/object/{object _id}_DELETE(object _id=x1.
↩→id)
returnx2.deleted _object_ids
}
Source: https://github.com/square/catalog-api-demo/blob/85b6754c90fa7b
66fc5e605ee7a344314537eade/src/main/java/com/squareup/catalog/demo/e
xample/DeleteAllItemsExample.java
