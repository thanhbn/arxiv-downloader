# ChatDev: Các Tác Nhân Giao Tiếp Cho Phát Triển Phần Mềm

Chen Qian⋆Wei Liu⋆Hongzhang Liu♠Nuo Chen⋆Yufan Dang⋆
Jiahao Li⋆Cheng Yang♣Weize Chen⋆Yusheng Su⋆Xin Cong⋆
Juyuan Xu⋆Dahai Li♦Zhiyuan Liu⋆BMaosong Sun⋆B
⋆Đại học Thanh Hoa♠Đại học Sydney♣BUPT♦Modelbest Inc.

## Tóm tắt

Phát triển phần mềm là một nhiệm vụ phức tạp đòi hỏi sự hợp tác giữa nhiều thành viên với các kỹ năng đa dạng. Nhiều nghiên cứu đã sử dụng deep learning để cải thiện các giai đoạn cụ thể trong mô hình thác nước, như thiết kế, lập trình và kiểm thử. Tuy nhiên, mô hình deep learning ở mỗi giai đoạn đòi hỏi thiết kế riêng biệt, dẫn đến sự không nhất quán kỹ thuật giữa các giai đoạn khác nhau, kết quả là quá trình phát triển bị phân mảnh và không hiệu quả. Trong bài báo này, chúng tôi giới thiệu ChatDev, một framework phát triển phần mềm dựa trên chat, trong đó các tác nhân chuyên biệt được điều khiển bởi các mô hình ngôn ngữ lớn (LLM) được hướng dẫn về việc giao tiếp gì (thông qua chuỗi chat) và cách giao tiếp (thông qua khử ảo giác giao tiếp). Các tác nhân này tích cực đóng góp vào các giai đoạn thiết kế, lập trình và kiểm thử thông qua giao tiếp dựa trên ngôn ngữ thống nhất, với các giải pháp được rút ra từ các cuộc đối화 đa vòng của họ. Chúng tôi thấy rằng việc sử dụng ngôn ngữ tự nhiên của họ có lợi cho thiết kế hệ thống, và giao tiếp bằng ngôn ngữ lập trình chứng tỏ hữu ích trong việc debug. Mô hình này chứng minh cách giao tiếp ngôn ngữ tạo điều kiện cho sự hợp tác đa tác nhân, thiết lập ngôn ngữ như một cầu nối thống nhất cho việc giải quyết nhiệm vụ tự động giữa các tác nhân LLM. Mã nguồn và dữ liệu có sẵn tại https://github.com/OpenBMB/ChatDev.

## 1. Giới thiệu

Các mô hình ngôn ngữ lớn (LLM) đã dẫn đến những chuyển đổi đáng kể do khả năng tích hợp dễ dàng kiến thức rộng lớn được thể hiện bằng ngôn ngữ (Brown et al., 2020; Bubeck et al., 2023), kết hợp với khả năng đóng vai mạnh mẽ trong các vai trò được chỉ định (Park et al., 2023; Hua et al., 2023; Chen et al., 2023b). Tiến bộ này loại bỏ nhu cầu thiết kế đặc thù cho mô hình và mang lại hiệu suất ấn tượng trong các ứng dụng downstream đa dạng. Hơn nữa, các tác nhân tự động (Richards, 2023; Zhou et al., 2023a) đã thu hút sự chú ý trong việc nâng cao khả năng của LLM với các tính năng tiên tiến như bộ nhớ nhận biết ngữ cảnh (Sumers et al., 2023), lập kế hoạch đa bước (Liu et al., 2023), và sử dụng công cụ chiến lược (Schick et al., 2023).

Phát triển phần mềm là một nhiệm vụ phức tạp đòi hỏi sự hợp tác giữa nhiều thành viên với các kỹ năng đa dạng (ví dụ, kiến trúc sư, lập trình viên và người kiểm thử) (Basili, 1989; Sawyer và Guinan, 1998). Điều này đòi hỏi giao tiếp rộng rãi giữa các vai trò khác nhau để hiểu và phân tích yêu cầu thông qua ngôn ngữ tự nhiên, đồng thời bao gồm phát triển và debug bằng ngôn ngữ lập trình (Ernst, 2017; Banker et al., 1998). Nhiều nghiên cứu sử dụng deep learning để cải thiện các giai đoạn cụ thể của mô hình thác nước trong phát triển phần mềm, như thiết kế, lập trình và kiểm thử (Pudlitz et al., 2019; Martín và Abran, 2015; Gao et al., 2019; Wang et al., 2016). Do những sự không nhất quán kỹ thuật này, các phương pháp được sử dụng trong các giai đoạn khác nhau vẫn bị cô lập cho đến nay. Mỗi giai đoạn, từ thu thập và gán nhãn dữ liệu đến huấn luyện mô hình và suy luận, đều đòi hỏi thiết kế riêng biệt, dẫn đến quá trình phát triển bị phân mảnh và kém hiệu quả trong lĩnh vực này (Freeman et al., 2001; Ernst, 2017; Winkler et al., 2020).

Được thúc đẩy bởi tiềm năng như chuyên gia của các tác nhân tự động, chúng tôi hướng đến việc thiết lập ngôn ngữ như một cầu nối thống nhất—sử dụng nhiều tác nhân được hỗ trợ bởi LLM với các vai trò chuyên biệt để phát triển phần mềm hợp tác thông qua giao tiếp dựa trên ngôn ngữ qua các giai đoạn khác nhau; các giải pháp trong các giai đoạn khác nhau được rút ra từ các cuộc đối thoại đa vòng của họ, dù xử lý văn bản hay mã nguồn. Tuy nhiên, do xu hướng ảo giác của LLM (Dhuliawala et al., 2023; Zhang et al., 2023b), chiến lược tạo phần mềm thông qua các tác nhân giao tiếp có thể dẫn đến thách thức không tầm thường của ảo giác lập trình, liên quan đến việc tạo ra mã nguồn không đầy đủ, không thể thực thi hoặc không chính xác, cuối cùng không thể đáp ứng yêu cầu dự định (Agnihotri và Chug, 2020). Sự xuất hiện thường xuyên của ảo giác lập trình lại phản ánh tính tự động hạn chế của các tác nhân trong việc hoàn thành nhiệm vụ, chắc chắn đòi hỏi sự can thiệp thủ công bổ sung và do đó cản trở khả năng sử dụng tức thì và độ tin cậy của phần mềm được tạo ra (Ji et al., 2023).

Trong bài báo này, chúng tôi đề xuất ChatDev (xem Hình 1), một framework phát triển phần mềm dựa trên chat tích hợp nhiều "tác nhân phần mềm" để tham gia tích cực vào ba giai đoạn cốt lõi của vòng đời phần mềm: thiết kế, lập trình và kiểm thử. Về mặt kỹ thuật, ChatDev sử dụng chuỗi chat để chia mỗi giai đoạn thành các tác vụ con nhỏ hơn, cho phép giao tiếp đa vòng của các tác nhân để hợp tác đề xuất và phát triển giải pháp (ví dụ, ý tưởng sáng tạo hoặc mã nguồn). Quy trình làm việc có cấu trúc chuỗi hướng dẫn các tác nhân về việc giao tiếp gì, thúc đẩy hợp tác và liên kết mượt mà các tác vụ con ngôn ngữ tự nhiên và lập trình để thúc đẩy giải quyết vấn đề. Ngoài ra, để giảm thiểu ảo giác lập trình, ChatDev bao gồm cơ chế khử ảo giác giao tiếp, cho phép các tác nhân chủ động yêu cầu chi tiết cụ thể hơn trước khi đưa ra phản hồi trực tiếp. Mô hình giao tiếp hướng dẫn các tác nhân về cách giao tiếp, cho phép trao đổi thông tin chính xác để tối ưu hóa giải pháp hiệu quả đồng thời giảm ảo giác lập trình. Chúng tôi đã xây dựng một bộ dữ liệu toàn diện chứa mô tả yêu cầu phần mềm và tiến hành phân tích toàn diện. Kết quả cho thấy ChatDev cải thiện đáng kể chất lượng phần mềm, dẫn đến độ hoàn chỉnh, khả năng thực thi được cải thiện và sự nhất quán tốt hơn với yêu cầu. Các điều tra sâu hơn cho thấy giao tiếp ngôn ngữ tự nhiên đóng góp vào thiết kế hệ thống toàn diện, trong khi giao tiếp ngôn ngữ lập trình thúc đẩy tối ưu hóa phần mềm. Tóm lại, mô hình được đề xuất chứng minh cách giao tiếp ngôn ngữ tạo điều kiện cho sự hợp tác đa tác nhân, thiết lập ngôn ngữ như một cầu nối thống nhất cho việc giải quyết nhiệm vụ tự động giữa các tác nhân LLM.

## 2. Công trình liên quan

Được huấn luyện trên các bộ dữ liệu khổng lồ để hiểu và thao tác hàng tỷ tham số, LLM đã trở thành trọng tâm trong xử lý ngôn ngữ tự nhiên do khả năng tích hợp liền mạch kiến thức rộng lớn (Brown et al., 2020; Bubeck et al., 2023; Vaswani et al., 2017; Radford et al.; Touvron et al., 2023; Wei et al., 2022a; Shanahan et al., 2023; Chen et al., 2021; Brants et al., 2007; Chen et al., 2021; Ouyang et al., 2022; Yang et al., 2023a; Qin et al., 2023b; Kaplan et al., 2020). Hơn nữa, LLM đã chứng minh khả năng đóng vai mạnh mẽ (Li et al., 2023a; Park et al., 2023; Hua et al., 2023; Chan et al., 2023; Zhou et al., 2023b; Chen et al., 2023b,a; Cohen et al., 2023; Li et al., 2023b). Tiến bộ gần đây, đặc biệt trong lĩnh vực tác nhân tự động (Zhou et al., 2023a; Wang et al., 2023a; Park et al., 2023; Wang et al., 2023e; Richards, 2023; Osika, 2023; Wang et al., 2023d), phần lớn được quy cho những tiến bộ cơ bản trong LLM. Các tác nhân này sử dụng khả năng mạnh mẽ của LLM, thể hiện kỹ năng đáng chú ý trong bộ nhớ (Park et al., 2023; Sumers et al., 2023), lập kế hoạch (Chen et al., 2023b; Liu et al., 2023) và sử dụng công cụ (Schick et al., 2023; Cai et al., 2023; Qin et al., 2023a; Ruan et al., 2023; Yang et al., 2023b), cho phép họ suy luận trong các kịch bản phức tạp (Wei et al., 2022b; Zhao et al., 2023; Zhou et al., 2023a; Ma et al., 2023; Zhang et al., 2023a; Wang et al., 2023b; Ding et al., 2023; Weng, 2023).

Phát triển phần mềm là một quá trình đa diện và phức tạp đòi hỏi sự hợp tác của nhiều chuyên gia từ các lĩnh vực khác nhau (Yilmaz et al., 2012; Acuna et al., 2006; Basili, 1989; Sawyer và Guinan, 1998; Banker et al., 1998; France và Rumpe, 2007), bao gồm phân tích yêu cầu và thiết kế hệ thống bằng ngôn ngữ tự nhiên (Pudlitz et al., 2019; Martín và Abran, 2015; Nahar et al., 2022), cùng với phát triển hệ thống và debug bằng ngôn ngữ lập trình (Gao et al., 2019; Wang et al., 2016; Wan et al., 2022). Nhiều nghiên cứu sử dụng mô hình thác nước, một vòng đời phát triển phần mềm cụ thể, để phân đoạn quá trình thành các giai đoạn riêng biệt (ví dụ, thiết kế, lập trình, kiểm thử) và áp dụng deep learning để cải thiện hiệu quả của một số giai đoạn nhất định (Winkler et al., 2020; Ezzini et al., 2022; Thaller et al., 2019; Zhao et al., 2021; Nijkamp et al., 2023; Wan et al., 2018; Wang et al., 2021).

## 3. ChatDev

Chúng tôi giới thiệu ChatDev, một framework phát triển phần mềm dựa trên chat tích hợp nhiều "tác nhân phần mềm" với các vai trò xã hội khác nhau (ví dụ, nhà phân tích yêu cầu, lập trình viên chuyên nghiệp và kỹ sư kiểm thử) hợp tác trong các giai đoạn cốt lõi của vòng đời phần mềm, xem Hình 1. Về mặt kỹ thuật, để tạo điều kiện cho giao tiếp hợp tác, ChatDev giới thiệu chuỗi chat để chia nhỏ mỗi giai đoạn thành các tác vụ con nhỏ hơn và dễ quản lý hơn, hướng dẫn giao tiếp đa vòng giữa các vai trò khác nhau để đề xuất và xác thực giải pháp cho mỗi tác vụ con. Ngoài ra, để giảm thiểu ảo giác bất ngờ, một mô hình giao tiếp có tên khử ảo giác giao tiếp được thiết kế, trong đó các tác nhân yêu cầu thông tin chi tiết hơn trước khi phản hồi trực tiếp và sau đó tiếp tục vòng giao tiếp tiếp theo dựa trên những chi tiết này.

### 3.1 Chuỗi Chat

Mặc dù LLM thể hiện sự hiểu biết tốt về ngôn ngữ tự nhiên và lập trình, việc chuyển đổi hiệu quả các yêu cầu văn bản thành phần mềm chức năng trong một bước duy nhất vẫn là một thách thức đáng kể. Do đó ChatDev áp dụng các nguyên tắc cốt lõi của mô hình thác nước, sử dụng chuỗi chat (C) với các giai đoạn tuần tự (P), mỗi giai đoạn bao gồm các tác vụ con tuần tự (T). Cụ thể, ChatDev phân đoạn quá trình phát triển phần mềm thành ba giai đoạn tuần tự: thiết kế, lập trình và kiểm thử. Giai đoạn lập trình được chia nhỏ thành các tác vụ con viết mã và hoàn thiện mã, và giai đoạn kiểm thử được phân đoạn thành đánh giá mã (kiểm thử tĩnh) và kiểm thử hệ thống (kiểm thử động), như được minh họa trong Hình 2. Trong mỗi tác vụ con, hai tác nhân, mỗi tác nhân có vai trò chuyên biệt riêng (ví dụ, một người đánh giá thành thạo xác định vòng lặp vô tận và một lập trình viên giỏi thiết kế GUI), thực hiện chức năng của một người hướng dẫn (I) và một trợ lý (A). Tác nhân hướng dẫn khởi tạo các hướng dẫn, hướng dẫn (→) diễn ngôn hướng tới việc hoàn thành tác vụ con, trong khi tác nhân trợ lý tuân thủ các hướng dẫn này và phản hồi với (;) các giải pháp thích hợp. Họ tham gia vào một cuộc đối thoại đa vòng (C), làm việc hợp tác cho đến khi họ đạt được sự đồng thuận, trích xuất (τ) các giải pháp có thể từ văn bản (ví dụ, định nghĩa một điểm chức năng phần mềm) đến mã (ví dụ, tạo phiên bản ban đầu của mã nguồn), cuối cùng dẫn đến việc hoàn thành tác vụ con. Toàn bộ quá trình giải quyết nhiệm vụ theo quy trình làm việc của tác nhân có thể được công thức hóa như sau:

C=⟨P1,P2, . . . ,P|C|⟩
Pi=⟨T1,T2, . . . ,T|Pi|⟩
Tj=τ C(I,A)
C(I,A) =⟨I → A ,A;I⟩⟲(1)

Thiết kế giao tiếp hai tác nhân đơn giản hóa giao tiếp bằng cách tránh các cấu trúc đa tác nhân phức tạp, hiệu quả hóa quá trình đạt được sự đồng thuận (Yin et al., 2023; Chen et al., 2023b). Tiếp theo, các giải pháp từ các nhiệm vụ trước đó phục vụ như những cầu nối đến giai đoạn tiếp theo, cho phép chuyển đổi mượt mà giữa các tác vụ con. Cách tiếp cận này tiếp tục cho đến khi tất cả các tác vụ con được hoàn thành. Đáng chú ý rằng cấu trúc kiểu chuỗi đơn giản về mặt khái niệm nhưng mạnh mẽ về mặt thực nghiệm hướng dẫn các tác nhân về việc giao tiếp gì, thúc đẩy hợp tác và liên kết mượt mà các tác vụ con ngôn ngữ tự nhiên và lập trình. Nó cũng cung cấp cái nhìn minh bạch về toàn bộ quá trình phát triển phần mềm, cho phép kiểm tra các giải pháp trung gian và hỗ trợ xác định các vấn đề có thể có.

**Tác nhân hóa** Để nâng cao chất lượng và giảm sự can thiệp của con người, ChatDev triển khai kỹ thuật prompt chỉ diễn ra ở đầu mỗi vòng tác vụ con. Ngay khi giai đoạn giao tiếp bắt đầu, người hướng dẫn và trợ lý sẽ giao tiếp với nhau trong một vòng lặp tự động, tiếp tục trao đổi này cho đến khi nhiệm vụ kết thúc. Tuy nhiên, việc chỉ trao đổi phản hồi không thể đạt được giao tiếp hướng nhiệm vụ đa vòng hiệu quả, vì nó chắc chắn phải đối mặt với những thách thức đáng kể bao gồm lật vai trò, lặp lại hướng dẫn và phản hồi giả mạo. Kết quả là, có sự thất bại trong việc thúc đẩy tiến trình giao tiếp hiệu quả và cản trở việc đạt được các giải pháp có ý nghĩa. Do đó ChatDev sử dụng cơ chế nhắc khởi tạo (Li et al., 2023a) để khởi tạo, duy trì và kết thúc giao tiếp của các tác nhân nhằm đảm bảo quy trình làm việc mạnh mẽ và hiệu quả. Cơ chế này bao gồm nhắc hệ thống người hướng dẫn PI và nhắc hệ thống trợ lý PA. Nhắc hệ thống cho cả hai vai trò chủ yếu đối xứng, bao gồm tổng quan và mục tiêu của tác vụ con hiện tại, các vai trò chuyên biệt, công cụ bên ngoài có thể truy cập, giao thức giao tiếp, điều kiện kết thúc, và các ràng buộc hoặc yêu cầu để tránh các hành vi không mong muốn. Sau đó, một người hướng dẫn I và một trợ lý A được khởi tạo bằng cách thôi miên LLM qua PI và PA:

I=ρ(LLM, PI),A=ρ(LLM, PA)(2)

trong đó ρ là hoạt động tùy chỉnh vai trò, được triển khai thông qua phân công thông điệp hệ thống.

**Bộ nhớ** Lưu ý rằng độ dài ngữ cảnh hạn chế của LLM thông thường thường giới hạn khả năng duy trì lịch sử giao tiếp đầy đủ giữa tất cả các tác nhân và giai đoạn. Để giải quyết vấn đề này, dựa trên bản chất của chuỗi chat, chúng tôi tương ứng phân đoạn bộ nhớ ngữ cảnh của các tác nhân dựa trên các giai đoạn tuần tự của họ, dẫn đến hai loại bộ nhớ có chức năng khác biệt: bộ nhớ ngắn hạn và bộ nhớ dài hạn. Bộ nhớ ngắn hạn được sử dụng để duy trì tính liên tục của đối thoại trong một giai đoạn duy nhất, trong khi bộ nhớ dài hạn được tận dụng để bảo tồn nhận thức ngữ cảnh qua các giai đoạn khác nhau.

Chính thức, bộ nhớ ngắn hạn ghi lại các phát ngôn giai đoạn hiện tại của tác nhân, hỗ trợ việc ra quyết định nhận biết ngữ cảnh. Tại thời điểm t trong giai đoạn Pi, chúng tôi sử dụng Iit để đại diện cho hướng dẫn của người hướng dẫn và Ait cho phản hồi của trợ lý. Bộ nhớ ngắn hạn M thu thập các phát ngôn đến thời điểm t như:

Mit=⟨(Ii1,Ai1),(Ii2,Ai2), . . . , (Iit,Ait)⟩(3)

Trong bước thời gian tiếp theo t+ 1, người hướng dẫn sử dụng bộ nhớ hiện tại để tạo ra một hướng dẫn mới Iit+1, sau đó được truyền đạt đến trợ lý để tạo ra một phản hồi mới Ait+1. Bộ nhớ ngắn hạn cập nhật lặp lại cho đến khi số lần giao tiếp đạt đến giới hạn trên |Mi|:

Iit+1=I(Mit),Ait+1=A(Mit,Iit+1)
Mit+1=Mit∪(Iit+1,Ait+1)(4)

Để nhận thức các cuộc đối thoại qua các giai đoạn trước, chuỗi chat chỉ truyền các giải pháp từ các giai đoạn trước đó làm bộ nhớ dài hạn M̃, tích hợp chúng ở đầu giai đoạn tiếp theo và cho phép truyền dẫn đối thoại dài qua giai đoạn:

Ii+11=M̃i∪Pi+1I,M̃i=i⋃j=1τ(Mj|Mj|)(5)

trong đó P tượng trưng cho một nhắc được định trước chỉ xuất hiện ở đầu mỗi giai đoạn.

Bằng cách chỉ chia sẻ các giải pháp của mỗi tác vụ con thay vì toàn bộ lịch sử giao tiếp, ChatDev giảm thiểu rủi ro bị choáng ngợp bởi quá nhiều thông tin, tăng cường tập trung vào mỗi nhiệm vụ và khuyến khích hợp tác có mục tiêu hơn, đồng thời tạo điều kiện cho tính liên tục ngữ cảnh qua giai đoạn.

### 3.2 Khử ảo giác giao tiếp

Ảo giác LLM biểu hiện khi mô hình tạo ra đầu ra vô nghĩa, không đúng sự thật hoặc không chính xác (Dhuliawala et al., 2023; Zhang et al., 2023b). Vấn đề này đặc biệt quan ngại trong phát triển phần mềm, nơi ngôn ngữ lập trình đòi hỏi cú pháp chính xác—việc thiếu thậm chí một dòng duy nhất có thể dẫn đến lỗi hệ thống. Chúng tôi đã quan sát thấy LLM thường tạo ra ảo giác lập trình, bao gồm các vấn đề tiềm ẩn như triển khai không đầy đủ, mã không thể thực thi và sự không nhất quán không đáp ứng yêu cầu. Ảo giác lập trình thường xuất hiện khi trợ lý gặp khó khăn trong việc tuân thủ chính xác hướng dẫn, thường do tính mơ hồ và tổng quát của một số hướng dẫn nhất định đòi hỏi nhiều điều chỉnh, khiến các tác nhân gặp khó khăn trong việc đạt được sự tuân thủ hoàn toàn. Được truyền cảm hứng bởi điều này, chúng tôi giới thiệu khử ảo giác giao tiếp, khuyến khích trợ lý chủ động tìm kiếm các gợi ý chi tiết hơn từ người hướng dẫn trước khi đưa ra phản hồi chính thức.

Cụ thể, một mô hình giao tiếp vanilla giữa trợ lý và người hướng dẫn tuân theo định dạng hướng dẫn-phản hồi đơn giản:

⟨I → A ,A;I⟩⟲ (6)

Ngược lại, cơ chế khử ảo giác giao tiếp của chúng tôi có tính năng "đảo vai trò" có chủ ý, trong đó trợ lý đảm nhận vai trò giống như người hướng dẫn, chủ động tìm kiếm thông tin cụ thể hơn (ví dụ, tên chính xác của một phụ thuộc bên ngoài và lớp liên quan của nó) trước khi đưa ra phản hồi kết luận. Sau khi người hướng dẫn cung cấp một gợi ý sửa đổi cụ thể, trợ lý tiến hành thực hiện tối ưu hóa chính xác:

⟨I → A ,⟨A → I ,I;A⟩⟲,A;I⟩⟲(7)

Vì cơ chế này giải quyết một vấn đề cụ thể tại một thời điểm, nó đòi hỏi nhiều vòng giao tiếp để tối ưu hóa các vấn đề tiềm ẩn khác nhau. Mô hình giao tiếp hướng dẫn các tác nhân về cách giao tiếp, cho phép trao đổi thông tin tinh tế hơn để tối ưu hóa giải pháp hiệu quả, điều này thực tế hỗ trợ việc giảm ảo giác lập trình.

## 4. Đánh giá

**Đường cơ sở** Chúng tôi đã chọn một số phương pháp phát triển phần mềm dựa trên LLM đại diện làm đường cơ sở của chúng tôi. GPT-Engineer (Osika, 2023) là một cách tiếp cận tác nhân đơn cơ bản trong các tác nhân phần mềm được điều khiển bởi LLM với hiểu biết chính xác về yêu cầu nhiệm vụ và việc áp dụng lý luận một bước, điều này làm nổi bật hiệu quả của nó trong việc tạo ra các giải pháp phần mềm chi tiết ở cấp repository. MetaGPT (Hong et al., 2023) là một framework tiên tiến phân bổ các vai trò cụ thể cho các tác nhân phần mềm được điều khiển bởi LLM khác nhau và kết hợp các quy trình hoạt động tiêu chuẩn để cho phép sự tham gia đa tác nhân. Trong mỗi bước, các tác nhân với các vai trò cụ thể tạo ra giải pháp bằng cách tuân thủ các hướng dẫn tĩnh được định trước bởi các chuyên gia con người.

**Bộ dữ liệu** Lưu ý rằng, đến nay, không có bộ dữ liệu công khai chứa các mô tả văn bản về yêu cầu phần mềm trong bối cảnh phát triển phần mềm được điều khiển bởi tác nhân. Để đạt được mục tiêu này, chúng tôi đang tích cực làm việc để phát triển một bộ dữ liệu toàn diện cho các mô tả yêu cầu phần mềm, mà chúng tôi gọi là SRDD (Bộ dữ liệu mô tả yêu cầu phần mềm). Dựa trên công trình trước đây (Li et al., 2023a), chúng tôi sử dụng các mô tả phần mềm hiện có làm ví dụ ban đầu, sau đó được phát triển thêm thông qua một quy trình kết hợp tạo tự động dựa trên LLM với tinh chỉnh hậu xử lý được hướng dẫn bởi con người. Kết quả là, bộ dữ liệu này bao gồm các danh mục phần mềm quan trọng từ các nền tảng phổ biến như Ubuntu, Google Play, Microsoft Store và Apple Store. Nó bao gồm 1.200 nhắc nhiệm vụ phần mềm đã được phân loại cẩn thận thành 5 lĩnh vực chính: Giáo dục, Công việc, Cuộc sống, Trò chơi và Sáng tạo. Tất cả các lĩnh vực này được chia thành 40 danh mục con, và mỗi danh mục con chứa 30 nhắc nhiệm vụ duy nhất.

**Độ đo** Đánh giá phần mềm cũng là một nhiệm vụ thách thức, đặc biệt khi cố gắng đánh giá nó ở mức độ toàn diện. Dưới hạn chế hiện tại về nguồn lực benchmark khan hiếm, các độ đo tạo mã hướng chức năng truyền thống (ví dụ, pass@k), không thể chuyển đổi liền mạch sang đánh giá toàn diện của toàn bộ hệ thống phần mềm. Lý do chính cho điều này là việc phát triển các trường hợp kiểm thử thủ công hoặc tự động cho các loại phần mềm khác nhau thường không thực tế, đặc biệt là những phần mềm liên quan đến giao diện phức tạp, tương tác người dùng thường xuyên hoặc phản hồi không xác định. Như một chiến lược ban đầu, chúng tôi áp dụng ba chiều cơ bản và khách quan phản ánh các khía cạnh khác nhau của ảo giác lập trình để đánh giá phần mềm được tạo bởi tác nhân, sau đó tích hợp chúng để tạo điều kiện cho đánh giá toàn diện hơn:

• **Độ hoàn chỉnh** đo lường khả năng của phần mềm trong việc hoàn thành mã trong phát triển phần mềm, được định lượng là tỷ lệ phần trăm phần mềm không có bất kỳ đoạn mã "giữ chỗ" nào. Điểm số cao hơn cho biết xác suất hoàn thành tự động cao hơn.

• **Khả năng thực thi** đánh giá khả năng của phần mềm chạy chính xác trong môi trường biên dịch, được định lượng là tỷ lệ phần trăm phần mềm biên dịch thành công và có thể chạy trực tiếp. Điểm số cao hơn cho biết xác suất thực thi thành công cao hơn.

• **Tính nhất quán** đo lường mức độ phù hợp của mã phần mềm được tạo ra với mô tả yêu cầu gốc, được định lượng là khoảng cách cosine giữa các embedding ngữ nghĩa của yêu cầu văn bản và mã phần mềm được tạo ra. Điểm số cao hơn cho biết mức độ nhất quán lớn hơn với yêu cầu.

• **Chất lượng** là một độ đo toàn diện tích hợp các yếu tố khác nhau để đánh giá chất lượng tổng thể của phần mềm, được định lượng bằng cách nhân độ hoàn chỉnh, khả năng thực thi và tính nhất quán. Điểm chất lượng cao hơn gợi ý sự hài lòng tổng thể cao hơn với phần mềm được tạo ra, ngụ ý nhu cầu can thiệp thủ công thêm thấp hơn.

**Chi tiết triển khai** Chúng tôi chia phát triển phần mềm thành 5 tác vụ con trong 3 giai đoạn, phân công các vai trò cụ thể như CEO, CTO, lập trình viên, người đánh giá và người kiểm thử. Một tác vụ con sẽ kết thúc và có kết luận sau hai lần sửa đổi mã không thay đổi hoặc sau 10 vòng giao tiếp. Trong quá trình hoàn thiện mã, đánh giá và kiểm thử, khử ảo giác giao tiếp được kích hoạt. Để dễ dàng xác định giải pháp, trợ lý bắt đầu phản hồi với "<SOLUTION>" khi đạt được sự đồng thuận. Chúng tôi sử dụng ChatGPT-3.5 với nhiệt độ 0.2 và tích hợp Python-3.11.4 để phản hồi. Tất cả các đường cơ sở trong đánh giá chia sẻ cùng các siêu tham số và cài đặt để đảm bảo công bằng.

### 4.1 Hiệu suất tổng thể

Như được minh họa trong Bảng 1, ChatDev vượt trội hơn tất cả các phương pháp đường cơ sở trên tất cả các độ đo, cho thấy biên độ cải thiện đáng kể. Đầu tiên, sự cải thiện của ChatDev và MetaGPT so với GPT-Engineer chứng minh rằng các nhiệm vụ phức tạp khó giải quyết trong giải pháp một bước. Do đó, việc phân tách rõ ràng vấn đề khó thành nhiều tác vụ con nhỏ hơn, dễ quản lý hơn tăng cường hiệu quả của việc hoàn thành nhiệm vụ. Ngoài ra, so với MetaGPT, ChatDev tăng đáng kể Chất lượng từ 0.1523 lên 0.3953. Tiến bộ này phần lớn được quy cho các tác nhân sử dụng phương pháp giao tiếp hợp tác, liên quan đến việc tự động đề xuất và liên tục tinh chỉnh mã nguồn thông qua sự kết hợp của ngôn ngữ tự nhiên và lập trình, trái ngược với việc chỉ đưa ra phản hồi dựa trên các hướng dẫn được định trước bởi con người. Các tác nhân giao tiếp hướng dẫn mỗi tác vụ con hướng tới các giải pháp tích hợp và tự động, hiệu quả vượt qua các hạn chế thường liên quan đến các quy tắc tối ưu hóa được thiết lập thủ công, và cung cấp một framework linh hoạt và thích ứng hơn cho giải quyết vấn đề.

Để hiểu rõ hơn sở thích của người dùng trong các cài đặt thực tế, chúng tôi sử dụng cài đặt được áp dụng bởi Li et al. (2023a), trong đó các giải pháp được tạo bởi tác nhân được so sánh theo cặp bởi cả người tham gia con người và mô hình GPT-4 phổ biến để xác định giải pháp được ưa thích. Bảng 2 cho thấy ChatDev nhất quán vượt trội hơn các đường cơ sở khác, với tỷ lệ thắng trung bình cao hơn trong cả đánh giá GPT-4 và con người.

Hơn nữa, thống kê phần mềm được trình bày trong Bảng 3 cho thấy mô hình đa tác nhân, mặc dù chậm hơn và tiêu tốn nhiều token hơn phương pháp tác nhân đơn, tạo ra số lượng file mã lớn hơn và codebase lớn hơn, điều này có thể tăng cường chức năng và tính toàn vẹn của phần mềm. Phân tích các cuộc đối thoại của các tác nhân gợi ý rằng phương pháp giao tiếp đa tác nhân thường dẫn các tác nhân tự động cung cấp các cải tiến chức năng (ví dụ, tạo GUI hoặc tăng độ khó của trò chơi), do đó có thể dẫn đến việc kết hợp các tính năng có lợi không được chỉ định rõ ràng trong yêu cầu. Xem xét tất cả các yếu tố này, chúng tôi cho rằng các đặc tính cơ bản của phát triển phần mềm đa tác nhân có ý nghĩa lớn hơn, vượt qua các mối quan tâm ngắn hạn như thời gian và chi phí kinh tế trong bối cảnh hiện tại.

### 4.2 Nghiên cứu loại bỏ

Phần này kiểm tra các thành phần hoặc cơ chế chính trong framework hợp tác đa tác nhân của chúng tôi bằng cách loại bỏ các giai đoạn cụ thể trong chuỗi chat, khử ảo giác giao tiếp, hoặc các vai trò được phân công cho tất cả các tác nhân trong nhắc hệ thống của họ. Hình 4 cho thấy giai đoạn hoàn thiện mã tăng cường Độ hoàn chỉnh, với kiểm thử quan trọng cho Khả năng thực thi. Chất lượng tăng đều với mỗi bước, gợi ý rằng tối ưu hóa phát triển phần mềm được đạt được từ từ thông qua giao tiếp đa giai đoạn giữa các tác nhân thông minh. Trong khi đó, loại bỏ khử ảo giác giao tiếp dẫn đến giảm trên tất cả các độ đo, cho thấy hiệu quả của nó trong việc giải quyết ảo giác lập trình. Thú vị nhất, tác động lớn nhất đến hiệu suất xảy ra khi các vai trò của tất cả các tác nhân được loại bỏ khỏi nhắc hệ thống của họ. Phân tích đối thoại chi tiết cho thấy việc phân công vai trò "ưa thiết kế GUI" cho lập trình viên dẫn đến mã nguồn được tạo ra với các triển khai GUI liên quan; khi không có chỉ dẫn vai trò như vậy, nó mặc định triển khai các chương trình chỉ dòng lệnh không thân thiện. Tương tự, việc phân công các vai trò như "người đánh giá cẩn thận để phát hiện lỗi" tăng cường cơ hội phát hiện lỗ hổng mã; không có vai trò như vậy, phản hồi có xu hướng ở mức cao, dẫn đến các điều chỉnh hạn chế bởi lập trình viên. Phát hiện này nhấn mạnh tầm quan trọng của việc phân công vai trò trong việc gợi ý phản hồi từ LLM, nhấn mạnh ảnh hưởng đáng kể của hợp tác đa tác nhân đến chất lượng phần mềm.

### 4.3 Phân tích giao tiếp

Mô hình phát triển phần mềm được điều khiển bởi tác nhân của chúng tôi thúc đẩy các tác nhân hợp tác thông qua giao tiếp hiệu quả để tối ưu hóa giải pháp tự động. Các giai đoạn trong chuỗi chat có các mức độ tham gia khác nhau trong ngôn ngữ tự nhiên và lập trình. Chúng tôi hiện phân tích nội dung giao tiếp của họ để hiểu các hiệu ứng ngôn ngữ.

Hình 3 mô tả một bảng phân tích giao tiếp, với ngôn ngữ tự nhiên ở 57.20%. Trong giai đoạn ngôn ngữ tự nhiên (tức là thiết kế), giao tiếp ngôn ngữ tự nhiên đóng vai trò quan trọng trong thiết kế hệ thống toàn diện, với các tác nhân tự động thảo luận và thiết kế các khía cạnh như người dùng mục tiêu, quản lý dữ liệu và giao diện người dùng. Các giai đoạn sau thiết kế cho thấy sự kết hợp cân bằng của các hoạt động lập trình, hoàn thiện mã và kiểm thử, với hầu hết giao tiếp xảy ra trong đánh giá mã. Xu hướng này là do các tác nhân tự đánh giá và sửa mã liên tục thúc đẩy phát triển phần mềm; nếu không, tiến trình dừng lại khi các cập nhật liên tiếp không cho thấy thay đổi đáng kể, dẫn đến giảm tự nhiên trong giao tiếp đánh giá mã.

Chúng tôi khám phá các thuộc tính của động lực debug tĩnh trong đánh giá mã phát sinh từ giao tiếp giữa người đánh giá và lập trình viên, như được mô tả trong Hình 4. Dữ liệu tiết lộ rằng trong giai đoạn đánh giá, người đánh giá có thể phát hiện các vấn đề khác nhau thông qua tương tác ngôn ngữ. Sự can thiệp của lập trình viên có thể chuyển đổi một số vấn đề thành những vấn đề khác hoặc một trạng thái không cần gợi ý thêm; tỷ lệ tăng của trường hợp sau cho thấy tối ưu hóa phần mềm thành công. Đặc biệt, vấn đề "Method Not Implemented" phổ biến nhất trong giao tiếp giữa người đánh giá và lập trình viên trong đánh giá mã, chiếm 34.85% thảo luận. Vấn đề này thường phát sinh từ yêu cầu văn bản không rõ ràng và việc sử dụng thẻ "placeholder" trong mã Python, đòi hỏi điều chỉnh thủ công bổ sung. Hơn nữa, vấn đề "Module Not Imported" thường phát sinh do việc tạo mã bỏ qua các chi tiết quan trọng. Ngoài các vấn đề phổ biến, người đánh giá thường tập trung vào tăng cường độ bền vững của mã bằng cách xác định các ngoại lệ hiếm, lớp không sử dụng hoặc vòng lặp vô tận tiềm ẩn.

Tương tự, chúng tôi phân tích giao tiếp tester-programmer trong giai đoạn kiểm thử, minh họa động lực debug động trong các tương tác đa vòng của họ với phản hồi trình biên dịch, như được mô tả trong Hình 5. Khả năng biên dịch thành công ở mỗi bước thường cao hơn việc gặp lỗi, với hầu hết lỗi vẫn tồn tại và xác suất thấp hơn chuyển đổi thành các lỗi khác. Lỗi thường xuyên nhất là "ModuleNotFound" (45.76%), tiếp theo là "NameError" và "ImportError" (mỗi loại ở 15.25%). Quan sát này nhấn mạnh xu hướng của mô hình bỏ qua các yếu tố cơ bản như câu lệnh "import", nhấn mạnh khó khăn của nó trong việc quản lý các chi tiết phức tạp trong quá trình tạo mã. Bên cạnh đó, tester cũng phát hiện các lỗi hiếm hơn như GUI được khởi tạo không đúng cách, lời gọi phương thức không chính xác, phụ thuộc file thiếu và module không sử dụng. Cơ chế khử ảo giác giao tiếp hiệu quả giải quyết một số lỗi nhất định, thường dẫn đến "biên dịch thành công" sau các thay đổi mã. Có một cơ hội thấp đáng kể để trở lại trạng thái lỗi từ biên dịch thành công. Theo thời gian, quá trình giao tiếp đa vòng thống kê cho thấy sự giảm nhất quán của lỗi, di chuyển đều hướng tới thực thi phần mềm thành công.

## 5. Kết luận

Chúng tôi đã giới thiệu ChatDev, một framework hợp tác đa tác nhân sáng tạo cho phát triển phần mềm sử dụng nhiều tác nhân được hỗ trợ bởi LLM để tích hợp các giai đoạn phân mảnh của mô hình thác nước thành một hệ thống giao tiếp gắn kết. Nó có chuỗi chat tổ chức mục tiêu giao tiếp và khử ảo giác để giải quyết ảo giác lập trình. Kết quả chứng minh tính ưu việt của nó và làm nổi bật lợi ích của giao tiếp đa vòng trong tối ưu hóa phần mềm. Chúng tôi hướng tới việc các insight này thúc đẩy các tác nhân LLM hướng tới tính tự động tăng cường và làm sáng tỏ những tác động sâu sắc của "ngôn ngữ" và vai trò trao quyền của nó trên một phổ ứng dụng thậm chí rộng lớn hơn.

## 6. Hạn chế

Nghiên cứu của chúng tôi khám phá tiềm năng của các tác nhân tự động hợp tác trong phát triển phần mềm, nhưng một số hạn chế và rủi ro nhất định phải được các nhà nghiên cứu và người thực hành xem xét. Đầu tiên, khả năng của các tác nhân tự động trong sản xuất phần mềm có thể bị đánh giá quá cao. Mặc dù họ tăng cường chất lượng phát triển, các tác nhân thường triển khai logic đơn giản, dẫn đến mật độ thông tin thấp. Không có yêu cầu rõ ràng, chi tiết, các tác nhân gặp khó khăn trong việc nắm bắt ý tưởng nhiệm vụ. Ví dụ, hướng dẫn mơ hồ trong việc phát triển trò chơi Snake dẫn đến các biểu diễn cơ bản; trong hệ thống quản lý thông tin, các tác nhân có thể lấy các placeholder key-value tĩnh thay vì cơ sở dữ liệu bên ngoài. Do đó, việc định nghĩa rõ ràng các yêu cầu phần mềm chi tiết là quan trọng. Hiện tại, những công nghệ này phù hợp hơn cho các hệ thống nguyên mẫu thay vì các ứng dụng thực tế phức tạp. Thứ hai, không giống như tạo mã cấp độ chức năng truyền thống, việc tự động hóa đánh giá phần mềm đa dụng là rất phức tạp. Mặc dù một số nỗ lực đã tập trung vào Chi phí sửa đổi con người (Hong et al., 2023), việc xác minh thủ công cho các bộ dữ liệu lớn là không thực tế. Bài báo của chúng tôi nhấn mạnh tính hoàn chỉnh, khả năng thực thi, tính nhất quán và chất lượng tổng thể, nhưng nghiên cứu tương lai nên xem xét các yếu tố bổ sung như chức năng, độ bền vững, an toàn và thân thiện với người dùng. Thứ ba, so với các cách tiếp cận tác nhân đơn, nhiều tác nhân đòi hỏi nhiều token và thời gian hơn, tăng nhu cầu tính toán và tác động môi trường. Nghiên cứu tương lai nên hướng tới tăng cường khả năng tác nhân với ít tương tác hơn. Mặc dù có những hạn chế này, chúng tôi tin rằng việc thu hút đối tượng rộng hơn, thành thạo kỹ thuật có thể mở khóa các hướng tiềm năng bổ sung trong hợp tác đa tác nhân được hỗ trợ bởi LLM.

## Lời cảm ơn

Công trình này được hỗ trợ bởi Chương trình R&D Quốc gia chính (Số 2022ZD0116312), Chương trình Fellowship Tiến sĩ sau đại học của CPSF dưới Số Grant GZB20230348, và Chương trình Nghiên cứu Tập trung Tencent Rhino-Bird.

## Tài liệu tham khảo

[Phần tài liệu tham khảo được giữ nguyên như trong bản gốc]
