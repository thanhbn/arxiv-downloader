# Tổng hợp chương trình hướng kiểu cho API RESTful
Zheng Guo
UC San Diego
USA
zhg069@ucsd.eduDavid Cao
UC San Diego
USA
dmcao@ucsd.eduDavin Tjong
UC San Diego
USA
dtjong@ucsd.edu
Jean Yang
Akita Software
USA
jean@akitasoftware.comCole Schlesinger
Akita Software
USA
cole@akitasoftware.comNadia Polikarpova
UC San Diego
USA
npolikarpova@ucsd.edu

Tóm tắt
Với sự phát triển của kiến trúc phần mềm dưới dạng dịch vụ và microservice, API RESTful hiện đã trở nên phổ biến trong các ứng dụng di động và web. Một dịch vụ có thể có hàng chục hoặc hàng trăm phương thức API, khiến việc tìm ra sự kết hợp đúng các phương thức để giải quyết nhiệm vụ của họ trở thành thách thức đối với các lập trình viên.

Chúng tôi trình bày APIphany, một bộ tổng hợp dựa trên thành phần cho các chương trình kết hợp các cuộc gọi đến API RESTful. Đổi mới chính đằng sau APIphany là việc sử dụng các kiểu ngữ nghĩa chính xác, cả để chỉ định ý định của người dùng và để định hướng tìm kiếm.

APIphany đóng góp ba cơ chế mới để vượt qua các thách thức trong việc thích ứng tổng hợp dựa trên thành phần với miền REST: (1) một thuật toán suy luận kiểu để bổ sung thông số kỹ thuật REST với các kiểu ngữ nghĩa; (2) một kỹ thuật tổng hợp hiệu quả cho việc "xử lý" dữ liệu bán cấu trúc, điều thường được yêu cầu khi làm việc với API RESTful; và (3) một hình thức mới của thực thi mô phỏng để tránh thực thi các cuộc gọi API trong quá trình tổng hợp. Chúng tôi đánh giá APIphany trên ba API thực tế và 32 nhiệm vụ được trích xuất từ các kho lưu trữ GitHub và StackOverflow. Trong các thí nghiệm của chúng tôi, APIphany tìm được giải pháp đúng cho 29 nhiệm vụ, với 23 trong số đó được báo cáo trong mười kết quả tổng hợp hàng đầu.

Khái niệm CCS: •Phần mềm và kỹ thuật phần mềm →Lập trình tự động.

Từ khóa: Tổng hợp chương trình, API RESTful, Suy luận kiểu

Định dạng tham chiếu ACM:
Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, và Nadia Polikarpova. 2022. Tổng hợp chương trình hướng kiểu cho API RESTful. Trong Kỷ yếu Hội nghị quốc tế lần thứ 43 của ACM SIGPLAN về Thiết kế và Triển khai ngôn ngữ lập trình (PLDI '22), 13–17 tháng 6, 2022, San Diego, CA, USA. ACM, New York, NY, USA, 27 trang. https://doi.org/10.1145/3519939.3523450

1 Giới thiệu
Phần mềm dưới dạng dịch vụ đã nổi lên như một phương tiện được sử dụng rộng rãi để các nhà phát triển tận dụng phần mềm của bên thứ ba. Các nhà phát triển có thể gửi yêu cầu đến Stripe để xử lý thanh toán hoặc tích hợp với Slack để xuất bản thông báo, tất cả trong khi sử dụng các nhà cung cấp đám mây để cung cấp nhiều hình thức lưu trữ và tính toán. Theo các khảo sát ngành gần đây, hơn 80% dịch vụ của các bên trả lời cung cấp API RESTful [26,30], và những API này rất phong phú. Ví dụ, Slack có 174 phương thức API tính đến phiên bản 1.5.0. Amazon Web Services cung cấp hơn hai trăm sản phẩm và dịch vụ, mỗi cái có hàng chục hoặc hàng trăm phương thức API. Ngay cả với tài liệu toàn diện—điều không hề được đảm bảo—việc sử dụng một dịch vụ mới có thể là một đề xuất đáng sợ.

Ví dụ, hãy xem xét một câu hỏi được đặt trên StackOverflow về Slack API: Làm thế nào để tôi lấy tất cả email thành viên từ một kênh Slack với tên cho trước? Câu trả lời phức tạp một cách đáng ngạc nhiên:

1. Trước tiên, gọi conversations_list để lấy mảng tất cả các đối tượng kênh, sau đó tìm kiếm một đối tượng kênh với tên cho trước và lấy ID của nó;
2. Tiếp theo, gọi conversations_members trên ID kênh để lấy tất cả ID người dùng của các thành viên;
3. Cuối cùng, với mỗi ID người dùng, gọi users_info để lấy một đối tượng người dùng u, và sau đó truy cập email của người dùng qua u.profile.email.

Để đưa ra giải pháp này, người ta phải quen thuộc với các đối tượng kênh, đối tượng người dùng, và ba phương thức API khác nhau.

Tổng hợp chương trình dựa trên thành phần [8,14,18,21] đã được sử dụng trước đây để giúp các lập trình viên điều hướng API trong Java, Scala, và Haskell. Các bộ tổng hợp dựa trên thành phần nhận đầu vào là một chữ ký kiểu và (trong hầu hết các trường hợp) một tập hợp các ví dụ đầu vào-đầu ra, và trả về một danh sách các đoạn mã chương trình kết hợp các cuộc gọi API và có kiểu mong muốn cũng như hành vi đầu vào-đầu ra. Đây là một cách tiếp cận mạnh mẽ để điều hướng API, bởi vì nó cho phép các nhà phát triển bắt đầu với thông tin dễ có—các kiểu đầu vào họ có và đầu ra họ mong muốn—và không yêu cầu kiến thức về phương thức API nào cần áp dụng.

Thách thức. Thật không may, có ba thách thức đáng kể trong việc áp dụng tổng hợp dựa trên thành phần cho API RESTful. Thứ nhất, tổng hợp dựa trên thành phần dựa vào các kiểu cả để biểu đạt ý định của người dùng và để tìm kiếm hiệu quả, nhưng các kiểu trong API REST khá nông. Ví dụ, trong đặc tả Slack API, cả tên kênh và email đều có kiểu String, vì vậy ví dụ của chúng tôi, chuyển đổi tên kênh thành một mảng email, sẽ có chữ ký kiểu rất không chính xác String→[String].

Thứ hai, API RESTful thường truyền dữ liệu bán cấu trúc, tức là mảng các đối tượng, có thể chứa các đối tượng và mảng lồng nhau. Kết quả là, việc sử dụng một API thường không đơn giản như việc nối tiếp một số cuộc gọi phương thức; thay vào đó, các cuộc gọi phải được xen kẽ với các hoạt động "xử lý dữ liệu" như phép chiếu, map, và filter. Các hoạt động xử lý dữ liệu này là thách thức đối với tổng hợp dựa trên thành phần: chúng cực kỳ chung chung, và do đó mở rộng đáng kể không gian tìm kiếm.

Cuối cùng, để bù đắp cho tính mơ hồ vốn có của các kiểu, tổng hợp dựa trên thành phần thường dựa vào việc thực thi các đoạn mã chương trình ứng viên và khớp chúng với các ví dụ đầu vào-đầu ra do người dùng cung cấp. Trong môi trường phần mềm dưới dạng dịch vụ, điều này hoàn toàn không khả thi: không chỉ người dùng thường không biết về trạng thái nội bộ của dịch vụ và do đó không thể cung cấp các ví dụ chính xác, mà việc thực thi các cuộc gọi API trong quá trình tổng hợp cũng có thể cực kỳ tốn kém do giới hạn tốc độ do các dịch vụ áp đặt và, quan trọng hơn, có thể có tác dụng phụ không thể phục hồi, như xóa tài khoản hoặc xuất bản tin nhắn.

APIphany: tổng hợp với các kiểu ngữ nghĩa. Hiểu biết cốt lõi của chúng tôi là các đặc tả dựa trên kiểu thực sự phù hợp với API REST, miễn là các kiểu chi tiết hơn. Trong ví dụ của chúng tôi, nếu Slack API có các kiểu riêng cho Channel.name và Profile.email, lập trình viên có thể chỉ định ý định của họ là kiểu Channel.name→[Profile.email]. Mặc dù đặc tả này vẫn có phần mơ hồ, trực quan nó có đủ thông tin để thu hẹp kết quả tổng hợp xuống một số có thể quản lý sao cho lập trình viên có thể kiểm tra thủ công các giải pháp còn lại. Chúng tôi gọi những kiểu chi tiết như vậy là các kiểu ngữ nghĩa.

Trong bài báo này, chúng tôi trình bày APIphany, một bộ tổng hợp dựa trên thành phần cho API REST được hướng dẫn bởi các kiểu ngữ nghĩa. Hình 1 cho thấy tổng quan cấp cao về cách tiếp cận của chúng tôi, được cấu trúc thành hai giai đoạn: (1) giai đoạn phân tích suy luận các chú thích kiểu ngữ nghĩa cho một API cho trước; (2) giai đoạn tổng hợp sử dụng các chú thích kiểu này để thực hiện tổng hợp dựa trên thành phần. Đối với Slack API, APIphany có thể suy luận, ví dụ, rằng phương thức conversations_members có kiểu ngữ nghĩa Channel.id→[User.id]. Tại thời điểm tổng hợp, với truy vấn kiểu Channel.name→[Profile.email], APIphany trả về một danh sách được xếp hạng các chương trình có kiểu này, trong đó giải pháp mong muốn (được hiển thị trong Hình 2) xuất hiện trong mười kết quả hàng đầu. Đầu ra của APIphany được biểu đạt trong một DSL nhỏ gọn lấy cảm hứng từ ký hiệu do monadic của Haskell và for-comprehensions của Scala, tuy nhiên, có thể dễ dàng được dịch sang ngôn ngữ lựa chọn của người dùng để giao tiếp với API.

Đóng góp. Chúng tôi trình bày thiết kế, triển khai, và đánh giá của APIphany, bao gồm:

1. Khai thác kiểu (Mục 4), một kỹ thuật suy luận các kiểu ngữ nghĩa từ một tập hợp các nhân chứng (các cuộc gọi phương thức API được quan sát). Nhân chứng có thể được tạo ra trong sandbox hoặc bằng cách khai thác lưu lượng sản xuất trực tiếp; trong cả hai trường hợp, chúng được thu thập trước, một lần cho mỗi API, điều này tránh gây ra tác dụng phụ trong quá trình tổng hợp.

2. Tổng hợp hiệu quả các hoạt động xử lý cho dữ liệu bán cấu trúc thông qua tìm kiếm bỏ qua mảng (Mục 5), bỏ qua các hoạt động mảng thách thức trong quá trình tìm kiếm, và khôi phục chúng sau đó thông qua nâng cấp hướng kiểu.

3. Xếp hạng kết quả tổng hợp với sự trợ giúp của thực thi hồi cứu (Mục 6), một loại thực thi mô phỏng sử dụng các nhân chứng đã thu thập trước đó. Thực thi hồi cứu giúp APIphany loại bỏ các chương trình không thú vị (ví dụ các chương trình luôn trả về mảng rỗng), giảm số lượng kết quả tổng hợp mà người dùng phải kiểm tra để tìm ra giải pháp mong đợi của họ.

Chúng tôi đánh giá APIphany trên ba API thực tế, và 32 nhiệm vụ được trích xuất từ các kho lưu trữ GitHub và StackOverflow (Mục 7). Đánh giá của chúng tôi cho thấy APIphany có thể tìm giải pháp cho phần lớn các nhiệm vụ (29/32) trong vòng 150 giây. Hơn nữa, các kiểu ngữ nghĩa là rất quan trọng đối với hiệu quả của nó: không có khai thác kiểu, APIphany chỉ có thể giải quyết bốn nhiệm vụ. Cuối cùng, xếp hạng cải thiện đáng kể chất lượng của các giải pháp được báo cáo, tăng số lượng giải pháp đúng xuất hiện trong mười kết quả hàng đầu từ 12/29 lên 23/29.

2 APIphany qua Ví dụ
Trong phần này, chúng tôi sử dụng nhiệm vụ lấy tất cả email thành viên trong một kênh Slack làm ví dụ chạy để minh họa quy trình làm việc APIphany được mô tả trong Hình 1.

2.1 Phân tích API qua Ví dụ
Phân tích API được thực hiện một lần cho mỗi API. Nó nhận đầu vào là một đặc tả theo định dạng OpenAPI phổ biến và một tập hợp nhân chứng (các cuộc gọi phương thức API thành công); nó tạo ra một đặc tả được chú thích với các kiểu ngữ nghĩa. Đặc tả OpenAPI có sẵn công khai cho hầu hết các API phổ biến. Nhân chứng có thể được tạo ra theo một số cách, ví dụ, bằng cách chạy một bộ kiểm tra tích hợp trong sandbox hoặc bằng cách lắng nghe một cách thụ động lưu lượng API sản xuất. Chúng tôi hình dung việc thu thập nhân chứng và phân tích API được thực hiện bởi người duy trì API (hoặc một bên quan tâm khác), không phải bởi người dùng thường xuyên của bộ tổng hợp APIphany.

Đặc tả OpenAPI. Hình 3 cho thấy một đoạn của đặc tả OpenAPI được cung cấp bởi Slack. Một đặc tả OpenAPI bao gồm các định nghĩa đối tượng và định nghĩa phương thức. Chúng tôi hiển thị các định nghĩa của ba đối tượng, user, profile và channel, và hai phương thức, users_info và conversations_list, liên quan đến ví dụ của chúng tôi.

Như bạn có thể thấy, đặc tả cung cấp thông tin kiểu chính xác cho một số vị trí: ví dụ, phản hồi của users_info rõ ràng có kiểu User (nó được chú thích với một tham chiếu đến định nghĩa đối tượng tương ứng). Tuy nhiên, phần lớn các vị trí, như trường user.id hoặc tham số của users_info, chỉ đơn giản được chú thích với String, điều này không hữu ích lắm cho mục đích tổng hợp hướng kiểu. Mục tiêu của chúng tôi là thay thế các chú thích String này bằng các kiểu chi tiết hơn.

Khai thác kiểu từ nhân chứng. Để làm điều này, chúng tôi xây dựng trên một thuật toán được đề xuất lần đầu trong [1] suy luận các kiểu bằng cách khai thác chúng từ các dấu vết thực thi, dựa trên hiểu biết rằng các giá trị bằng nhau được quan sát tại các vị trí khác nhau có khả năng có cùng kiểu. Cụ thể hơn, thuật toán khai thác kiểu của chúng tôi bắt đầu bằng cách gán một kiểu ngữ nghĩa duy nhất cho mỗi vị trí String và sau đó hợp nhất các vị trí chia sẻ một giá trị ở bất kỳ đâu trong tập nhân chứng. Như một minh họa, hãy xem xét Hình 4, liệt kê hai nhân chứng cho các phương thức API từ ví dụ chạy của chúng tôi.

Trong tập nhân chứng này, chúng tôi quan sát cùng một giá trị "UJ5RHEG4S" trong ba vị trí: (1) tham số của users_info, (2) trường id của một đối tượng User (chúng tôi biết từ đặc tả rằng users_info trả về một User), và (3) trường creator của một đối tượng Channel (chúng tôi biết từ đặc tả rằng conversations_list trả về một mảng Channel). Do đó chúng tôi hợp nhất tất cả ba vị trí thành cùng một kiểu ngữ nghĩa. Cho mục đích trình bày, chúng tôi gán tên User.id cho kiểu này, được lấy từ vị trí (2) ở trên. Việc lựa chọn tên không quan trọng, tuy nhiên: người dùng có thể tự do tham chiếu kiểu ngữ nghĩa này thông qua bất kỳ vị trí đại diện nào của nó; ví dụ, Channel.creator cũng biểu thị cùng một kiểu.

2.2 Tổng hợp Chương trình qua Ví dụ
Giai đoạn tổng hợp chương trình của APIphany được thiết kế để được sử dụng bởi các lập trình viên thường xuyên, bất cứ khi nào họ cần trợ giúp thực hiện một nhiệm vụ với một trong các API được hỗ trợ. Lập trình viên truy vấn APIphany với một chữ ký kiểu được xây dựng từ các kiểu ngữ nghĩa. Mặc dù giao diện người dùng để xây dựng truy vấn nằm ngoài phạm vi của bài báo này, chúng tôi hình dung lập trình viên duyệt các định nghĩa đối tượng và chọn các trường liên quan làm kiểu ngữ nghĩa. Đối với ví dụ chạy của chúng tôi, lập trình viên biết rằng họ cần đi từ tên kênh đến một mảng email người dùng; họ có thể đầu tiên xem qua định nghĩa đối tượng kênh và tìm trường name; sau đó họ có thể tìm kiếm toàn cục cho một trường có tên email và tìm thấy nó bên trong đối tượng profile; do đó họ quyết định truy vấn kiểu Channel.name→[Profile.email].

Bản thân giai đoạn tổng hợp chương trình bao gồm hai bước, bắt đầu với một bước tìm kiếm chương trình để tạo ra một danh sách các chương trình ứng viên với một kiểu cho trước, tiếp theo là một bước xếp hạng để xác định các ứng viên hứa hẹn (được mô tả trong Mục 2.3).

Thách thức: thành phần gặp luồng điều khiển. Cho truy vấn kiểu Channel.name→[Profile.email], APIphany sẽ liệt kê tất cả các chương trình có kiểu này như thế nào? Nhiệm vụ này đặt ra thách thức cho các kỹ thuật tổng hợp hiện có bởi vì các chương trình ứng viên của chúng tôi có cả một thư viện thành phần lớn để chọn từ—từ hàng chục đến hàng trăm phương thức—và luồng điều khiển không tầm thường—ví dụ giải pháp cho ví dụ chạy của chúng tôi phải lặp qua các thành viên của một kênh. Một dòng công việc trước đây mở rộng đến thư viện thành phần lớn là tìm kiếm dựa trên đồ thị sử dụng mạng chuyển đổi kiểu (TTN) [8,12]; thật không may, cách tiếp cận này chỉ có thể tạo ra chuỗi các cuộc gọi phương thức, và không hỗ trợ vòng lặp.

DSL APIphany. Chúng tôi quan sát rằng các vòng lặp chúng tôi cần để thao tác dữ liệu bán cấu trúc được hạn chế để lặp qua các mảng (có thể lồng nhau) của các đối tượng. Để nắm bắt lớp chương trình hạn chế này, chúng tôi đã thiết kế một DSL lấy cảm hứng từ for-comprehensions của Scala, ký hiệu do monadic của Haskell, và LINQ [22]. Giải pháp cho ví dụ chạy của chúng tôi trong DSL này được đưa ra trong Hình 2. Trong ngôn ngữ này, việc lặp qua một mảng được biểu đạt bằng cách sử dụng hoạt động bind monadic (được viết ←). Ví dụ, bind thứ hai trong Hình 2 có tác dụng thực hiện tính toán tiếp theo cho mỗi phần tử uid của mảng được trả về trong dòng 4:

4uid←conversations_members(channel=c.id);
5letu = users_info(user=uid);
6returnu.profile.email

Tìm kiếm bỏ qua mảng. Ý tưởng chính đằng sau tìm kiếm của APIphany là mặc dù chúng ta không thể trực tiếp tổng hợp chương trình trên bằng các kỹ thuật dựa trên TTN hiện có, chúng ta có thể tổng hợp một phiên bản bỏ qua mảng của chương trình này, trong đó chúng ta giả vờ rằng conversations_members trả về một User.id duy nhất thay vì một mảng, và do đó chúng ta có thể đơn giản nối tiếp hai cuộc gọi phương thức, không có binding monadic:

4letuid = conversations_members(channel=c.id);
5letu = users_info(user=uid);
6u.profile.email

Để chuyển đổi một chương trình bỏ qua mảng thành giải pháp cuối cùng, APIphany nâng nó thành một comprehension bằng cách thay thế mỗi let binding gây ra lỗi kiểu bằng một bind monadic. Trong ví dụ của chúng tôi, let trong dòng 4 gây ra lỗi kiểu (bởi vì conversations_members trả về [User.id], trong khi users_info mong đợi một User.id duy nhất), trong khi let trong dòng 5 thì không (vì users_info trả về một User duy nhất); do đó việc nâng thay thế let-binding đầu tiên bằng ← nhưng không phải cái thứ hai.

2.3 Xếp hạng thông qua Thực thi Hồi cứu
Mặc dù các kiểu ngữ nghĩa ít mơ hồ hơn các kiểu nguyên thủy để biểu đạt ý định của người dùng, chúng vẫn không đủ chính xác để xác định chính xác chương trình mong muốn. Ví dụ, bộ tổng hợp của chúng tôi tạo ra hơn 1000 ứng viên cho chữ ký kiểu Channel.name→[Profile.email]; rõ ràng, việc người dùng kiểm tra thủ công tất cả chúng là không khả thi. Do đó, APIphany phải có khả năng xếp hạng các ứng viên để hiển thị cho người dùng một số lượng nhỏ các giải pháp có khả năng.

May mắn thay, hầu hết trong số 1000 ứng viên đều dễ loại bỏ bởi vì chúng tạo ra kết quả không thú vị. Hãy xem xét hai ứng viên được mô tả trong Hình 5, khác với giải pháp mong muốn của chúng tôi (Hình 2) ở các đoạn được tô sáng: chương trình đầu tiên trả về email của người tạo kênh (thay vì tất cả thành viên của nó), và chương trình thứ hai lấy danh sách kênh từ conversations_open, được dành cho việc mở kênh tin nhắn trực tiếp. Hóa ra chương trình thứ hai luôn thất bại tại thời gian chạy, bởi vì một cuộc gọi thành công đến conversations_open yêu cầu cung cấp chính xác một trong hai đối số tùy chọn (một ID kênh hoặc một danh sách người dùng). Chương trình đầu tiên thực thi thành công, nhưng nó luôn trả về một email duy nhất, trong khi người dùng yêu cầu một mảng email.

Vì những lý do này, cả hai chương trình này đều ít có khả năng là giải pháp dự định hơn chương trình trong Hình 2, chương trình thành công trả về nhiều email ít nhất đôi khi.

Một ý tưởng tự nhiên là kiểm tra tất cả các chương trình ứng viên trên các đầu vào ngẫu nhiên và xếp hạng chúng dựa trên kết quả chúng tạo ra. Thật không may, như chúng tôi đã gợi ý ở trên, có một số rào cản đối với việc thực thi có hệ thống nhiều chương trình ứng viên thực hiện cuộc gọi đến API REST. Thứ nhất, hầu hết API REST đặt giới hạn tốc độ về tần suất người dùng có thể thực hiện cuộc gọi phương thức hoặc số lượng cuộc gọi người dùng có thể thực hiện trong một ngày. Thứ hai, nhiều phương thức API REST có tác dụng phụ. Không giống như một tệp nhị phân độc lập, một dịch vụ được lưu trữ từ xa không thể được khởi động lại từ trạng thái sạch cho mỗi lần thực thi.

Thực thi hồi cứu. Chúng tôi đề xuất thực thi hồi cứu (RE) như một sự thay thế hiệu quả, không có tác dụng phụ cho việc thực thi chương trình. Ý tưởng chính là mô phỏng thực thi bằng cách "phát lại" các nhân chứng được thu thập cho giai đoạn phân tích API. Khi đánh giá một chương trình ứng viên, thay vì thực thi một cuộc gọi API, RE thay vào đó tìm kiếm một nhân chứng phù hợp và thay thế phản hồi của nó tại chỗ gọi. Tuy nhiên, nếu được thực hiện một cách ngây thơ, quá trình này gần như luôn dẫn đến thất bại hoặc một mảng rỗng; vì vậy việc làm cho RE hữu ích cho mục đích xếp hạng đòi hỏi việc thiên vị một cách rõ ràng việc thực thi hướng tới kết quả có ý nghĩa.

Như một minh họa, hãy xem xét việc thực thi chương trình trong Hình 2 sử dụng các nhân chứng trong Hình 4. Như bước đầu tiên, chúng tôi mô phỏng cuộc gọi đến conversations_list sử dụng nhân chứng đầu tiên; phản hồi là một mảng các kênh với tên "general", "private-test", và "team". Bước thứ hai là lọc mảng này, chỉ giữ lại những kênh có tên bằng tham số đầu vào channel_name. Nếu chúng ta đã lấy mẫu giá trị cho channel_name một cách háo hức, trước khi chạy chương trình, chúng ta hiếm khi có thể chọn một trong ba tên thực sự có trong mảng, vì vậy bước lọc (và do đó toàn bộ chương trình) gần như luôn trả về một mảng rỗng. Thay vào đó, chúng tôi lấy mẫu giá trị cho channel_name một cách lười biếng, một khi chúng tôi gặp bộ lọc, chọn một trong các tên có trong mảng.

Giả sử rằng chúng tôi đã chọn channel_name = "general", và do đó bộ lọc trả về kênh đầu tiên. Tiếp theo, chúng tôi mô phỏng cuộc gọi đến conversations_members trên ID của kênh này. Bởi vì tập nhân chứng của chúng tôi thưa thớt, chúng tôi có thể hoặc có thể không tìm thấy một kết quả chính xác cho cuộc gọi này; trong trường hợp sau, chúng tôi lấy mẫu phản hồi từ tập hợp các kết quả gần đúng, tức là các nhân chứng có cùng tên phương thức và tên đối số, nhưng không nhất thiết có cùng giá trị đối số. Do kết quả gần đúng, kết quả RE không luôn bằng kết quả của một lần thực thi thực, nhưng chúng vẫn hữu ích để ước tính liệu một ứng viên chương trình có thể tạo ra đầu ra có ý nghĩa hay không. Đối với mỗi ứng viên, chúng tôi chạy RE nhiều lần (với các hạt giống ngẫu nhiên khác nhau) và sử dụng các đầu ra để gán một thứ hạng cho mỗi ứng viên.

3 Ngôn ngữ Cốt lõi
Trong phần này, chúng tôi chính thức hóa cốt lõi của DSL APIphany như λ_A, một ngôn ngữ hàm chuyên biệt để thao tác dữ liệu bán cấu trúc. Cú pháp của λ_A được tóm tắt trong Hình 6.

Kiểu. Các kiểu của λ_A bao gồm kiểu cú pháp t (những kiểu được sử dụng trong đặc tả OpenAPI) và kiểu ngữ nghĩa t̂, mà chúng tôi suy luận. Cả hai loại kiểu đều có đối tượng có tên o, mảng [t], và bản ghi {ℓᵢ:tᵢ}. Bản ghi là ánh xạ từ nhãn trường đến kiểu; một số trường là tùy chọn, được chỉ định bằng ? trước nhãn của nó. Ví dụ, kiểu bản ghi {id:String,?time_zone:String}, có một trường bắt buộc id và một trường tùy chọn time_zone.

Hai loại kiểu khác nhau ở kiểu cơ sở của chúng: kiểu cú pháp nguyên thủy duy nhất là String, trong khi kiểu ngữ nghĩa nguyên thủy duy nhất là một loc-set, tức là một tập hợp các vị trí.

Một vị trí là một tên đối tượng hoặc phương thức theo sau bởi một chuỗi nhãn, như User.id. Ngoài các nhãn trường tương ứng với các trường đối tượng trong đặc tả OpenAPI, chúng tôi giới thiệu ba nhãn dành riêng—in, out, và 0—để địa chỉ hóa các tham số và phản hồi phương thức, và các phần tử mảng. Ví dụ, c_list.out.0 đề cập đến một kiểu phần tử của mảng phản hồi của phương thức c_list.

Kiểu hàm được viết t→t, và nhiều đối số được biểu diễn như một bản ghi có các trường mã hóa tên đối số (với các trường tùy chọn mã hóa các đối số tùy chọn).

Một thư viện Λ mô hình một đặc tả OpenAPI. Nó chứa các định nghĩa đối tượng, ràng buộc các định danh đối tượng với các kiểu (bản ghi), và các định nghĩa phương thức, ràng buộc tên phương thức với các kiểu hàm. Một thư viện ngữ nghĩa Λ̂, là đầu ra của khai thác kiểu, ràng buộc các định danh đối tượng và tên phương thức với các kiểu ngữ nghĩa. Ví dụ, Hình 7 cho thấy các định nghĩa Λ tương ứng với một phần của đặc tả Slack OpenAPI (với tên phương thức được rút ngắn để dễ đọc), và các định nghĩa tương ứng của chúng trong thư viện ngữ nghĩa Λ̂.

Thuật ngữ. Giá trị của λ_A bao gồm chuỗi ký tự, mảng, và đối tượng; đối tượng là ánh xạ từ nhãn trường đến giá trị. Tương tự như ký hiệu do của Haskell, return e trả về một mảng với một phần tử duy nhất e, và binding monadic x←e₁;e₂ đánh giá e₂ cho mỗi phần tử x của mảng e₁, và nối tất cả các mảng kết quả. Ngược lại, binding thuần túy let x=e₁;e₂ ràng buộc x với toàn bộ kết quả của e₁ và sau đó đánh giá e₂. Biểu thức bảo vệ if e₁=e₂;e đánh giá e nếu bảo vệ đúng và trả về một mảng rỗng nếu không; các bảo vệ được hạn chế đến sự bằng nhau, vì đây là những bảo vệ duy nhất được tạo ra bởi APIphany. Ở cấp độ cao nhất, một chương trình E là một trừu tượng với một danh sách các đối số x và thân e.

4 Khai thác Kiểu
Trong phần này, chúng tôi trình bày chi tiết thuật toán khai thác kiểu của APIphany, sử dụng thư viện Λ trong Hình 7 và các nhân chứng trong Hình 4 làm ví dụ chạy. Một cách không chính thức, ý tưởng là đầu tiên gán cho mỗi vị trí String loc trong Λ một kiểu duy nhất {loc}, và sau đó hợp nhất các kiểu của một số vị trí dựa trên các nhân chứng.

Gán các kiểu dựa trên vị trí. Chúng tôi chính thức hóa bước đầu tiên như một phán đoán Λ⊢loc⟹t̂, gán một kiểu ngữ nghĩa t̂ cho vị trí loc chỉ dựa trên thông tin có trong thư viện cú pháp Λ. Người đọc có thể tự hỏi tại sao kiểu được gán t̂ không phải lúc nào cũng đơn giản là {loc}. Điều này thực sự đúng với các vị trí có chú thích String xuất hiện rõ ràng trong Λ, như User.id hoặc u_info.in.user. Nhưng trong các trường hợp khác, việc gán kiểu dựa trên vị trí phức tạp hơn; ví dụ:

• Λ⊢u_info.out⟹User vì vị trí này được chú thích với một kiểu đối tượng có tên.
• Λ⊢c_members.out⟹[{c_members.out.0}] vì các kiểu mảng không tự thay thế bằng loc-sets; thay vào đó, chúng tôi gán đệ quy một kiểu dựa trên vị trí cho phần tử của mảng.
• Λ⊢u_info.out.id⟹{User.id} vì việc gán kiểu chuẩn hóa các vị trí bên trong các kiểu để đảm bảo chúng xuất hiện rõ ràng trong Λ; để làm điều này, chúng tôi gán đệ quy một kiểu cho tiền tố của vị trí, Λ⊢u_info.out⟹User, và sau đó theo trường id của đối tượng User.

Việc chính thức hóa gán kiểu dựa trên vị trí hầu hết đơn giản và được chuyển đến Phụ lục A (Hình 15).

Hợp nhất các kiểu thông qua một tập hợp rời rạc. Khai thác kiểu dựa vào một biến thể của cấu trúc dữ liệu tập hợp rời rạc (còn được gọi là union-find [31]). Tập hợp rời rạc DS của chúng tôi lưu trữ các nhóm rời rạc của các cặp (loc,v), trong đó loc là một vị trí và v là một giá trị chuỗi. Khi hai cặp ở trong cùng một nhóm, các vị trí tương ứng của chúng có cùng kiểu ngữ nghĩa.

DS hỗ trợ hai hoạt động hiệu quả: insert và find. insert nhận một cặp (loc,v) và kiểm tra xem có thành phần nào của nó đã xuất hiện trong DS; nếu có, nó hợp nhất cặp mới vào nhóm tương ứng, và nếu không thì đặt nó vào một nhóm mới. find nhận một vị trí loc và trả về một kiểu ngữ nghĩa t̂; bên trong, find định vị nhóm mà cặp (loc,_) thuộc về trong DS và trả về loc-set {loc,loc₁,...} chứa tất cả các vị trí trong nhóm đó.

Thuật toán khai thác kiểu. Hình 8 trình bày thuật toán cấp cao MineTypes, nhận đầu vào là một thư viện cú pháp Λ và một tập hợp nhân chứng W, và trả về một thư viện ngữ nghĩa Λ̂. Một nhân chứng W là một bộ ba ⟨f,v_in,v_out⟩, trong đó f là một tên phương thức và v_in,v_out là giá trị đối số và phản hồi của nó (nhiều đối số được biểu diễn như một đối tượng). MineTypes hoạt động trong hai giai đoạn: trong các dòng 2–5 nó xây dựng tập hợp rời rạc DS từ W và trong dòng 6 nó xây dựng Λ̂ từ DS.

Trong giai đoạn đầu tiên, thuật toán lặp qua các nhân chứng, đăng ký giá trị đầu vào v_in tại vị trí f.in và giá trị đầu ra v_out tại vị trí f.out. Để làm điều này, chúng tôi gọi một hàm trợ giúp AddWitness, đi sâu vào các giá trị tổng hợp (mảng và đối tượng) để đến các chuỗi ký tự, và sau đó insert mỗi chuỗi vào DS với kiểu dựa trên vị trí của nó. Ví dụ, khi xử lý phản hồi từ nhân chứng đầu tiên trong Hình 4, AddWitness lặp qua tất cả các đối tượng kênh trong mảng, và qua tất cả các trường của mỗi đối tượng kênh; một khi nó đến giá trị "UJ5RHEG4S", nó tính toán kiểu của vị trí của nó là Λ⊢c_list.out.0.creator⟹{Channel.creator}, và chèn (Channel.creator,"UJ...") vào DS. Xử lý nhân chứng thứ hai dẫn đến việc chèn các cặp (u_info.in.user,"UJ...") và (User.id,"UJ..."), chia sẻ cùng giá trị chuỗi, và do đó tất cả ba cặp được hợp nhất vào cùng một nhóm. Một khi tất cả các nhân chứng được thêm vào DS, các nhóm của nó đại diện cho tập hợp cuối cùng của các kiểu ngữ nghĩa.

Trong giai đoạn thứ hai, thuật toán gọi AddDefinitions để lặp qua tất cả các định nghĩa đối tượng và phương thức trong Λ, và thêm các định nghĩa tương ứng vào Λ̂, dựa vào find để lấy kiểu ngữ nghĩa cho mỗi vị trí. Ví dụ, khi thêm phương thức u_info, chúng tôi truy vấn find(DS,u_info.in.user), tìm nhóm được đề cập ở trên và trả về loc-set của nó: {User.id,Channel.creator,...}. Nếu vị trí được yêu cầu không có trong DS—vì W không có nhân chứng cho phương thức hoặc đối tượng bao quanh—nó được chú thích với kiểu dựa trên vị trí chưa được hợp nhất.

5 Tổng hợp Hướng Kiểu
Trong phần này, chúng tôi thảo luận về cách APIphany tạo ra một tập hợp các chương trình có kiểu tốt cho trước một kiểu truy vấn, sử dụng cùng một ví dụ chạy như trong các phần trước.

Bài toán tổng hợp. Chính thức, bài toán tổng hợp của chúng tôi được định nghĩa bởi một thư viện ngữ nghĩa Λ̂ và một kiểu truy vấn ngữ nghĩa ŝ. Đối với ví dụ chạy của chúng tôi, chúng tôi sử dụng thư viện ngữ nghĩa từ Hình 7 và kiểu truy vấn Channel.name→[Profile.email]. Một giải pháp ứng viên là bất kỳ chương trình E nào có kiểu kiểm tra đối với ŝ. Để chính thức hóa khái niệm này, chúng tôi giới thiệu phán đoán gõ chương trình Λ̂⊢E::ŝ, hầu hết đơn giản. Chúng tôi chỉ lưu ý rằng trong một binding monadic x←e₁;e₂, cả e₁ và e₂ đều phải có kiểu mảng; trong một bảo vệ if e₁=e₂;e, e phải có kiểu mảng, trong khi e₁ và e₂ phải có kiểu loc-set (giống nhau), vì sự bằng nhau chỉ được hỗ trợ trên các giá trị chuỗi. Định nghĩa đầy đủ có thể tìm thấy trong Phụ lục B (Hình 16).

Mạng chuyển đổi kiểu. Để liệt kê hiệu quả các chương trình có kiểu tốt, chúng tôi theo công việc trước [8,12] và mã hóa không gian tìm kiếm như một loại đặc biệt của mạng Petri, được gọi là mạng chuyển đổi kiểu (TTN). Một cách trực quan, một TTN mã hóa cách mỗi phương thức API biến đổi các giá trị của một kiểu ngữ nghĩa thành kiểu khác; ví dụ u_info biến đổi một User.id thành một User. Hình 9 cho thấy một TTN cho ví dụ chạy của chúng tôi. Các địa điểm (hình tròn) tương ứng với các kiểu ngữ nghĩa, các chuyển đổi (hình chữ nhật) tương ứng với các phương thức, và các cạnh kết nối các phương thức với các kiểu đầu vào và đầu ra của chúng. Ngoài các phương thức API, TTN chứa các chuyển đổi tương ứng với các phép chiếu λ_A (ví dụ projUser.profile và projProfile.email) và các bảo vệ (ví dụ filterChannel.name).

Tìm kiếm bỏ qua mảng. Để mã hóa không gian tìm kiếm của chúng tôi hữu ích, chúng tôi cần đảm bảo rằng mỗi chương trình λ_A có kiểu tốt tương ứng với một đường dẫn trong TTN. Đây là nơi chúng tôi gặp phải một thách thức: không có cách đơn giản nào để mã hóa hoạt động bind monadic của λ_A vào TTN. Mặc dù công việc trước về Hoogle+ [12] hỗ trợ các hàm bậc cao hơn, các đối số cho những hàm đó được hạn chế cú pháp đến các biến (tức là các trừu tượng lambda bên trong không được hỗ trợ), điều này không đủ cho mục đích của chúng tôi. Để giải quyết vấn đề này, chúng tôi giới thiệu một mã hóa TTN mới, bỏ qua mảng, không phân biệt giữa các kiểu mảng và các kiểu của các phần tử của chúng, và do đó không yêu cầu bind monadic. Ví dụ, trong Hình 9 c_members trả về User thay vì [User], và do đó đầu ra của nó có thể được truyền trực tiếp đến u_info, mà không cần lặp qua nó.

Tìm kiếm trong TTN. Một khi TTN được xây dựng, chúng tôi liệt kê các đường dẫn từ kiểu đầu vào đến kiểu đầu ra (hoặc đúng hơn, các phiên bản bỏ qua mảng của chúng). Trong ví dụ của chúng tôi, chúng tôi đặt một token trong kiểu đầu vào Channel.name và tìm kiếm một đường dẫn (một chuỗi các chuyển đổi) sẽ đưa token này đến kiểu đầu ra Profile.email, có thể tạo ra và tiêu thụ các token bổ sung dọc theo đường. Đường dẫn in đậm trong Hình 9 tương ứng với giải pháp mong muốn của chúng tôi từ Hình 2. Trên đường dẫn này, chúng tôi đầu tiên kích hoạt chuyển đổi c_list (không tiêu thụ token nào) để tạo ra một token bổ sung trong Channel. Tiếp theo, chúng tôi kích hoạt filterChannel.name, tiêu thụ hai token trong Channel và Channel.name, và tạo ra một token duy nhất trong Channel. Năm chuyển đổi còn lại trên đường dẫn in đậm chỉ đơn giản di chuyển token này dọc theo cho đến khi nó đến Profile.email.

Giống như trong công việc trước [8,12], một đường dẫn chỉ được coi là hợp lệ nếu trạng thái cuối cùng chứa chính xác một token trong kiểu đầu ra (và không có token trong bất kỳ kiểu nào khác); điều kiện này đảm bảo rằng các chương trình được tạo ra sử dụng tất cả đầu vào của chúng.

Thuật toán tổng hợp. Thuật toán tổng hợp cấp cao của APIphany được mô tả trong Hình 10. Thuật toán đầu tiên xây dựng một TTN N và mã hóa kiểu truy vấn ŝ như một vị trí token ban đầu và cuối cùng, I và F; sau đó nó liệt kê tất cả các đường dẫn từ I đến F trong N theo thứ tự độ dài (cho đến hết thời gian). Đối với mỗi đường dẫn π, thuật toán lặp qua các chương trình bỏ qua mảng tương ứng E và nâng chúng thành các chương trình λ_A có kiểu tốt. Lý do π có thể tạo ra nhiều chương trình là TTN không phân biệt các đối số khác nhau của cùng một kiểu, và do đó chúng tôi phải thử tất cả các kết hợp của chúng.

Bởi vì việc xây dựng TTN và tìm kiếm các đường dẫn hợp lệ tương tự như công việc trước, chúng tôi bỏ qua mô tả chi tiết của chúng và giới thiệu người đọc quan tâm đến Phụ lục B.

Một khác biệt đáng đề cập, tuy nhiên, là chúng tôi sử dụng một bộ giải quy hoạch tuyến tính nguyên (ILP) để tìm đường dẫn trong TTN, không giống như các cách tiếp cận trước, dựa vào các bộ giải SAT/SMT. Chúng tôi thấy rằng mặc dù cả hai bộ giải đều nhanh như nhau trong việc tìm một đường dẫn hợp lệ, khi tính toán tất cả các đường dẫn hợp lệ của một độ dài cho trước, bộ giải ILP hiệu quả hơn nhiều, vì nó có hỗ trợ gốc để liệt kê nhiều giải pháp.

Nâng các chương trình bỏ qua mảng. Hàm Progs(π) (dòng 5 trong Hình 10) chuyển đổi một đường dẫn TTN π thành một tập hợp các chương trình bỏ qua mảng ở dạng chuẩn A (ANF). Hình 11 (trái) cho thấy chương trình bỏ qua mảng đầy đủ được trích xuất từ đường dẫn in đậm trong Hình 9. Như bạn có thể thấy từ ví dụ này, các chương trình bỏ qua mảng có thể không có kiểu tốt: ví dụ, phép chiếu x₁.name trong dòng 4 không kiểm tra kiểu vì x₁ thực sự có kiểu mảng [Channel]. Điều chúng tôi thực sự muốn chương trình này làm là chiếu name (và thực thi các bước còn lại trong chương trình) cho mỗi kênh trong x₁. Điều này có thể được thực hiện bằng cách chèn một binding monadic x'₁←x₁ và sử dụng x'₁ thay vì x₁ trong dòng 4 (và ở những nơi khác trong chương trình nơi một phiên bản không phải mảng của x₁ được yêu cầu, như dòng 6).

Chúng tôi gọi quá trình sửa chữa lỗi kiểu bằng cách chèn các binding monadic và return là nâng cấp.

Hàm Lift (dòng 6 trong Hình 10) nhận đầu vào là một thư viện ngữ nghĩa Λ̂, một kiểu truy vấn ŝ, và một chương trình bỏ qua mảng E, và tạo ra một chương trình E' có kiểu tốt tại ŝ. Hình 11 (phải) mô tả kết quả của việc nâng chương trình trong Hình 11 (trái) đến kiểu truy vấn Channel.name→[Profile.email] với Λ̂ từ Hình 7. Định nghĩa đầy đủ của việc nâng có thể tìm thấy trong Phụ lục B (Hình 18). Một cách không chính thức, việc nâng kiểm tra kiểu chương trình "từng dòng", và bất cứ khi nào nó gặp phải một lỗi không khớp kiểu (trong một phép chiếu, bảo vệ, hoặc một đối số phương thức), nó chèn số lượng thích hợp các binding monadic hoặc return để sửa lỗi không khớp. Điều này luôn có thể vì loại lỗi không khớp kiểu duy nhất chúng tôi có thể gặp phải là giữa một kiểu thực tế [..[t̂]..] và kiểu mong đợi t̂, hoặc ngược lại. Một điều đáng lưu ý là chúng tôi giả định rằng kiểu trả về cấp cao nhất của chương trình là một kiểu mảng: vì các chương trình được nâng có binding monadic cấp cao nhất, chúng chỉ có thể trả về mảng. Nếu người dùng yêu cầu một kiểu trả về vô hướng, chúng tôi tính đến điều này ở giai đoạn xếp hạng bằng cách ưu tiên các chương trình luôn trả về mảng đơn tố.

Tính đầy đủ. Nói một cách nghiêm ngặt, tìm kiếm bỏ qua mảng là không đầy đủ: có nhiều chương trình ánh xạ đến cùng một chương trình bỏ qua mảng, nhưng việc nâng chỉ trả về một đại diện chính tắc duy nhất. Ví dụ, hãy xem xét chương trình trong Hình 11 (phải), nơi chúng tôi lặp qua mảng x₁ chỉ một lần (dòng 3), và tái sử dụng cùng biến "iterator" x₁' trong các dòng 4 và 6. Một thay thế sẽ là lặp qua x₁ lần thứ hai trước dòng 6, hiệu quả lấy tên và ID từ tất cả các cặp kênh (thay vì tên và ID thuộc về cùng một kênh). Chúng tôi coi đây là một sự không đầy đủ tốt tính bởi vì việc người dùng có ý định lặp hai lần qua cùng một mảng ít có khả năng hơn nhiều. Nếu họ có, chúng tôi tin rằng họ có thể sửa chữa chương trình bằng tay, như chúng tôi thảo luận trong Mục 7.4.

6 Xếp hạng
Như chúng tôi đã đề cập trong Mục 2, thuật toán Synthesize có thể tạo ra hàng trăm hoặc thậm chí hàng nghìn giải pháp ứng viên có kiểu tốt, tuy nhiên, hầu hết trong số đó không thú vị. Bây giờ chúng tôi chính thức hóa cách APIphany xếp hạng những ứng viên này với sự trợ giúp của thực thi hồi cứu (RE).

Tính toán chi phí. Để xếp hạng các chương trình, chúng tôi gán cho chúng một chi phí dương, và sau đó sắp xếp chúng từ chi phí thấp nhất đến cao nhất. Để tính toán chi phí của một chương trình E, chúng tôi thực thi hồi cứu nó nhiều lần, tích lũy kết quả thực thi trong một tập hợp res; thực thi hồi cứu là không xác định, và thực thi một chương trình nhiều lần dẫn đến ước tính chi phí chính xác hơn. Sau đó chúng tôi tính toán chi phí của E dựa trên tập kết quả res và kiểu trả về t̂ của truy vấn như sau:

1. Chi phí cơ sở là kích thước của E trong các nút AST.
2. Nếu res=∅ (tất cả các lần thực thi đã thất bại), ứng viên nhận một hình phạt lớn.
3. Nếu res={[]} (tất cả các lần thực thi trả về một mảng rỗng), ứng viên nhận một hình phạt trung bình.
4. Cuối cùng, chúng tôi so sánh các giá trị v∈res với kiểu kết quả mong muốn t̂; nhớ rằng các chương trình λ_A luôn trả về một mảng, trong khi t̂ có thể hoặc có thể không là một kiểu mảng. Chúng tôi gán một hình phạt nhỏ cho một lỗi không khớp bội số, tức là nếu t̂ là một kiểu vô hướng và bất kỳ giá trị v nào có nhiều hơn một phần tử, hoặc t̂ là một kiểu mảng và tất cả giá trị v có một phần tử duy nhất.

Thực thi hồi cứu. Chúng tôi chính thức hóa RE như một phán đoán ⟨W;Γ;Σ|e⟩⇒v, nói rằng v là một kết quả hợp lệ để thực thi biểu thức e trong môi trường Σ (ánh xạ các biến đến giá trị). Phán đoán cũng được tham số hóa bởi một ngữ cảnh kiểu Γ và tập nhân chứng W, được sử dụng để phát lại các cuộc gọi phương thức và lấy mẫu đầu vào chương trình. Để chạy một giải pháp ứng viên E, chúng tôi thực thi thân của nó trong một môi trường rỗng Σ=· và với Γ lưu trữ các kiểu của các đối số của E. Như chúng tôi giải thích chi tiết hơn dưới đây, các đầu vào chương trình được chọn một cách lười biếng, trong quá trình thực thi, để tối đa hóa cơ hội tạo ra kết quả có ý nghĩa.

Phát lại các cuộc gọi phương thức. Hầu hết các quy tắc cho phán đoán RE mô tả ngữ nghĩa hoạt động big-step tiêu chuẩn (chúng có thể tìm thấy trong Hình 19 trong Phụ lục C), nhưng hai nhóm quy tắc, được hiển thị trong Hình 12, đáng được chú ý hơn. Nhóm đầu tiên đáng quan tâm bao gồm E-Method-Val và E-Method-Name, phát lại một cuộc gọi phương thức bằng cách tra cứu nó trong W. Quy tắc E-Method-Val áp dụng khi W chứa một kết quả chính xác cho cuộc gọi hiện tại, tức là chúng tôi đã quan sát trước đó một cuộc gọi đến cùng một phương thức, với cùng tên tham số và giá trị tham số. Quy tắc E-Method-Name áp dụng khi không thể tìm thấy một kết quả chính xác (xem tiền đề đầu tiên); trong trường hợp này, chúng tôi chọn một kết quả gần đúng, nơi chỉ có tên phương thức và tên tham số khớp. Việc khớp tên tham số quan trọng bởi vì nhiều phương thức API REST chấp nhận các tham số tùy chọn, và hoạt động rất khác nhau dựa trên mẫu tham số tùy chọn nào được cung cấp. Nếu một kết quả gần đúng cũng không thể tìm thấy, RE thất bại. Lưu ý rằng đối với một cuộc gọi cho trước f(lᵢ=vᵢ), có thể có nhiều kết quả gần đúng trong W, điều này làm cho RE không xác định (thực tế, thậm chí có thể có nhiều kết quả chính xác bởi vì các dịch vụ có trạng thái). Do trạng thái ẩn và kết quả gần đúng, kết quả của RE không được đảm bảo khớp với thực thi thực tế, nhưng các thí nghiệm của chúng tôi cho thấy chúng đủ chính xác cho mục đích xếp hạng.

Lấy mẫu lười biếng các đầu vào chương trình. Hai quy tắc còn lại trong Hình 12 chịu trách nhiệm chọn đầu vào chương trình để thiên vị các biểu thức bảo vệ đánh giá thành true. Chúng tôi quan sát thấy rằng khi các đầu vào được lấy mẫu háo hức trước thời gian, các biểu thức bảo vệ gần như luôn đánh giá thành false, khiến RE trả về một mảng rỗng; kết quả là, heuristic xếp hạng của chúng tôi không thể phân biệt các ứng viên có ý nghĩa với những ứng viên trả về một mảng rỗng bất kể đầu vào. Để giải quyết vấn đề này, chúng tôi hoãn việc thêm đầu vào chương trình vào môi trường Σ cho đến khi chúng được sử dụng. Nếu việc sử dụng đầu tiên của một đầu vào chương trình là trong một bảo vệ, các quy tắc E-If-True-L và E-If-True-R chọn giá trị của nó để làm cho bảo vệ đúng: E-If-True-L áp dụng khi chỉ có phía bên phải của một bảo vệ không được định nghĩa, và E-If-True-R áp dụng khi phía bên trái hoặc cả hai không được định nghĩa. Nếu việc sử dụng đầu tiên của một đầu vào là trong một cuộc gọi phương thức hoặc một phép chiếu, chúng tôi thay vào đó lấy mẫu ngẫu nhiên từ tất cả các giá trị của cùng kiểu được quan sát trong W.

7 Đánh giá
Chúng tôi triển khai APIphany bằng Python, ngoại trừ thực thi hồi cứu, nơi chúng tôi sử dụng Rust vì lý do hiệu suất. Chúng tôi sử dụng bộ giải ILP Gurobi [13] v9.1 làm back-end cho tìm kiếm TTN. Chúng tôi chạy tất cả các thí nghiệm trên một máy với CPU Intel Core i9-10850K và 32GB bộ nhớ.

Chúng tôi thiết kế đánh giá thực nghiệm để trả lời các câu hỏi nghiên cứu sau:

(RQ1) APIphany có thể tìm giải pháp cho một loạt các nhiệm vụ thực tế trên nhiều API phổ biến không?
(RQ2) Khai thác kiểu có hiệu quả và cần thiết để kích hoạt tổng hợp hướng kiểu không?
(RQ3) Thực thi hồi cứu có hiệu quả và cần thiết để ưu tiên các kết quả tổng hợp liên quan không?

Lựa chọn API. Để đánh giá, chúng tôi đã chọn ba API REST phổ biến: nền tảng giao tiếp Slack và hai nền tảng thanh toán trực tuyến, Stripe và Sqare. Chúng tôi chọn những API này vì chúng được sử dụng rộng rãi và có cả đặc tả OpenAPI và giao diện web, cho phép chúng tôi thiết lập môi trường kiểm tra và thu thập nhân chứng dễ dàng.

Như được hiển thị trong Bảng 1, những API này khá phức tạp: mỗi cái có hơn một trăm phương thức với tối đa 145 đối số; cả ba đều có các đối số tùy chọn. Ba API cũng chứa một số lượng lớn định nghĩa đối tượng, với tối đa 70 trường.

Thiết lập thí nghiệm: khai thác kiểu. Nhớ rằng khai thác kiểu dựa vào một tập nhân chứng W. Nhân chứng rất đơn giản để thu thập cho chủ sở hữu API, hoặc khi một bộ kiểm tra tích hợp có sẵn công khai; cả hai đều không phải là trường hợp trong thiết lập của chúng tôi. Thay vào đó, chúng tôi thu thập nhân chứng bằng cách quan sát lưu lượng từ giao diện web của dịch vụ, và sau đó tăng cường tập nhân chứng ban đầu (rất thưa thớt) này thông qua kiểm tra ngẫu nhiên; quá trình này được mô tả chi tiết hơn trong Phụ lục D. Như được hiển thị trong Bảng 1, chúng tôi thu thập từ 1.7K đến 25K nhân chứng cho mỗi API, bao phủ 30–40% tất cả các phương thức. Thật khó để có được phạm vi bao phủ đầy đủ cho những API nguồn đóng này như một người ngoài cuộc, ví dụ, bởi vì nhiều phương thức chỉ có sẵn cho các tài khoản trả phí; tuy nhiên, các thí nghiệm của chúng tôi cho thấy APIphany hoạt động tốt với tập nhân chứng này.

Lựa chọn benchmark. Đối với mỗi API, chúng tôi trích xuất các nhiệm vụ lập trình từ các câu hỏi StackOverflow đề cập đến API này cũng như các kho lưu trữ GitHub sử dụng API. Sau khi loại trừ các nhiệm vụ nằm ngoài phạm vi của DSL của chúng tôi, chúng tôi dịch thủ công mỗi nhiệm vụ còn lại từ mô tả bằng ngôn ngữ tự nhiên hoặc một đoạn mã thành một truy vấn kiểu, dẫn đến 32 benchmark (xem Bảng 2). Ngoài ví dụ chạy của chúng tôi (benchmark 1.1), những nhiệm vụ này bao gồm, ví dụ: "Gửi tin nhắn đến người dùng có email cho trước" trong Slack (1.2), "Tạo sản phẩm và lập hóa đơn cho khách hàng" trong Stripe (2.3), và "Xóa các mục danh mục có tên cho trước" trong Sqare (3.10). Như được lưu ý trong Bảng 2, nhiều nhiệm vụ này có tác dụng: chúng yêu cầu tạo, sửa đổi, hoặc xóa đối tượng.

Mỗi benchmark đi kèm với một giải pháp "tiêu chuẩn vàng": giải pháp được chấp nhận trên StackOverflow hoặc đoạn mã chúng tôi tìm thấy trên GitHub. Chúng tôi dịch thủ công những giải pháp này thành DSL của APIphany. Như được hiển thị trong phần "Kích thước giải pháp" của Bảng 2, những giải pháp này có độ phức tạp từ 7 đến 22 nút AST, chứa tối đa ba cuộc gọi phương thức và bảo vệ và tối đa bảy phép chiếu, điều này làm cho chúng không tầm thường cho các lập trình viên giải quyết thủ công. Danh sách đầy đủ các nhiệm vụ, truy vấn kiểu, và giải pháp có thể tìm thấy trong Phụ lục E.

Thiết lập thí nghiệm: tổng hợp chương trình. Đối với mỗi trong số 32 benchmark, chúng tôi chạy bộ tổng hợp với thời gian chờ 150 giây. Đối với mỗi ứng viên mới được tạo ra, chúng tôi ước tính chi phí của nó bằng 15 vòng RE và ghi lại thời gian tổng hợp (bao gồm cả thời gian tìm kiếm TTN và thời gian RE). Sau thời gian chờ, chúng tôi kiểm tra xem giải pháp tiêu chuẩn vàng có xuất hiện trong số các ứng viên được tạo ra không và so sánh thứ hạng dựa trên RE của nó với thứ hạng ban đầu mà nó được tạo ra (dựa trên độ dài đường dẫn). Dưới đây chúng tôi báo cáo thời gian trung bình và thứ hạng trung vị qua ba lần chạy để giảm tác động của tính ngẫu nhiên.

7.1 RQ1: Hiệu quả Tổng thể
Bốn cột cuối cùng của Bảng 2 chi tiết hiệu suất của APIphany trên 32 benchmark tổng hợp. APIphany tìm thấy giải pháp đúng cho 29 benchmark. Ba benchmark còn lại thất bại với thời gian chờ vì truy vấn kiểu của chúng quá mơ hồ; ví dụ, trong benchmark 1.3 ("Lấy tin nhắn chưa đọc của người dùng") truy vấn kiểu không có phương tiện để chỉ định rằng chúng tôi chỉ quan tâm đến tin nhắn chưa đọc; kết quả là, giải pháp bị chìm trong hàng nghìn chương trình khác ánh xạ ID người dùng đến tin nhắn.

Chúng tôi vẽ số lượng benchmark được giải quyết như một hàm của thời gian (bao gồm RE) trong Hình 13. Như biểu đồ cho thấy, phần lớn benchmark (19/32) có thể được giải quyết trong vòng năm giây. Trung bình APIphany mất 17.8 giây để tìm ra giải pháp mong muốn (thời gian trung vị 1.3 giây).

Kết luận: APIphany có thể giải quyết 91% nhiệm vụ từ ba API thực tế.

7.2 RQ2: Khai thác Kiểu
Nhớ rằng khai thác kiểu liên quan đến việc thay thế các kiểu cú pháp nguyên thủy trong đặc tả bằng các kiểu dựa trên vị trí duy nhất, và sau đó hợp nhất những kiểu đó dựa trên tập nhân chứng để có được các kiểu ngữ nghĩa. Quá trình hợp nhất không hoàn hảo: nó có thể thất bại trong việc hợp nhất hai vị trí nên có cùng kiểu vì tập nhân chứng thiếu bằng chứng để biện minh cho việc hợp nhất; hoặc nó có thể hợp nhất một cách giả tạo hai vị trí nếu chúng chia sẻ một giá trị do tình cờ. Thật khó để đo độ chính xác của các kiểu được suy luận một cách trực tiếp, vì chúng tôi không có một oracle cho các kiểu ngữ nghĩa. Thay vào đó, chúng tôi đánh giá khai thác kiểu một cách gián tiếp theo hai cách: 1) chúng tôi chạy một nghiên cứu ablation để đo tác động của nó đối với hiệu suất tổng thể của bộ tổng hợp, và 2) chúng tôi thực hiện một phân tích định tính quy mô nhỏ của các kiểu được suy luận.

Nghiên cứu ablation. Đối với thí nghiệm này, chúng tôi so sánh hiệu suất của APIphany và hai biến thể của nó: (a) APIphany-Syn, xây dựng TTN trực tiếp từ các kiểu cú pháp, và (b) APIphany-Loc, xây dựng TTN từ các kiểu dựa trên vị trí (chưa được hợp nhất). Chúng tôi vẽ số lượng benchmark được giải quyết bởi mỗi biến thể như hàm của thời gian trong Hình 13.

Như mong đợi, cả hai biến thể đều hoạt động kém: APIphany-Syn chỉ giải quyết 4/32 benchmark và APIphany-Loc giải quyết 5. Tất cả những benchmark này đều "dễ" (được giải quyết bởi APIphany trong vòng dưới một giây). Một cách trực quan, hai biến thể đại diện cho hai cực đoan về mặt độ chi tiết kiểu. Các kiểu cú pháp quá thô (tất cả vị trí String có cùng kiểu), dẫn đến tìm kiếm TTN trả về quá nhiều ứng viên có kiểu tốt. Kết quả là, APIphany-Syn gặp khó khăn để giải quyết tất cả trừ những nhiệm vụ đơn giản nhất, với nhiều benchmark hết bộ nhớ. Mặt khác, các kiểu dựa trên vị trí quá chi tiết (mỗi vị trí String có một kiểu duy nhất), dẫn đến hầu hết các giải pháp mong muốn đơn giản là không có kiểu tốt, vì không có cách nào để một phương thức sử dụng các giá trị được trả về bởi phương thức khác. Các giải pháp cho tất cả năm benchmark được giải quyết bởi APIphany-Loc chỉ có một cuộc gọi phương thức không có tham số, theo sau bởi một số phép chiếu hoặc bộ lọc.

Như bạn có thể thấy từ Hình 13, APIphany vượt trội hẳn cả hai biến thể. Kết quả này cho thấy rằng khai thác kiểu đạt được sự cân bằng tốt giữa các kiểu thô và chi tiết: tất cả 32 benchmark đều có một giải pháp có kiểu tốt về mặt các kiểu được khai thác, và APIphany có thể tìm thấy hầu hết chúng trong thời gian hợp lý.

Phân tích định tính. Để đưa ra một báo cáo trực tiếp hơn về chất lượng của các kiểu ngữ nghĩa được suy luận, chúng tôi lấy mẫu ngẫu nhiên năm phương thức từ mỗi API (trong số các phương thức được bao phủ bởi các nhân chứng được thu thập), và kiểm tra thủ công các kiểu được suy luận để kiểm tra xem chúng có khớp với kỳ vọng của chúng tôi không. Cụ thể hơn, đối với mỗi vị trí String trong một đặc tả phương thức, chúng tôi chọn một kiểu vị trí loc*, mà chúng tôi coi là tự nhiên nhất để một lập trình viên sử dụng trong một truy vấn kiểu (ví dụ, đối với tham số đến users_info, loc*=User.id); chúng tôi coi kiểu loc-set được suy luận đủ nếu nó chứa loc*. Kết quả chi tiết xuất hiện trong Phụ lục E (Bảng 4).

Trong các phương thức chúng tôi kiểm tra, khai thác kiểu có thể suy luận một kiểu ngữ nghĩa đủ cho tất cả phản hồi, tham số bắt buộc, và khoảng một nửa các tham số tùy chọn. Các tham số tùy chọn còn lại được gán các kiểu vị trí chưa được hợp nhất, vì chúng không bao giờ được sử dụng trong tập nhân chứng của chúng tôi. Điều này gần như không thể tránh khỏi, vì số lượng khổng lồ các tham số tùy chọn khó hiểu trong các API thực tế (may mắn thay, hiếm khi cần thiết để giải quyết nhiệm vụ của lập trình viên).

Nhớ rằng chế độ thất bại khác của khai thác kiểu là hợp nhất một cách giả tạo các vị trí không liên quan. Chúng tôi không quan sát thấy bất kỳ hợp nhất giả tạo nào trong số các phương thức được lấy mẫu ngẫu nhiên, nhưng giai thoại chúng tôi đã gặp một hợp nhất như vậy ở nơi khác trong Slack API: giữa Channel.name và Message.name. Lưu ý rằng các hợp nhất giả tạo có thể làm chậm tìm kiếm và tạo ra một số giải pháp "không có kiểu ngữ nghĩa tốt", nhưng chúng không ngăn APIphany tìm ra giải pháp mong muốn.

Kết luận: Khai thác kiểu tăng tỷ lệ phần trăm benchmark được giải quyết từ 12% lên 91%.

7.3 RQ3: Xếp hạng
Để đo hiệu quả của xếp hạng dựa trên RE, chúng tôi so sánh ba cột cuối cùng của Bảng 2: rorig biểu thị thứ hạng của giải pháp mong muốn theo thứ tự nó được tạo ra bởi tìm kiếm TTN (dựa trên độ dài đường dẫn, và do đó tương quan với kích thước giải pháp); rRE biểu thị thứ hạng dựa trên RE của giải pháp tại thời điểm nó được tạo ra, và rTORE biểu thị thứ hạng dựa trên RE của nó theo thời gian chờ (có thể thấp hơn rRE vì các ứng viên khác được tạo ra sau đó có thể được xếp hạng cao hơn). Chúng tôi báo cáo cả hai thứ hạng dựa trên RE này vì chúng tôi hình dung một người dùng APIphany kiểm tra các giải pháp ứng viên trong khoảng thời gian giữa khi chúng được tạo ra và thời gian chờ, và do đó giá trị thứ hạng liên quan nằm giữa rRE và rTORE. Chúng tôi vẽ số lượng benchmark có giải pháp nằm ở hoặc dưới mỗi thứ hạng trong Hình 14, với phạm vi giữa rRE và rTORE được biểu diễn như một khu vực được tô đầy.

Như bạn có thể thấy từ Hình 14, xếp hạng dựa trên RE tăng đáng kể cơ hội rằng giải pháp mong muốn được đưa vào danh sách ngắn các ứng viên. Đặc biệt, không có xếp hạng dựa trên RE chỉ 8 benchmark (28% được giải quyết) trả về giải pháp đúng trong top năm, và chỉ 12 (41%) trả về nó trong top mười; ngược lại, với xếp hạng dựa trên RE, 19 (65%) benchmark trả về giải pháp đúng trong top năm (sau thời gian chờ), và 23 (79%) trong top mười. Hơn nữa, như chúng tôi có thể thấy từ Bảng 2, thứ hạng của giải pháp không bao giờ trở nên tệ hơn sau RE, trong tất cả trừ hai trường hợp nó cải thiện nghiêm ngặt, và đối với tất cả các benchmark chạy lâu nó cải thiện đáng kể (thứ hạng trung bình cải thiện từ 2230.5 xuống 7.0).

Một cái nhìn kỹ hơn vào sáu benchmark không nằm trong top mười sau RE tiết lộ hai lý do chính cho những xếp hạng không tối ưu này. Trong hầu hết các trường hợp, giải pháp đơn giản là lớn, và có nhiều ứng viên nhỏ hơn vẫn có ý nghĩa. Ví dụ, truy vấn "Xóa tất cả mục danh mục" (3.11) không nhận đối số và trả về một mảng tất cả các mục đã xóa; có nhiều cách hợp lệ và đơn giản để xây dựng một mảng các mục danh mục mà không xóa chúng. Trong một số trường hợp, APIphany thất bại trong việc loại bỏ các chương trình vô nghĩa do tính không chính xác của thực thi hồi cứu. Ví dụ, trong 1.6 nó báo cáo một giải pháp đăng một bản cập nhật lên một kênh cho trước với một dấu thời gian cho trước, mặc dù dấu thời gian này có thể không hợp lệ cho kênh này; APIphany thay vào đó nghĩ rằng cuộc gọi này luôn thành công bằng cách dựa vào kết quả gần đúng trong quá trình thực thi hồi cứu.

Chúng tôi cũng ghi lại thời gian APIphany mất để tính toán chi phí cho tất cả các ứng viên được tạo ra (liên quan đến việc thực thi mỗi ứng viên 15 lần). Mặc dù APIphany tạo ra hàng nghìn ứng viên có kiểu tốt cho hầu hết các benchmark, việc tính toán chi phí chỉ mất khoảng 1% tổng thời gian tổng hợp.

Kết luận: Xếp hạng dựa trên RE mất một lượng thời gian không đáng kể và tăng tỷ lệ phần trăm giải pháp đúng được báo cáo trong top mười từ 41% lên 79%.

7.4 Thảo luận và Hạn chế
Tạo nhân chứng. Một mối đe dọa đối với tính hợp lệ của đánh giá của chúng tôi là kết quả của khai thác kiểu (và do đó tổng hợp) phụ thuộc rất nhiều vào tập nhân chứng. Đặc biệt, nếu các benchmark của chúng tôi yêu cầu các phương thức không được bao phủ bởi tập nhân chứng, APIphany rất có thể sẽ không thể giải quyết chúng, vì chúng sẽ không có kiểu tốt với các kiểu ngữ nghĩa được suy luận. Chúng tôi đã chạy các thí nghiệm của mình bằng một tập nhân chứng cụ thể, mà chúng tôi thu thập bằng một phương pháp (được mô tả trong Phụ lục D); các phát hiện của chúng tôi có thể không khái quát hóa cho việc sử dụng APIphany với các tập nhân chứng được thu thập bằng các phương tiện khác.

Các phương thức có tác dụng. Chúng tôi quan sát thấy rằng các phương thức có tác dụng trong API REST có một tính chất thú vị: chúng làm cho tác dụng rõ ràng trong phản hồi của chúng. Ví dụ, phương thức để đăng tin nhắn trên Slack cũng trả về đối tượng tin nhắn, và phương thức để xóa một mục danh mục trong Sqare trả về ID của mục đã xóa (thay vì chỉ trả về void). Tính chất này làm cho API REST đặc biệt phù hợp cho tổng hợp hướng kiểu và biểu đạt ý định của người dùng với các kiểu: ví dụ, truy vấn "Gửi tin nhắn đến người dùng có email cho trước" có thể được biểu đạt như kiểu Profile.email→Message thay vì một kiểu ít thông tin hơn nhiều Profile.email→void.

Mặt trái, tất nhiên, là kiểu trả về của một phương thức có tác dụng có thể không rõ ràng đối với người dùng (ví dụ, việc xóa một mục danh mục có trả về một đối tượng hay ID của nó không?) Một cách để vượt qua hạn chế này là để người dùng chỉ định tên của phương thức cuối cùng họ muốn gọi (ví dụ catalog_object_delete) thay vì kiểu đầu ra; loại đặc tả này rất đơn giản để tích hợp vào tìm kiếm TTN.

Hạn chế DSL. Trong việc tìm kiếm benchmark của chúng tôi, chúng tôi gặp phải (rất ít) đoạn mã không thể biểu đạt trong DSL của chúng tôi vì chúng yêu cầu các biến đổi hàm trên các giá trị nguyên thủy, trái ngược với chỉ các biến đổi cấu trúc trên các đối tượng và mảng, ví dụ: "Lấy tất cả thành viên của một kênh và nối chúng lại với nhau". Chúng tôi coi những biến đổi hàm như vậy nằm ngoài phạm vi của APIphany vì các đặc tả dựa trên kiểu của nó quá thô để phân biệt giữa các biến đổi hàm khác nhau. Đây cũng là lý do đằng sau quyết định thiết kế của chúng tôi chỉ hỗ trợ sự bằng nhau bên trong các bảo vệ, trái ngược với các vị từ tổng quát hơn: nếu đặc tả không thể phân biệt giữa, chẳng hạn, = và ≤, thì có ít ích lợi trong việc tạo ra các chương trình với cả hai.

Tổng quát hơn, chúng tôi xem các chương trình được tổng hợp bởi APIphany như một điểm khởi đầu, giúp lập trình viên tìm ra cách dẫn dữ liệu qua một tập hợp các cuộc gọi API; chúng tôi hình dung người dùng xây dựng trên các chương trình đó để thêm các sửa đổi hàm và các vị từ biểu cảm hơn. Mô hình tương tác này thúc đẩy cả các hạn chế DSL và các đặc tả dựa trên kiểu của chúng tôi.

Hợp nhất vị trí dựa trên giá trị. Hợp nhất dựa trên giá trị hoạt động tốt cho các chuỗi, vì miền lớn của chúng làm cho việc hai vị trí String chia sẻ một giá trị do tình cờ không có khả năng. Nó hoạt động kém hơn cho các kiểu nguyên thủy khác, như số nguyên và boolean. Để giảm nguy cơ hợp nhất giả tạo, việc triển khai của chúng tôi thực hiện hợp nhất dựa trên giá trị chỉ cho các chuỗi và số nguyên lớn (>1000), nhưng không cho boolean hoặc số nguyên nhỏ. Trong tương lai, chúng tôi dự định điều tra các cách tiếp cận tinh vi hơn cho việc hợp nhất vị trí. Một ý tưởng là sử dụng lý luận xác suất để ước tính khả năng hai vị trí có cùng kiểu dựa trên (1) mức độ phổ biến của một giá trị trên các vị trí và (2) tỷ lệ giá trị được chia sẻ giữa hai vị trí. Một cách tiếp cận khác là nhóm các vị trí bằng các kỹ thuật NLP, như phân tích cảm xúc của tên đối tượng và trường, cũng như tài liệu.

Giao diện người dùng. Một hướng quan trọng khác cho công việc tương lai là điều tra các cách sử dụng được để chỉ định các truy vấn kiểu ngữ nghĩa và hiểu các kết quả tổng hợp. Đặc biệt, công việc hiện có từ cộng đồng HCI [9,10] có thể giúp người dùng nhanh chóng khám phá một không gian lớn các giải pháp ứng viên liên quan, do đó giảm thiểu các hạn chế của xếp hạng.

8 Công việc Liên quan
APIphany là một bộ tổng hợp dựa trên thành phần và chủ yếu so sánh với công việc liên quan trong không gian này. Nó cũng rút ra các kỹ thuật từ khai thác đặc tả và suy luận kiểu.

Tổng hợp dựa trên thành phần hướng kiểu. Mục tiêu của tổng hợp dựa trên thành phần là tìm ra một thành phần của các thành phần (hàm thư viện) triển khai một nhiệm vụ cho trước. Trong tổng hợp dựa trên thành phần hướng kiểu, cả nhiệm vụ và các thành phần đều được chỉ định bằng các kiểu. Cách tiếp cận truyền thống cho vấn đề này dựa trên tìm kiếm chứng minh [3,15,24] mở rộng kém với kích thước của thư viện thành phần. Một sự thay thế, cách tiếp cận dựa trên đồ thị có thể mở rộng hơn được giới thiệu trong Prospector [21] cho các thành phần unary, và được tổng quát hóa cho các thành phần n-ary trong SyPet [8], bằng cách thay thế đồ thị bằng mạng Petri. TYGAR [12] mở rộng thêm tìm kiếm của SyPet cho các thành phần đa hình bằng ý tưởng về các kiểu trừu tượng, được lấy cảm hứng từ các kiểu súc tích từ một bộ tổng hợp dựa trên thành phần khác, InSynth [14]. Giai đoạn tìm kiếm chương trình của APIphany sử dụng mã hóa mạng Petri từ SyPet và TYGAR với các điều chỉnh nhỏ (hỗ trợ các đối số tùy chọn và mã hóa ILP). Mã hóa bỏ qua mảng của chúng tôi liên quan đến các kiểu trừu tượng và súc tích ở chỗ nó giúp làm cho mạng Petri nhỏ hơn, nhưng nó cũng khác biệt đáng kể ở chỗ, không giống như công việc trước, nó có thể mã hóa hiệu quả một lớp nhất định của các chương trình bậc cao hơn (array comprehensions) vào mạng Petri.

Điều hướng API. Ngoài tổng hợp hướng kiểu, công việc khác tập trung vào auto-completion thông minh [20,25,27] nhưng dựa vào phân tích tĩnh và khai thác mã khách hàng, điều mà APIphany không yêu cầu. Trong số các công cụ tận dụng phân tích động, EdSynth [34] sử dụng thực thi kiểm tra để tạo ra các đoạn mã liên quan đến cả cuộc gọi API và cấu trúc điều khiển. MatchMaker [36] và DemoMatch [35] tương tự như APIphany ở chỗ chúng dựa vào các dấu vết chương trình quan sát được để đề xuất mã sử dụng các API phức tạp (cái trước từ các kiểu và cái sau từ các trình diễn). Tất cả những kỹ thuật này hoạt động trong bối cảnh của Java, và do đó giả định rằng các kiểu đủ chính xác đã có sẵn.

Tổng hợp SQL. Vấn đề tạo ra các phép chiếu và bộ lọc liên quan đến tổng hợp các truy vấn SQL [32,33]. Các kỹ thuật tổng hợp SQL hiện có không trực tiếp áp dụng được cho miền vấn đề của chúng tôi, vì (1) các chương trình của chúng tôi cũng chứa các cuộc gọi phương thức API tùy ý, và (2) chúng tôi thao tác dữ liệu bán cấu trúc thay vì dữ liệu quan hệ.

Khám phá API và khai thác đặc tả. Một cách tiếp cận bổ sung cho điều hướng API bằng tổng hợp chương trình là suy luận các đặc tả [1,23,28] hoặc các cách sử dụng ví dụ [4,6,17] để giúp người dùng hiểu API tốt hơn. Khai thác kiểu của APIphany được lấy cảm hứng từ Ammons et al. [1], nơi họ xây dựng các automat hữu hạn xác suất đại diện cho các phụ thuộc dữ liệu và thời gian giữa các phương thức API. APIphany triển khai một dạng đơn giản hóa của thuật toán của họ, khám phá các luồng dữ liệu (nhưng không có phụ thuộc thời gian), nhưng sự mới lạ nằm ở việc sử dụng thông tin này để thúc đẩy tổng hợp chương trình.

Khai thác kiểu cũng liên quan đến công việc trước về suy luận các chú thích kiểu cho các ngôn ngữ được gõ động từ các lần thực thi [2,5,7]. Tuy nhiên, công việc này dành cho các kiểu cấu trúc, trong khi chúng tôi suy luận các kiểu danh nghĩa cụ thể miền.

Thực thi mô phỏng. Một sự thay thế cho thực thi hồi cứu của chúng tôi là tổng hợp một mô hình của API, và đánh giá các ứng viên chương trình đối với mô hình đó. Công việc trước [16,19] tổng hợp các mô hình cho các framework phức tạp và mã không trong suốt; thực thi hồi cứu của chúng tôi đơn giản hơn: nó bỏ qua bước bổ sung của tổng hợp mô hình.

Xếp hạng giải pháp. Đặc tả trong tổng hợp chương trình thường mơ hồ, vì vậy các bộ tổng hợp phải xếp hạng các giải pháp ứng viên của chúng và trả về kết quả hàng đầu. Các công cụ hiện có thường dựa vào các hàm xếp hạng thủ công [11] hoặc học được [14,27,29] dựa trên các đặc trưng cú pháp của các chương trình được tạo ra. Hoogle+ [18] giống APIphany nhất ở chỗ nó xếp hạng các chương trình dựa trên kết quả thực thi của chúng, sử dụng các heuristic như liệu chương trình có luôn thất bại, và nó giống với các ứng viên khác như thế nào.

Lời cảm ơn
Các tác giả muốn cảm ơn các nhà đánh giá ẩn danh, người dẫn dắt của chúng tôi Yuepeng Wang, cũng như Hila Peleg và Ilya Sergey cho phản hồi có giá trị của họ về các bản thảo trước của bài báo này. Công việc này được hỗ trợ bởi Quỹ Khoa học Quốc gia dưới các Grants số 1943623, 1911149, và 2107397.
