# 2402.14034.pdf
# Được chuyển đổi từ PDF sang TXT
# Đường dẫn nguồn: /home/admin88/arxiv-downloader/agent/2402.14034.pdf
# Kích thước tệp: 7898607 bytes

===============================================
NỘI DUNG TỆP PDF
===============================================

--- TRANG 1 ---
AgentScope: Một Nền tảng Đa-Agent Linh hoạt nhưng Mạnh mẽ
Dawei Gao†, Zitao Li†, Xuchen Pan∗, Weirui Kuang∗, Zhijian Ma∗, Bingchen Qian∗,
Fei Wei∗, Wenhao Zhang∗, Yuexiang Xie∗, Daoyuan Chen∗,
Liuyi Yao, Hongyi Peng, Zeyu Zhang, Lin Zhu, Chen Cheng, Hongzhu Shi,
Yaliang Li‡, Bolin Ding‡, Jingren Zhou
Alibaba Group

Tóm tắt
Với sự tiến bộ nhanh chóng của các Mô hình Ngôn ngữ Lớn (LLMs), đã có tiến bộ đáng kể trong các ứng dụng đa-agent. Tuy nhiên, sự phức tạp trong việc điều phối hợp tác của các agent và hiệu suất bất thường của LLMs đặt ra những thách thức đáng chú ý trong việc phát triển các ứng dụng đa-agent mạnh mẽ và hiệu quả. Để giải quyết những thách thức này, chúng tôi đề xuất AgentScope, một nền tảng đa-agent hướng nhà phát triển với cơ chế trao đổi thông điệp là cốt lõi giao tiếp. Các công cụ cú pháp phong phú, agent có sẵn và chức năng dịch vụ, giao diện thân thiện với người dùng để trình diễn ứng dụng và giám sát tiện ích, trạm làm việc lập trình không cần mã, và cơ chế điều chỉnh prompt tự động giúp giảm đáng kể rào cản cả về phát triển và triển khai. Hướng tới ứng dụng đa-agent mạnh mẽ và linh hoạt, AgentScope cung cấp cả cơ chế chịu lỗi có sẵn và có thể tùy chỉnh. Đồng thời, nó cũng được trang bị hỗ trợ cấp hệ thống để quản lý và sử dụng dữ liệu đa phương thức, công cụ, và kiến thức bên ngoài. Ngoài ra, chúng tôi thiết kế một khung phân tán dựa trên actor, cho phép chuyển đổi dễ dàng giữa triển khai cục bộ và phân tán và tối ưu hóa song song tự động mà không cần nỗ lực thêm. Với những tính năng này, AgentScope trao quyền cho các nhà phát triển xây dựng ứng dụng thực hiện đầy đủ tiềm năng của các agent thông minh. Chúng tôi đã phát hành AgentScope tại https://github.com/modelscope/agentscope, và hy vọng AgentScope mời gọi sự tham gia rộng rãi hơn và đổi mới trong lĩnh vực phát triển nhanh này.

1 Giới thiệu
Hệ thống đa-agent, như là phần mở rộng nâng cấp của hệ thống đơn-agent, đòi hỏi nỗ lực hợp tác từ nhiều agent làm việc cùng nhau (Wang et al., 2023; Xi et al., 2023). Với sự tiến bộ của các Mô hình Ngôn ngữ Lớn (LLMs) (Ouyang et al., 2022; OpenAI, 2023; Touvron et al., 2023a,b), các ứng dụng đa-agent đã có tiến bộ lớn trong cả cộng đồng nghiên cứu và công nghiệp, bao gồm kỹ thuật phần mềm (Hong et al., 2023), mô phỏng xã hội (Park et al., 2023), và trợ lý thông minh (Wu et al., 2023; AutoGPT-Team, 2023). Mặc dù đã có tiến bộ đáng kể trong các tình huống đa-agent, vẫn còn những thách thức chính trong việc phát triển ứng dụng đa-agent.

Phát triển một ứng dụng đa-agent phức tạp hơn việc tạo ra một ứng dụng đơn-agent. Không giống như thiết lập đơn-agent nơi một agent chỉ tương tác với người dùng, việc phát triển trong tình huống đa-agent đòi hỏi việc tạo ra và quản lý cẩn thận nhiều mô hình và agent (Wang et al., 2023; Xi et al., 2023), điều này đặt ra yêu cầu cao cả về tính linh hoạt và tiện dụng cho một nền tảng. Đặc biệt, các khía cạnh sau thể hiện những thách thức: 1) Các agent tham gia trong một ứng dụng đa-agent có thể chuyên môn hóa ở các chức năng khác nhau thông qua các cấu hình ban đầu khác nhau; 2) Một ứng dụng đa-agent có thể yêu cầu các agent được thực thi trong một quy trình vận hành tiêu chuẩn (SOP) hoặc một quy trình làm việc động hơn; 3) Mô hình giao tiếp giữa các agent có thể thay đổi từ một-đến-một hoặc phát sóng (ví dụ: một nhóm thảo luận của các agent). Kết quả là, các nhà phát triển mong đợi một nền tảng tiện dụng có thể cung cấp các mô hình lập trình ngắn gọn và rõ ràng khi chăm sóc tất cả các khía cạnh trên, tăng tốc và tạo thuận lợi cho chu kỳ phát triển. Đạt được tính linh hoạt và tiện dụng đồng thời

†Tác giả đồng thứ nhất.
∗Đóng góp bằng nhau.
‡Tác giả liên hệ, địa chỉ email: {yaliang.li, bolin.ding}@alibaba-inc.com
1arXiv:2402.14034v2 [cs.MA] 20 May 2024

--- TRANG 2 ---
đòi hỏi thiết kế cẩn thận và cân bằng, và nó vẫn là một mục tiêu bền vững cho tất cả các thiết kế nền tảng đa-agent.

Các sự cố là hộp thuốc súng trong hệ thống đa-agent. Mặc dù LLMs đã tiến bộ nhanh chóng, chúng vẫn gặp khó khăn với các vấn đề như ảo giác (Rawte et al., 2023; Zhang et al., 2023b) và việc tuân theo hướng dẫn không đầy đủ (Fu et al., 2019; Zhang et al., 2023a). Ngoài ra, một agent có thể được trang bị các công cụ khác nhau, nhưng những công cụ đó mang lại những bất định bổ sung (ví dụ: khả năng truy cập cơ sở dữ liệu hoặc công cụ tìm kiếm). Từ góc độ độ mạnh mẽ của hệ thống đa-agent, bất kỳ lỗi hoặc phản hồi bất ngờ nào cũng có thể lan truyền đến toàn bộ hệ thống, gây ra một chuỗi các hiệu ứng tầng nếu không được xử lý đúng cách. Do đó, việc các ứng dụng đa-agent có thể tự động phát hiện và xử lý các phản hồi bất ngờ từ LLMs là rất quan trọng. Trong khi LLMs có thể hỗ trợ trong việc xác định và quản lý những lỗi này, việc xác định liệu chúng có thể tự giải quyết lỗi hay không và tự động cung cấp thông tin cần thiết để sửa lỗi vẫn là một thách thức. Do đó, thiết kế cơ chế chịu lỗi kết hợp LLMs là một thách thức chính trong việc phát triển ứng dụng đa-agent.

Hỗ trợ agent với dữ liệu đa phương thức, công cụ, và kiến thức bên ngoài là rất có hệ thống. Ngoài việc tạo ra câu trả lời với LLMs, các agent được mong đợi linh hoạt hơn, bao gồm tạo ra và xử lý dữ liệu đa phương thức (Su et al., 2023; Betker et al., 2023), chuẩn bị và gọi các chức năng như công cụ (Yao et al., 2023; Shen et al., 2024), quản lý ngân hàng kiến thức bên ngoài, và sử dụng kiến thức được truy xuất để tăng cường tạo sinh (Lewis et al., 2020a). Tuy nhiên, việc tích hợp những chức năng này trong các ứng dụng đa-agent đòi hỏi một cách tiếp cận toàn diện và có hệ thống. Hỗ trợ nội dung đa phương thức là một nỗ lực phức tạp, cần xem xét lưu trữ dữ liệu, trình bày, tương tác người dùng, truyền tải thông điệp, và giao tiếp. Việc sử dụng công cụ của agent đòi hỏi thống nhất mô hình gọi chức năng và phân tích đầu ra, khuyến khích hướng dẫn LLMs, và thiết kế cơ chế lý luận để đảm bảo các nhiệm vụ có thể được hoàn thành từng bước. Đối với kiến thức bên ngoài, ngoài các kỹ thuật tạo sinh tăng cường truy xuất (RAG), chúng ta cần xem xét cách chia sẻ và quản lý kiến thức hiệu quả trong các tình huống đa-agent trong khi để lại đủ linh hoạt cho các chiến lược truy xuất. Trong khi một số nghiên cứu hiện có điều tra cách những kỹ thuật đó hoạt động riêng lẻ trong các hệ thống agent chuyên biệt, các giao diện lập trình cấp nền tảng tổng quát vẫn chưa có.

Các ứng dụng phân tán mang lại khó khăn lập trình bổ sung và thách thức thiết kế hệ thống. Một tình huống hướng công nghiệp cho các ứng dụng đa-agent là các agent thuộc sở hữu của các tổ chức khác nhau và chạy trên các máy khác nhau vì các agent được trang bị kiến thức riêng tư độc đáo hoặc công cụ được cấp bằng sáng chế. Phát triển những ứng dụng như vậy thường đòi hỏi các nhà phát triển phải có kiến thức chuyên môn về lập trình hệ thống phân tán và tối ưu hóa trong giai đoạn thiết kế. Ngoài ra, các ứng dụng phân tán thường đòi hỏi nỗ lực lớn trong việc phát triển và thử nghiệm, đặc biệt khi gỡ lỗi và chẩn đoán các vấn đề trải rộng trên các quy trình hoặc agent phân tán. Hơn nữa, việc tích hợp các tính năng nâng cao như xử lý dữ liệu đa phương thức đặt ra những thách thức bổ sung trong môi trường phân tán, khi các agent cần thời gian khác nhau để hoàn thành các nhiệm vụ phụ hoặc nội dung được tạo ra rất không đồng nhất. Thiết kế hệ thống phân tán kém có thể dẫn đến chi phí giao tiếp quá mức giữa các agent. Do đó, xây dựng các ứng dụng đa-agent phân tán đòi hỏi nỗ lực lớn của các nhà phát triển có kinh nghiệm và rào cản cao cho người mới bắt đầu di chuyển các nguyên mẫu của họ sang phong cách phân tán để đạt hiệu quả tối ưu.

Để giải quyết những thách thức đã nêu, chúng tôi giới thiệu AgentScope, một nền tảng đa-agent mới được thiết kế cho các nhà phát triển với nhiều mức độ chuyên môn khác nhau. AgentScope được thiết kế tốt với cơ chế giao tiếp trao đổi thông điệp thể hiện khả năng sử dụng, độ mạnh mẽ và hiệu quả tuyệt vời. Chúng tôi nhấn mạnh các tính năng nổi bật của AgentScope như sau:

Khả năng sử dụng vượt trội cho nhà phát triển. AgentScope được thiết kế với trọng tâm cơ bản là dễ sử dụng, đặc biệt cho các nhà phát triển có nhiều mức độ chuyên môn khác nhau. Bằng cách triển khai cơ chế trao đổi thông điệp hướng quy trình, AgentScope đảm bảo đường cong học tập mượt mà trong việc phát triển ứng dụng đa-agent. Để giảm bớt gánh nặng lập trình, AgentScope cung cấp một bộ tiện ích cú pháp mở rộng, bao gồm các pipeline khác nhau và cơ chế chia sẻ thông tin. Ngoài lập trình với khung làm việc của chúng tôi, chúng tôi cũng cải thiện khả năng sử dụng bằng cách cung cấp một trạm làm việc lập trình kéo-thả không cần mã, có thể cho phép những người có kinh nghiệm lập trình Python hạn chế xây dựng ứng dụng của riêng họ với ít nỗ lực. So với việc xây dựng khung của ứng dụng, điều chỉnh prompt có thể là giai đoạn tốn thời gian hơn trong việc phát triển ứng dụng đa-agent. Trong AgentScope, chúng tôi trang bị cho các agent của mình một bộ cơ chế điều chỉnh prompt tự động để giảm bớt gánh nặng như vậy. Cùng với tài nguyên có sẵn phong phú và các mô-đun tương tác người dùng tích hợp, AgentScope làm cho việc xây dựng ứng dụng đa-agent trở nên thú vị hơn bao giờ hết.

Chịu lỗi mạnh mẽ cho LLMs và APIs đa dạng. Khi quy mô và phạm vi của các mô hình và APIs mở rộng, một cơ chế chịu lỗi mạnh mẽ trong các ứng dụng đa-agent trở nên tối quan trọng. AgentScope tích hợp cơ chế thử lại cấp dịch vụ toàn diện để duy trì độ tin cậy API. AgentScope được trang bị một bộ công cụ sửa chữa dựa trên quy tắc để xử lý một số vấn đề định dạng rõ ràng trong phản hồi của LLMs. Hơn nữa, AgentScope cung cấp cấu hình chịu lỗi có thể tùy chỉnh, cho phép các nhà phát triển điều chỉnh cơ chế chịu lỗi của riêng họ thông qua các tham số như parse_func, fault_handler, và max_retries. Mặc dù thừa nhận, không phải tất cả lỗi đều có thể được xử lý bởi cơ chế đã nêu, chúng tôi đề xuất một hệ thống logging với các tính năng tùy chỉnh cho các ứng dụng đa-agent như biện pháp bảo vệ cuối cùng cho AgentScope.

Khả năng tương thích mở rộng cho Đa phương thức, Công cụ, và Kiến thức Bên ngoài. Với tiến bộ đáng kể của các mô hình đa phương thức quy mô lớn, AgentScope hỗ trợ dữ liệu đa phương thức (ví dụ: văn bản, hình ảnh, âm thanh, và video) trong cuộc trò chuyện hội thoại, truyền tải thông điệp, và lưu trữ dữ liệu. Cụ thể, AgentScope tách biệt truyền tải dữ liệu đa phương thức khỏi lưu trữ và sử dụng chiến lược tải lười bằng cách cung cấp thuộc tính dựa trên URL thống nhất trong thông điệp. Trong quá trình truyền tải thông điệp, AgentScope chỉ đính kèm URL vào thông điệp, và dữ liệu đa phương thức chỉ được tải khi cần thiết, chẳng hạn như khi được hiển thị trong web UI hoặc được gọi bởi các wrapper mô hình. Đối với việc sử dụng công cụ, AgentScope cung cấp một thành phần, được gọi là service toolkit, như một giải pháp một bước cho việc sử dụng công cụ, bao gồm tiền xử lý chức năng, kỹ thuật prompt, lý luận, và phân tích phản hồi với các tính năng chịu lỗi. Để hỗ trợ việc sử dụng kiến thức bên ngoài hiệu quả, AgentScope cung cấp các mô-đun xử lý kiến thức end-to-end, có thể cấu hình cao, và có thể chia sẻ cho tạo sinh tăng cường truy xuất (RAG), từ tiền xử lý dữ liệu đến truy xuất có thể tùy chỉnh.

Hiệu quả được tối ưu hóa cho hoạt động đa-agent phân tán. Nhận ra tầm quan trọng sống còn của triển khai phân tán, AgentScope giới thiệu cơ chế phân tán dựa trên actor cho phép lập trình tập trung của các quy trình làm việc phân tán phức tạp, và tối ưu hóa song song tự động. Đặc biệt, các quy trình làm việc cho triển khai cục bộ và phân tán hoàn toàn giống nhau, cho thấy chi phí không đáng kể khi di chuyển ứng dụng giữa các môi trường tập trung và phân tán. Với khung phân tán như vậy, AgentScope trao quyền cho các nhà phát triển tập trung vào thiết kế ứng dụng thay vì chi tiết triển khai.

Tóm tắt. Để tóm tắt, AgentScope, một nền tảng đa-agent mới được đề xuất cho tính linh hoạt và độ mạnh mẽ, bao gồm các tính năng tiên tiến sau:

1. AgentScope cung cấp cơ chế trao đổi thông điệp hướng quy trình với một bộ tính năng cú pháp để tạo thuận lợi cho lập trình đa-agent, một trạm làm việc lập trình kéo-thả không cần mã, và một bộ cơ chế điều chỉnh prompt tự động.

2. Các thiết kế chịu lỗi của AgentScope cho phép các nhà phát triển xử lý lỗi một cách tao nhã cho ứng dụng của họ.

3. Hỗ trợ cho các ứng dụng đa phương thức giảm chi phí tạo sinh và truyền tải dữ liệu không đồng nhất. Thành phần service toolkit tạo thuận lợi cho việc sử dụng công cụ của các agent trong AgentScope, và các mô-đun xử lý kiến thức cung cấp giải pháp linh hoạt cho các agent để xử lý thông tin khác nhau.

4. Chế độ phân tán dựa trên actor của AgentScope có thể giúp phát triển các ứng dụng đa-agent phân tán hiệu quả và đáng tin cậy một cách liền mạch.

Lộ trình. Trong các phần tiếp theo, chúng tôi điều hướng qua các thành phần cốt lõi và khả năng của AgentScope, thể hiện vai trò của nó trong việc thúc đẩy phát triển và triển khai các ứng dụng đa-agent. Phần 2 cung cấp tổng quan, trong khi Phần 3 tập trung vào trải nghiệm người dùng. Phần 4 giới thiệu cơ chế chịu lỗi trong AgentScope. Các phần 5, 6, và 7 bao gồm hỗ trợ đa phương thức, sử dụng công cụ, và các mô-đun tạo sinh tăng cường truy xuất trong AgentScope. Phần 8 trình bày hỗ trợ của nền tảng chúng tôi cho các ứng dụng đa-agent phân tán. Các trường hợp sử dụng được trình bày trong Phần 9, công trình liên quan được tóm tắt trong Phần 10, và những suy nghĩ kết luận được ghi lại trong Phần 11.

--- TRANG 4 ---

2 Tổng quan

2.1 Các khái niệm cơ bản trong AgentScope

Phần này giới thiệu các khái niệm chính trong AgentScope: message, agent, service, và workflow. Bốn khái niệm này xuyên suốt nền tảng và tất cả các ứng dụng đa-agent dựa trên nó.

• Message: Thông điệp đóng vai trò là phương tiện mang thông tin trao đổi trong các cuộc trò chuyện đa-agent, bao gồm nguồn và nội dung của thông tin. Trong AgentScope, thông điệp được triển khai như các từ điển Python với hai trường bắt buộc (name và content) và một trường tùy chọn (url). Trường name ghi lại tên của agent tạo ra thông điệp, và trường content chứa thông tin dựa trên văn bản được tạo ra bởi agent. Trường url được thiết kế để chứa Uniform Resource Locator (URL), thường liên kết đến dữ liệu đa phương thức, như hình ảnh hoặc video. Thông điệp với trường này đặc biệt phù hợp cho tương tác với các agent có thể xử lý và tạo ra nội dung đa phương thức. Mỗi thông điệp được xác định duy nhất bằng UUID và dấu thời gian được tạo tự động, đảm bảo khả năng truy vết. Ví dụ 1 cho thấy cách thông điệp có thể được tạo ra, phục vụ như các nguyên tử trong giao tiếp giữa các agent của AgentScope.

```python
from agentscope.message import Msg

msg1 = Msg("Alice", "Hello!")
msg2 = Msg(
    name="Bob",
    content="How do you find this picture I captured yesterday?",
    url="https://xxx.png"
)
```
Ví dụ 1: Các ví dụ minh họa về tạo thông điệp trong AgentScope.

• Agent: Các agent là những actor chính trong các ứng dụng đa-agent, hoạt động như những người tham gia trò chuyện và người thực hiện nhiệm vụ. Trong AgentScope, hành vi của agent được trừu tượng hóa thông qua hai giao diện: các chức năng reply và observe. Chức năng reply nhận thông điệp làm đầu vào và tạo ra phản hồi, trong khi chức năng observe xử lý thông điệp đến mà không tạo ra phản hồi trực tiếp. Sự tương tác giữa các agent và thông điệp, như được thể hiện trong Ví dụ 2, tạo thành cơ sở hoạt động của AgentScope và là thiết yếu cho các nhà phát triển mô hình hóa các tương tác phức tạp trong LLMs đa-agent.

```python
# agent1 và agent2 là hai agent đã được khởi tạo, ví dụ
# agent1, agent2 = DialogAgent(...), DialogAgent(...)
msg1 = agent1()
msg2 = agent2(msg1)
```
Ví dụ 2: Minh họa trao đổi thông điệp giữa các agent trong AgentScope.

• Workflow: Quy trình làm việc đại diện cho các chuỗi có thứ tự của việc thực thi agent và trao đổi thông điệp giữa các agent, tương tự như đồ thị tính toán trong TensorFlow, nhưng với tính linh hoạt để chứa các cấu trúc không phải DAG. Quy trình làm việc xác định luồng thông tin và xử lý nhiệm vụ giữa các agent, tạo thuận lợi cho việc thực thi song song và cải thiện hiệu quả. Khái niệm này rất cần thiết cho việc thiết kế các hệ thống đa-agent tương tác với LLMs, vì nó cho phép điều phối các nhiệm vụ phức tạp, phụ thuộc lẫn nhau.

• Chức năng Dịch vụ và Công cụ: Lưu ý rằng các chức năng dịch vụ có liên quan chặt chẽ nhưng khác với khái niệm, công cụ, trong bối cảnh thiết kế agent trong AgentScope. Chức năng dịch vụ đề cập đến các API chức năng trả về một ServiceResponse được định dạng, trong khi công cụ đề cập đến các chức năng dịch vụ đã được xử lý với mô tả chức năng và các tham số đầu vào cần thiết đã được chuẩn bị. Chúng tôi giới thiệu hai khái niệm này trong AgentScope vì LLMs cần giúp đỡ để gọi các chức năng dịch vụ như công cụ. Một quan sát là LLMs có thể cần giúp đỡ hiểu chính xác các chức năng của các chức năng dịch vụ và yêu cầu thông tin mô tả hơn để đưa ra quyết định chính xác. Đồng thời, LLMs không thể (đáng tin cậy) điền vào một số tham số đầu vào của APIs, chẳng hạn như khóa API của Bing và Google Search. Kết quả là, AgentScope định nghĩa công cụ là các chức năng dịch vụ đã được xử lý.

2.2 Kiến trúc của AgentScope

Chúng tôi trình bày AgentScope như một nền tảng cơ sở hạ tầng để tạo thuận lợi cho việc tạo ra, quản lý, và triển khai các ứng dụng đa-agent tích hợp với LLMs. Kiến trúc của AgentScope bao gồm ba lớp phân cấp và một bộ giao diện tương tác người dùng, như được thể hiện trong Hình 1. Những lớp này cung cấp hỗ trợ cho các ứng dụng đa-agent từ các cấp độ khác nhau, bao gồm các chức năng cơ bản và nâng cao của một agent đơn lẻ (lớp tiện ích), quản lý tài nguyên và thời gian chạy (lớp quản lý và wrapper), và giao diện lập trình từ cấp agent đến cấp quy trình làm việc (lớp agent). AgentScope giới thiệu các trừu tượng trực quan được thiết kế để đáp ứng các chức năng đa dạng vốn có của mỗi lớp và đơn giản hóa các phụ thuộc phức tạp giữa các lớp khi xây dựng hệ thống đa-agent. Hơn nữa, chúng tôi cung cấp giao diện lập trình và cơ chế mặc định để tăng cường khả năng chống chịu của hệ thống đa-agent chống lại lỗi trong các lớp khác nhau.

• Lớp Tiện ích: Như nền tảng của nền tảng, lớp tiện ích trong AgentScope cung cấp các dịch vụ thiết yếu để hỗ trợ các chức năng cốt lõi của agent. Lớp này trừu tượng hóa sự phức tạp của các hoạt động cơ bản, chẳng hạn như gọi API mô hình và các chức năng dịch vụ bao gồm thực thi mã và hoạt động cơ sở dữ liệu, cho phép các agent tập trung vào nhiệm vụ chính của họ. Lớp tiện ích của AgentScope được thiết kế với tính dễ sử dụng và độ mạnh mẽ là ưu tiên hàng đầu, hỗ trợ các hoạt động đa dạng trong hệ thống đa-agent và cung cấp cơ chế thử lại tự động có sẵn để xử lý ngoại lệ và lỗi chống lại sự gián đoạn bất ngờ.

• Lớp Quản lý và Wrapper: Như một trung gian, lớp trừu tượng quản lý và wrapper quản lý tài nguyên và dịch vụ API, đảm bảo tính sẵn sàng cao của tài nguyên và cung cấp khả năng chống chịu các phản hồi không mong muốn từ LLMs. Không giống như lớp tiện ích, cung cấp các trình xử lý mặc định, lớp quản lý và wrapper cũng cung cấp giao diện có thể tùy chỉnh cho kiểm soát chịu lỗi tùy thuộc vào nhu cầu của nhà phát triển và yêu cầu cụ thể của ứng dụng. Lớp này có trách nhiệm duy trì tính toàn vẹn hoạt động của các agent, một khía cạnh quan trọng để LLMs hoạt động nhất quán trong các điều kiện đa dạng. Giải thích chi tiết về các cơ chế chịu lỗi được cung cấp trong Phần 4.

• Lớp Agent: Ở cốt lõi của AgentScope nằm trừu tượng agent, tạo thành xương sống của quy trình làm việc đa-agent và là thực thể chính chịu trách nhiệm tương tác và giao tiếp. Lớp này được thiết kế để tạo thuận lợi cho việc xây dựng quy trình làm việc phức tạp và tăng cường khả năng sử dụng, giảm gánh nặng lập trình cho các nhà phát triển. Bằng cách tích hợp cú pháp và công cụ được sắp xếp hợp lý, AgentScope trao quyền cho các nhà phát triển tập trung vào việc triển khai và tối ưu hóa các ứng dụng dựa trên agent tận dụng khả năng của LLMs. Các tính năng lập trình và cú pháp đường được giới thiệu trong Phần 3 với nhiều chi tiết hơn.

• Tương tác người dùng: Ngoài kiến trúc phân lớp, AgentScope cung cấp giao diện hướng đa-agent như terminal có chú thích trình bày thông tin cơ bản, Web UI giám sát hệ thống, giao diện dựa trên Gradio (Abid et al., 2019) có thể thay đổi ứng dụng dòng lệnh thành ứng dụng đồ họa chỉ với một bước và trạm làm việc lập trình kéo-thả không cần mã (Hình 4). Những giao diện này cho phép các nhà phát triển dễ dàng giám sát trạng thái và số liệu của ứng dụng, bao gồm giao tiếp agent, thời gian thực thi, và chi phí tài chính.

Tổng thể, các cấu trúc phân lớp của AgentScope cung cấp các khối xây dựng thiết yếu cho các nhà phát triển chế tác các ứng dụng đa-agent tùy chỉnh tận dụng khả năng tiên tiến của các mô hình ngôn ngữ lớn. Phần tiếp theo sẽ đi sâu vào các tính năng của AgentScope nâng cao trải nghiệm lập trình cho việc phát triển ứng dụng đa-agent.

3 Khả năng sử dụng cao

Thiết kế của AgentScope ưu tiên khả năng sử dụng, nhằm hợp lý hóa quy trình phát triển cho đa-agent với LLMs và đảm bảo trải nghiệm tương tác mượt mà cho cả người dùng và nhà phát triển. Phần này đi sâu vào cách AgentScope làm phẳng đường cong học tập và nâng cao trải nghiệm của lập trình viên bằng cách giới thiệu các khái niệm và tính năng trực quan tạo thuận lợi cho việc tạo ra các ứng dụng đa-agent phức tạp.

3.1 Cú pháp đường cho Quy trình làm việc Đa-Agent

Tận dụng các khái niệm cơ bản được giới thiệu trong Phần 2.1, các nhà phát triển được trao quyền xây dựng các ứng dụng đa-agent tinh vi. Tuy nhiên, việc mã hóa trực tiếp trao đổi thông điệp của mỗi agent có thể trở nên cồng kềnh, như được thể hiện trong Ví dụ 3. Nhận ra điều này, AgentScope giới thiệu hai tiện ích cú pháp: pipeline và message hub, để trừu tượng hóa sự phức tạp và giảm thiểu sự lặp lại.

```python
# thiết lập agent: agent1 đến agent5
# ...

msg = agent1(Msg("Alice", "Hello!"))
msg = agent2(msg)
msg = agent3(msg)
msg = agent4(msg)
msg = agent5(msg)
```
Ví dụ 3: Ví dụ về lập trình quy trình làm việc tuần tự với các khái niệm cơ bản trong AgentScope.

Trừu tượng Pipeline. Trừu tượng pipeline giảm mã hóa lặp lại bằng cách đóng gói các mô hình truyền tải thông điệp, bao gồm trao đổi tuần tự, có điều kiện, và lặp, thành các thành phần đơn giản và có thể tái sử dụng. Với những pipeline này, các nhà phát triển có thể tập trung vào logic của tương tác agent thay vì mã boilerplate. Ví dụ 4 minh họa cách pipeline có thể được sử dụng trong cả phong cách chức năng và hướng đối tượng để tạo ra quy trình làm việc agent rõ ràng và ngắn gọn. Ngoài pipeline tuần tự trong ví dụ, AgentScope cũng cung cấp pipeline if-else, switch, while-loop, và for-loop, tạo thuận lợi cho việc lập trình tương tác đa-agent.

```python
# thiết lập agent: agent1 đến agent5
# ...
from agentscope.pipelines import SequentialPipeline
from agentscope.pipelines.functional import sequentialpipeline

# sử dụng pipeline chức năng
x = sequentialpipeline([agent1, agent2, agent3, agent4, agent5], x)

# sử dụng pipeline đối tượng
pipe = SequentialPipeline([agent1, agent2, agent3, agent4, agent5])
x = pipe(x)
```
Ví dụ 4: Sử dụng pipeline tuần tự chức năng và đối tượng để xây dựng quy trình làm việc trong AgentScope.

Message Hub cho Giao tiếp Agent. Trong hệ thống đa-agent, đặc biệt khi tích hợp với LLMs, việc quản lý hiệu quả giao tiếp giữa một nhóm agent là thiết yếu. Message hub trong AgentScope phục vụ như một cơ chế phát sóng đơn giản hóa tương tác nhóm. Các nhà phát triển có thể khởi tạo message hub bằng cách định nghĩa các agent tham gia và có thể bao gồm thông điệp phát sóng ban đầu. Khi thông điệp mới được tạo ra bởi các agent trong message hub, chúng được tự động phát tán đến những người tham gia khác, như được thể hiện trong Ví dụ 5. Trừu tượng này đặc biệt hữu ích cho các tình huống đa-agent liên quan đến LLMs, nơi các cuộc trò chuyện động và phong phú về ngữ cảnh thường được quan sát (Du et al., 2023).

```python
# thiết lập agent: agent1 đến agent4
# ...

greeting = Msg("host", "Welcome to the message hub!")

with msghub(participant=[agent1, agent2, agent3],
           announcement=greeting) as hub:
    # Thông điệp sẽ được phát sóng tự động đến agent2 và agent3
    agent1()
    
    # Xóa agent2 khỏi message hub
    hub.delete(agent2)
    
    # Thêm agent4 vào message hub
    hub.add(agent4)
    
    # Phát sóng thông điệp
    hub.broadcast(Msg("host", "Welcome agent4 to join the hub!"))
```
Ví dụ 5: Sử dụng message hub với AgentScope.

3.2 Môi trường Giàu Tài nguyên cho Phát triển Agent

Để tăng cường hơn nữa khả năng sử dụng, AgentScope được trang bị một bộ tài nguyên có sẵn phong phú, bao gồm dịch vụ, agent chuyên dụng, và ví dụ được cấu hình sẵn. Những tài nguyên này được thiết kế để giảm nỗ lực thiết lập ban đầu và cho phép tạo mẫu nhanh và triển khai hệ thống LLM đa-agent.

Tích hợp Dịch vụ Toàn diện. AgentScope tích hợp các chức năng dịch vụ khác nhau, chẳng hạn như tìm kiếm web, truy vấn cơ sở dữ liệu, và thực thi mã, để hỗ trợ khả năng sử dụng công cụ của agent. Những chức năng dịch vụ này rất cần thiết để xây dựng agent hữu ích với LLMs, vì agent thường cần rút thông tin từ các nguồn bên ngoài hoặc thực hiện nhiệm vụ vượt ra ngoài kiến thức nội bộ của LLMs được trang bị. Ví dụ 6 thể hiện việc chuyển đổi liền mạch của dịch vụ thành định dạng JSON tương thích với OpenAI, đơn giản hóa quy trình tích hợp cho các nhà phát triển.

```python
from agentscope.service import ServiceFactory, web_search

bing_search, func_json = ServiceFactory.get(web_search, engine="bing", api_key="xxx", num_results=10)

print(func_json)
# {
#  "name": "web_search",
#  "description": "Searching the given question with bing.",
#  "parameters": {
#    "type": "object",
#    "properties": {
#      "type": "object",
#      "properties": {
#        "question": {
#          "type": "string",
#          "description": "The string question to search in Bing."
#        }
#      }
#    }
#  }
# }

searching_result = bing_search("What's the date today?")
```
Ví dụ 6: Chuyển đổi dịch vụ tìm kiếm web thành định dạng chức năng và từ điển JSON mà agent có thể sử dụng.

Mẫu Agent Có sẵn. Như được liệt kê trong Bảng 1, AgentScope cung cấp các agent có sẵn và thành phần sẵn sàng sử dụng cho các nhiệm vụ như quản lý hội thoại, đại diện người dùng, xử lý dữ liệu đa phương thức, và triển khai phân tán. Những mẫu này phục vụ như điểm khởi đầu cho các nhà phát triển tùy chỉnh và mở rộng, tăng tốc đáng kể việc phát triển các ứng dụng LLM đa-agent.

| Tên Agent | Chức năng |
|-----------|-----------|
| UserAgent | Đại diện của người dùng. |
| DialogAgent | Agent hội thoại chung, vai trò có thể được thiết lập bằng prompt hệ thống. |
| DictDialogAgent | Agent hội thoại phiên bản từ điển, phản hồi ở định dạng từ điển Python. |
| ReActAgent | Agent có thể lý luận và sử dụng công cụ |
| ProgrammerAgent | Agent có thể viết và thực thi mã Python. |
| TextToImageAgent | Agent tạo ra hình ảnh theo yêu cầu. |
| RpcUserAgent | Phiên bản phân tán của đại diện người dùng. |
| RpcDialogAgent | Phiên bản phân tán của DialogAgent. |

Bảng 1: Một số ví dụ về agent có sẵn và chức năng của chúng trong AgentScope.

3.3 Giao diện Trình diễn Hướng Đa-Agent

Hơn nữa, AgentScope giới thiệu giao diện tương tác được điều chỉnh cho hệ thống đa-agent, như được minh họa trong Hình 2 và 3. Những giao diện này cung cấp trải nghiệm đa phương thức phong phú, quan trọng cho hệ thống kết hợp LLMs xử lý các loại dữ liệu đa dạng.

Phân biệt Agent trong Giao diện Người dùng. Để tạo thuận lợi cho tương tác người dùng với nhiều agent, AgentScope gán màu sắc và biểu tượng duy nhất cho mỗi agent, tăng cường sự rõ ràng và phân biệt trực quan trong cả terminal và web UI (Hình 3). Tính năng "góc nhìn người thứ nhất" cho phép người dùng trải nghiệm tương tác từ quan điểm của một agent được chỉ định, phù hợp với vai trò của họ trong ứng dụng, chẳng hạn như trong tình huống trò chơi. Tính năng này không chỉ làm phong phú trải nghiệm đa-agent mà còn phản ánh các tương tác tinh tế xảy ra trong hội thoại người-agent và agent-agent trong hệ thống LLM.

Giám sát và Quản lý Chi phí. Một khía cạnh quan trọng của việc triển khai LLMs ở quy mô lớn là quản lý tài nguyên. AgentScope bao gồm một mô-đun giám sát theo dõi việc sử dụng mô hình và API, cũng như tính toán chi phí tài chính. Các nhà phát triển có thể tùy chỉnh số liệu và đặt giới hạn ngân sách, nhận cảnh báo tự động khi ngưỡng được tiếp cận hoặc vượt quá. Quản lý chi phí chủ động này đặc biệt quan trọng đối với LLMs có thể phát sinh chi phí tính toán cao.

Giao diện Gradio của AgentScope. Khi bạn có một ứng dụng đa-agent, thực thi nó trong terminal có thể là lựa chọn ngắn gọn nhưng thiếu sức hút. Trong AgentScope, chúng tôi cung cấp giao diện mạnh mẽ dựa trên Gradio tương thích với tất cả ứng dụng AgentScope miễn là có hàm main như điểm nhập của ứng dụng. Ví dụ, nếu hàm main của ứng dụng nằm trong tệp application.py, thì chạy "as_studio application.py" có thể xây dựng ứng dụng Gradio với giao diện người dùng đồ họa và hỗ trợ tải lên và trình bày nội dung đa phương thức.

3.4 Hướng tới Phát triển Ứng dụng Đồ họa

Thiết kế đã đề cập ở trên cung cấp sự tiện lợi to lớn cho những người quen thuộc với lập trình Python để nhanh chóng phát triển ứng dụng đa-agent của họ. Tuy nhiên, AgentScope đi xa hơn một bước. AgentScope cung cấp trạm làm việc trực tuyến kéo-thả nơi các nhà phát triển chỉ cần kéo các khối mô-đun để tạo thành ứng dụng; sau đó, trạm làm việc có thể tạo ra tệp cấu hình của ứng dụng ở định dạng JSON hoặc thậm chí một đoạn mã Python. Với tính năng này, những người có kinh nghiệm hạn chế với lập trình Python có thể xây dựng ứng dụng đa-agent mà không cần viết bất kỳ mã Python nào, trong khi những người quen thuộc với Python có thể ngay lập tức có được một đoạn mã bản thảo sẵn sàng để tùy chỉnh thêm. Ảnh chụp màn hình của trạm làm việc trực tuyến được thể hiện trong Hình 4, và ý tưởng hỗ trợ việc triển khai này được minh họa như sau.

Biểu diễn ứng dụng Đa-agent với các nút trong đồ thị có hướng không chu trình (DAG). Dựa trên thiết kế mô-đun hóa cao của cơ sở hạ tầng cơ bản, tất cả các thành phần chính có thể được biểu diễn như một nút, và một ứng dụng có thể được xây dựng bằng cách xây dựng đồ thị chu trình có hướng (DAG). Việc thực thi ứng dụng tương đương với việc kích hoạt và chạy các nút trong đồ thị theo thứ tự duyệt của DAG. Theo các thuật ngữ truyền thống, chúng tôi đặt tên việc thực thi DAG như vậy là quy trình làm việc và đặt tên các nút trong quy trình làm việc là các nút quy trình làm việc. Theo chức năng của chúng, các nút quy trình làm việc được phân loại thành sáu loại khác nhau: nút mô hình, nút agent, nút pipeline, nút dịch vụ và nút sao chép.

• Nút Mô hình: Nút mô hình được thiết kế tương đối độc lập với DAG. Chúng tương ứng với các cấu hình mô hình trong AgentScope và hoạt động như các điểm nhập để cho phép người dùng cấu hình mô hình của họ (LLMs, mô hình embedding, hoặc mô hình đa phương thức) và duy trì thông tin như vậy cho tất cả các nút trong quy trình làm việc tiếp theo cần sử dụng mô hình.

• Nút Dịch vụ (công cụ): Những nút này tương ứng với các dịch vụ có sẵn trong AgentScope. Một số trong số chúng yêu cầu thông tin bổ sung để thiết lập, chẳng hạn như Google search và Bing search, yêu cầu khóa API; những nút khác có thể được sử dụng trực tiếp.

• Nút Agent: Như tên gọi, nút agent đại diện cho các agent trong AgentScope, có nghĩa là người dùng cần quyết định mô hình, tên agent và prompt hệ thống cho agent.

• Nút Pipeline: Nút pipeline bao gồm các toán tử của AgentScope, bao gồm message hub và các pipeline (tuần tự, for-loop, while-loop, v.v.). Với những nút như vậy, biểu diễn DAG có thể ngắn gọn như lập trình Python.

• Nút Message: Nút message được thiết kế cho các trường hợp cần một số thông điệp ban đầu, chẳng hạn như thông báo (thông điệp ban đầu) cho message hub.

• Nút Copy: Nút copy là một loại nút đặc biệt nhân bản kết quả của nút cha khi đầu ra của nó cần thiết cho nhiều hoạt động tiếp theo.

Thực thi DAG với JSON hoặc biên dịch thành Python. Với các nút trên, các nhà phát triển có thể xây dựng ứng dụng bằng cách tạo thành DAG. Tuy nhiên, DAG phụ thuộc cao vào UI. Mặc dù DAG có thể được biểu diễn ở một số định dạng (ví dụ: định dạng JSON ghi lại thông tin của mỗi nút và phụ thuộc thực thi), chúng tôi vẫn cần đảm bảo nó có thể tái sử dụng như các ứng dụng khác. Để khắc phục điều này, AgentScope được trang bị cấu trúc dữ liệu gọi là ASDiGraph, cung cấp hai giải pháp dựa trên nó.

• Direct-run: Cho một tệp JSON ghi lại thông tin DAG, ASDiGraph có thể phân tích thông tin DAG và sắp xếp các nút theo thứ tự tô-pô. Với những nút được sắp xếp này, hàm run của ASDiGraph có thể thực thi chúng theo thứ tự và cung cấp đầu ra của người tiền nhiệm cho người kế nhiệm khi ứng dụng được thực thi từng bước.

• Trình biên dịch To-Python: Giải pháp thứ hai là dịch tệp JSON thành script Python. Với các thành phần được mô-đun hóa cao của AgentScope, ý tưởng chính là dựa vào ánh xạ nội bộ của chức năng, đầu vào yêu cầu, và đầu ra mong đợi thành các đoạn mã Python nhỏ. Cụ thể, mỗi nút chứa mã Python để nhập các mô-đun phụ thuộc, khởi tạo mô hình hoặc agent, và thực thi logic ứng dụng. ASDiGraph đầu tiên nhóm các đoạn mã nhập và mã khởi tạo, và sau đó nó tạo thành các đoạn mã thực thi theo thứ tự tô-pô. Do đó, người dùng sẽ có được script Python hoàn chỉnh sau khi ASDiGraph hoàn thành biên dịch.

3.5 Điều chỉnh Prompt Tự động

Đối với hệ thống đa-agent sử dụng LLMs để tạo sinh, viết prompt phù hợp đòi hỏi nỗ lực và chuyên môn đáng kể của con người (Pryzant et al., 2023), điều này thúc đẩy chúng tôi cung cấp tạo sinh và điều chỉnh prompt tự động trong AgentScope cho khả năng sử dụng cao. Cụ thể, AgentScope cho phép người dùng tạo prompt dựa trên mô tả đơn giản của agent bằng ngôn ngữ tự nhiên, cập nhật prompt theo ngữ cảnh, và cho phép học trong ngữ cảnh.

Điều chỉnh System Prompt. Khi một agent được tạo ra, một system prompt nên được liên kết với agent để xác định vai trò và trách nhiệm của nó trong việc tuân theo hướng dẫn của con người. Ví dụ, một Programmer Agent có thể được nhắc như "You are proficient in writing and executing Python code". Đồng thời, một system prompt chi tiết và có thông tin có thể cải thiện hiệu suất agent và đảm bảo agent hoạt động như mong đợi, chẳng hạn như "You are proficient in writing and executing Python code. You prefer to write the code in a modular fashion and provide unit tests for each module". Với AgentScope, người dùng chỉ cần cung cấp mô tả đơn giản của agent khi tạo agent, và AgentScope có thể tự động tạo ra những system prompt hữu ích như vậy bằng cách sử dụng công cụ có sẵn dựa trên LLMs, như được thể hiện trong Ví dụ 7.

```python
# thiết lập agent với tạo prompt tự động
# ...
from agentscope.agents import ProgrammerAgent

# Load cấu hình mô hình
agentscope.init(model_configs="model_configs.json")

# Tạo programmer agent
programmer_agent = ProgrammerAgent(name="assistant", auto_sys_prompt=True,
                                  model_config_name="my_config",
                                  sys_prompt="an assistant that can write Python code")
```
Ví dụ 7: Khởi tạo programmer agent với tạo system prompt tự động.

Ngoài ra, AgentScope cung cấp giao diện cho cập nhật system prompt, bao gồm thiết lập thủ công bởi người dùng hoặc điều chỉnh tự động dựa trên ngữ cảnh. Như một hướng nghiên cứu hứa hẹn trong tương lai, các kỹ thuật meta-prompting (Pryzant et al., 2023; Suzgun và Kalai, 2024) cũng có thể được tích hợp vào AgentScope, có thể liên quan đến việc tích hợp một evaluator để cung cấp hướng dẫn cho tối ưu hóa prompt tự động.

Học trong Ngữ cảnh. Cung cấp nhiều minh họa cho LLMs có thể tăng cường đáng kể khả năng tuân theo hướng dẫn của chúng, đặc biệt khi chúng ta muốn chúng hoàn thành các nhiệm vụ downstream cụ thể (Dai et al., 2023; Wei et al., 2022). AgentScope cung cấp một công tắc đơn giản để bật/tắt hành vi học trong ngữ cảnh cho các agent sử dụng LLMs. Khi người dùng chọn áp dụng học trong ngữ cảnh, họ chỉ cần cung cấp các ứng viên minh họa và cấu hình cách khớp những cái phù hợp nhất, như được minh họa trong Ví dụ 8. AgentScope cung cấp một số phương pháp khớp được sử dụng rộng rãi và hữu ích, chẳng hạn như lựa chọn ngẫu nhiên, câu hỏi tương tự, và câu trả lời tương tự, và cho phép tùy chỉnh người dùng.

```python
# thiết lập agent với học trong ngữ cảnh
# ...
from agentscope.agents import ReActAgent
from agentscope.utils.common import load_demo_data

# Load cấu hình mô hình
agentscope.init(model_configs="model_configs.json")

# Load minh họa
react_pairs = load_demo_data("my_demos.txt")

# Tạo reAct agent
react_agent = ReActAgent(name="react_agent", enable_icl=True,
                        demos=react_pairs, matching_approach="random")
```
Ví dụ 8: Bật học trong ngữ cảnh khi tạo agent.

4 Cơ chế Chịu lỗi

Trong lĩnh vực hệ thống đa-agent, đặc biệt là những hệ thống giao tiếp với các LLMs mã nguồn mở đa dạng với khả năng tuân theo hướng dẫn khác nhau, chịu lỗi là một thuộc tính chính để đảm bảo hoạt động liền mạch. AgentScope được thiết kế để tự động xử lý nhiều loại lỗi với sự can thiệp tối thiểu của con người, dựa vào cơ sở hạ tầng chịu lỗi toàn diện nhận thức rõ về sự phức tạp liên quan đến điều phối đa-agent và phụ thuộc LLM.

Phân loại Lỗi và Chiến lược Xử lý. Cách tiếp cận của chúng tôi bắt đầu với phân loại có phương pháp các lỗi thành các cấp độ riêng biệt, mỗi cấp với chiến lược xử lý được điều chỉnh:

• Lỗi khả năng tiếp cận: Trong AgentScope, các chức năng của agent dựa vào các loại dịch vụ khác nhau, nhưng những dịch vụ đó có thể chịu lỗi tạm thời không thể tiếp cận. Những lỗi này có thể được gây ra bởi sự bất ổn của mô hình hoặc điều kiện mạng. Ví dụ, các API mô hình có thể trả về lỗi timeout khi có tắc nghẽn giao thông trong giờ cao điểm, hoặc cơ sở dữ liệu trên máy từ xa có thể không thể tiếp cận vì sự cố mạng tạm thời.

• Lỗi có thể giải quyết bằng quy tắc: Vì nhiều ứng dụng đa-agent yêu cầu trao đổi thông tin giữa các dịch vụ hoặc agent, việc tuân theo giao thức cho những giao tiếp đó là thiết yếu, ví dụ: ở định dạng JSON. Tuy nhiên, vì phản hồi của LLMs chưa thể kiểm soát hoàn toàn, kết quả trả về của chúng có thể không tuân theo định dạng yêu cầu trong prompt. Ví dụ, chúng ta có thể mong đợi phản hồi từ LLM ở dạng JSON, nhưng thiếu dấu ngoặc nhọn phải ở cuối kết quả trả về, dẫn đến lỗi phân tích. Vì định dạng JSON có thông số kỹ thuật rõ ràng, việc giả định rằng một tập con của những lỗi này có thể được giải quyết bằng cách sửa chữa định dạng theo quy tắc để đáp ứng thông số kỹ thuật là hợp lý.

• Lỗi có thể giải quyết bằng mô hình: Khi hệ thống đa-agent xử lý một số nhiệm vụ phức tạp, khả năng của agent để hiểu đầu vào, đưa ra quyết định, và cung cấp đầu ra chủ yếu phụ thuộc vào khả năng của LLMs. Trong một số trường hợp, phản hồi của LLMs ở định dạng mong đợi, nhưng nội dung có vấn đề, chẳng hạn như lỗi đối số, lỗi ngữ nghĩa, hoặc lỗi lập trình. Khó có quy tắc định trước để chuẩn hóa những phản hồi đó cho các nhiệm vụ đa dạng, nhưng cũng đã được chứng minh rằng những lỗi như vậy có thể được phát hiện và khôi phục bằng tương tác thêm với LLMs.

• Lỗi không thể giải quyết: Cuối cùng, chắc chắn phải có một số lỗi không thể được phát hiện hoặc giải quyết. Một ví dụ điển hình là khóa API của LLM đã hết hạn hoặc không được ủy quyền. Các agent dựa vào nó hoặc hệ thống không thể làm gì để giải quyết những lỗi như vậy mà không có sự can thiệp của con người.

Cơ chế Chịu lỗi trong AgentScope. Trong AgentScope, chúng tôi cung cấp các cơ chế khác nhau để đối phó với các lỗi được tóm tắt ở trên.

• Cơ chế thử lại tự động cơ bản: Để chống lại lỗi khả năng tiếp cận, các dịch vụ API và wrapper mô hình của AgentScope được củng cố bằng logic thử lại mà các nhà phát triển có thể tùy chỉnh, chẳng hạn như đặt số lần thử lại tối đa. Điều này đảm bảo rằng các agent có thể hồi phục từ sự gián đoạn rải rác và duy trì tính liên tục hoạt động của chúng.

• Công cụ sửa chữa dựa trên quy tắc: Các công cụ sửa chữa dựa trên quy tắc được giới thiệu vào AgentScope để xử lý hiệu quả và tiết kiệm một số lỗi định dạng dễ sửa trong phản hồi của LLMs. Ví dụ, chúng tôi thiết lập một bộ quy tắc mặc định trong AgentScope có thể hoàn thành các dấu ngoặc không khớp và trích xuất dữ liệu JSON từ chuỗi. Những công cụ sửa chữa dựa trên quy tắc như vậy có thể sửa chữa một số lỗi có thể giải quyết bằng quy tắc phổ biến mà không gọi API LLM lại, có nghĩa là thời gian xử lý ngắn hơn và không có chi phí gọi API LLM.

• Trình xử lý lỗi có thể tùy chỉnh: AgentScope cũng tích hợp giao diện linh hoạt của trình xử lý lỗi trong wrapper mô hình để các nhà phát triển định nghĩa cách phân tích phản hồi từ LLMs và xử lý đầu ra bất ngờ. Các nhà phát triển ứng dụng có thể cấu hình cơ chế xử lý lỗi của họ bằng cách cung cấp hàm phân tích, hàm xử lý lỗi, và số cơ hội được đưa cho LLMs thông qua các tham số có thể cấu hình (tức là parse_func và fault_handler và max_retries) khi gọi LLMs. Với thiết kế thân thiện với nhà phát triển như vậy, AgentScope có thể được cấu hình mạnh mẽ để chống lại lỗi có thể giải quyết bằng quy tắc (khi các quy tắc có sẵn không xử lý được) và một số lỗi có thể giải quyết bằng mô hình có thể được phát hiện và xử lý bởi một agent đơn lẻ (ví dụ: chưng cất tóm tắt dài dòng thành tóm tắt ngắn gọn hơn).

• Xử lý lỗi cấp agent: Có những lỗi có thể giải quyết bằng mô hình yêu cầu việc sử dụng LLM nâng cao hơn hoặc tương tác cấp agent để khôi phục. Ví dụ, phát hiện lỗi ngữ nghĩa, thường bao gồm sự không chính xác về sự thật, sự không nhất quán logic, sự không liên kết ngữ cảnh, suy luận không hợp lý, và việc sử dụng từ vựng không phù hợp, là thách thức vì chúng có thể không nhất thiết kích hoạt cờ đỏ ngay lập tức trong các quy trình xác thực hiện có của hệ thống. Các nhà phát triển có thể sử dụng khả năng của agent trong AgentScope (ví dụ: mô-đun bộ nhớ và message hub) để phê bình cho việc kiểm tra lỗi ngữ nghĩa như tự phê bình, phê bình theo cặp, và phê bình tăng cường con người.

• Hệ thống logging: Mặc dù các lỗi không thể giải quyết quá khó khăn để hệ thống xử lý, AgentScope cung cấp hệ thống logging được cải thiện để các nhà phát triển nhanh chóng giám sát và xác định vấn đề trong ứng dụng đa-agent. Hệ thống logging trong AgentScope có các tính năng tùy chỉnh cho các tình huống ứng dụng đa-agent, bao gồm thêm cấp độ logging được gọi là CHAT để logging cuộc trò chuyện giữa các agent, cung cấp log được định dạng với thông tin thực thi khác nhau, và giao diện người dùng WebUI để tạo thuận lợi cho giám sát.

5 Ứng dụng Đa phương thức

Việc tích hợp dữ liệu đa phương thức là không thể thiếu để thúc đẩy khả năng và ứng dụng của đa-agent với LLMs. AgentScope được thiết kế để hỗ trợ liền mạch các phương thức dữ liệu khác nhau, tận dụng các đầu vào và đầu ra đa dạng mà LLMs đương đại có thể xử lý và tạo ra.

Quản lý Dữ liệu Đa phương thức. Trong một ứng dụng AgentScope đang chạy, chu kỳ sống của dữ liệu đa phương thức được quản lý cẩn thận. Việc quản lý này bao gồm tạo sinh, truyền tải, và lưu trữ dữ liệu đa phương thức—tất cả được tạo thuận lợi thông qua kiến trúc tách biệt sử dụng URLs và hệ thống quản lý tệp cục bộ. Hình 5 minh họa quy trình này, bao gồm dữ liệu xuất phát từ đầu vào của người dùng hoặc tạo sinh mô hình, lưu trữ và truy xuất dữ liệu, và chia sẻ dữ liệu.

• Tạo sinh dữ liệu đa phương thức: Có hai nguồn chính của dữ liệu đa phương thức trong AgentScope. Một nguồn đơn giản là các tệp đa phương thức được lưu trữ cục bộ, có thể được sử dụng bởi các agent đại diện người dùng hoặc agent chung có quyền truy cập vào hệ thống tệp cục bộ. Nguồn khác là các mô hình tạo sinh nội dung mô-đun phương thức. API mô hình và wrapper mô hình của chúng tôi tích hợp các mô hình đa phương thức phổ biến nhất, chẳng hạn như các mô hình tạo sinh nội dung text-to-image như DALL-E của OpenAI, và ngược lại, các mô hình phân tích hình ảnh image-to-text, ví dụ: GPT-4V. Ngoài các API có sẵn, các nhà phát triển có thể giới thiệu các mô hình đa phương thức yêu thích của họ và tùy chỉnh wrapper mô hình riêng, với các ví dụ sẵn sàng sử dụng của chúng tôi như điểm khởi đầu. Quy trình tùy chỉnh này được hợp lý hóa trong AgentScope và hưởng lợi từ thiết kế mô-đun của chúng tôi, cho phép các nhà phát triển kết nối dịch vụ đa phương thức của họ với nỗ lực tối thiểu.

• Lưu trữ dữ liệu đa phương thức: Như đã đề cập ở trên, dữ liệu đa phương thức trong ứng dụng đa-agent có thể từ các tệp cục bộ sẵn sàng sử dụng hoặc được tạo ra bởi các mô hình đa phương thức. Khi wrapper mô hình đa phương thức được gọi để tạo ra dữ liệu đa phương thức, nó đầu tiên lưu dữ liệu cục bộ với sự giúp đỡ của trình quản lý tệp và trả về URL cục bộ khi nhận dữ liệu đa phương thức từ dịch vụ API mô hình.

• Truyền tải dữ liệu đa phương thức: AgentScope đơn giản hóa quy trình chia sẻ dữ liệu đa phương thức giữa các agent bằng cách cho phép các agent đóng gói URLs cục bộ hoặc từ xa trong thông điệp đa phương thức để chỉ ra vị trí lưu trữ thực tế của dữ liệu. Các agent nhận có thể tải dữ liệu đa phương thức thông qua URLs khi sẵn sàng xử lý những dữ liệu đó.

Lợi ích của việc giới thiệu URLs trong thông điệp khi các agent chia sẻ dữ liệu đa phương thức có ba khía cạnh. Thứ nhất, nó có thể giảm thiểu kích thước thông điệp để tránh lỗi hoặc chậm trễ tiềm năng do băng thông mạng và cho phép agent nhận tải dữ liệu theo yêu cầu. Thứ hai, nếu có thông tin văn bản khác trong thông điệp, các agent downstream có thể ưu tiên hoặc song song xử lý thông tin văn bản với/và xử lý thông tin đa phương thức. Cuối cùng nhưng không kém phần quan trọng, những thông điệp đính kèm URL như vậy cũng có thể tạo thuận lợi cho việc trình diễn dữ liệu đa phương thức, sẽ được giới thiệu trong phần tiếp theo.

Chế độ Tương tác Đa phương thức. Với việc triển khai thông điệp đính kèm URL, AgentScope trao quyền cho người dùng tương tác với hệ thống đa phương thức thông qua giao diện có thể tiếp cận như terminal và web UI. Hình 3 thể hiện khả năng của người dùng tương tác với dữ liệu đa phương thức trong các chế độ tương tác. Trong terminal, người dùng có thể dễ dàng truy cập dữ liệu được lưu trữ cục bộ bằng cách kích hoạt URLs được cung cấp. Web UI tiến thêm một bước nữa trong việc nâng cao trải nghiệm người dùng bằng cách cung cấp nền tảng trực quan để xem và phân tích nội dung đa phương thức, phù hợp với kỳ vọng của các ứng dụng web hiện đại.

Thông qua AgentScope, các nhà phát triển được trang bị để điều chỉnh dịch vụ API mô hình và wrapper theo nhu cầu cá nhân của họ, tạo ra các ứng dụng xử lý các phương thức dữ liệu đa dạng, và cung cấp cho người dùng các công cụ cần thiết để tương tác hiệu quả với các agent đa phương thức. Hỗ trợ toàn diện này cho các ứng dụng đa phương thức định vị AgentScope như một khung làm việc linh hoạt và mạnh mẽ để khai thác toàn bộ tiềm năng của LLMs đa-agent, mở rộng tầm nhìn cho các nhà phát triển và nhà nghiên cứu trong việc tạo ra các hệ thống AI tinh vi và tương tác.

6 Sử dụng Công cụ

Việc sử dụng công cụ là một tính năng quan trọng cho các agent được trao quyền bởi LLM, cho phép các agent cảm nhận, thay đổi môi trường của họ, và xử lý các nhiệm vụ phức tạp hơn (Wu et al., 2023; Paranjape et al., 2023; Parisi et al., 2022). Để đơn giản, chúng tôi coi việc sử dụng công cụ tương đương với việc gọi các chức năng dịch vụ bởi LLMs. Trong AgentScope, mô-đun sử dụng công cụ được thiết kế dựa trên thuật toán ReAct (Yao et al., 2023), cho phép tạo ra lý luận và hành động cụ thể nhiệm vụ xen kẽ, cùng với một thành phần cốt lõi—service toolkit. Thiết kế như vậy có tính tương thích cao, khả năng mở rộng, độ mạnh mẽ, và tái sử dụng, kéo dài từ tiền xử lý chức năng, kỹ thuật prompt, lý luận, và phân tích phản hồi đến chịu lỗi cấp agent. Cụ thể, trong AgentScope việc sử dụng công cụ bao gồm bốn bước:

• Chuẩn bị Chức năng: Phân tích các chức năng dịch vụ được cung cấp, và tiền xử lý các chức năng để LLMs có thể sử dụng chúng trực tiếp.

• Chuẩn bị Hướng dẫn: Chuẩn bị prompt hướng dẫn cho việc sử dụng công cụ để giải thích chi tiết các chức năng công cụ có sẵn cho LLMs, bao gồm mục đích, đối số, ràng buộc của chức năng, và định dạng gọi của nó.

• Lý luận Lặp: LLMs tạo ra lý luận chiến lược, đưa ra quyết định cho việc sử dụng công cụ, và phản hồi ở định dạng yêu cầu.

• Hành động Lặp: Phân tích và kiểm tra phản hồi LLM theo định dạng gọi, gọi chức năng nếu phản hồi tuân theo định dạng mong đợi, hoặc tạo ra thông báo lỗi chi tiết cho LLMs để sửa chữa.

Trong quy trình trên, mô-đun service toolkit chịu trách nhiệm quản lý chức năng công cụ, tiền xử lý, kỹ thuật prompt, phân tích phản hồi, và thực thi chức năng, và nó có tính mô-đun cao và khả năng mở rộng. Hình 6 minh họa cách service toolkit hoạt động trong AgentScope khi người dùng đăng truy vấn.

Chuẩn bị Chức năng. Trong chuẩn bị chức năng, mục tiêu là thiết lập trước các đối số cụ thể của nhà phát triển, và tạo ra các chức năng sẵn sàng sử dụng và mô tả được định dạng tương ứng cho LLMs. Trong AgentScope, các nhà phát triển chỉ cần đăng ký chức năng của họ với các đối số được thiết lập trước trong service toolkit. Như được thể hiện trong Hình 6, các nhà phát triển chọn chức năng Bing search và cung cấp khóa API trong quá trình đăng ký. Sau đó service toolkit sẽ tự động tạo ra chức năng sẵn sàng sử dụng đã được xử lý và mô tả của nó ở định dạng JSON schema. Các mô tả sẽ được sử dụng để tạo ra hướng dẫn công cụ bằng ngôn ngữ tự nhiên. Tùy chọn, một số API mô hình (ví dụ: OpenAI và DashScope Chat API, v.v.) có thể nhận mô tả JSON schema trực tiếp, mà chúng tôi sẽ thảo luận trong Phần 6.1.

Chuẩn bị Hướng dẫn. Đối với các nhà phát triển mới, service toolkit xây dựng trong các mẫu cho hướng dẫn công cụ và định dạng gọi cho việc sử dụng công cụ, như được thể hiện trong Hình 6. Mẫu hướng dẫn công cụ liệt kê mỗi chức năng với mô tả rõ ràng và các tham số nó yêu cầu, dẫn đến sự hiểu biết dễ dàng về chức năng của chúng. Mặt khác, định dạng gọi, như được thể hiện trong Hình 6, yêu cầu một từ điển JSON trong khối mã được đánh dấu Markdown với các trường thought, speak, và function. Trong quá trình tạo sinh LLM, chúng ta mong đợi trường thought sẽ cung cấp quy trình lý luận cho hành động tiếp theo, bao gồm phân tích tình huống hiện tại, lựa chọn chức năng ứng viên, và sửa chữa lỗi.

Lý luận Lặp. Trong AgentScope các bước lý luận và hành động là lặp. Như đã nêu ở trên, trong bước lý luận LLMs nên phân tích tình huống hiện tại và quyết định các hành động tiếp theo. Các nhà phát triển chỉ cần xây dựng prompt với hướng dẫn công cụ và hướng dẫn định dạng gọi và đưa chúng vào LLMs. Thiết kế như vậy cung cấp tính tái sử dụng và linh hoạt cao, tức là service toolkit độc lập với nhiệm vụ và có thể được điều chỉnh cho các nhiệm vụ và tình huống khác nhau rất dễ dàng.

Hành động Lặp. Trong bước hành động, service toolkit sẽ phân tích phản hồi LLM theo định dạng gọi, trích xuất chức năng được chọn, và thực thi nó với các đối số tương ứng. Nếu phản hồi tuân theo yêu cầu định dạng, và chức năng thực thi thành công, service toolkit sẽ trả về kết quả thực thi trực tiếp, mà LLM có thể tạo ra phản hồi dựa trên trong bước lý luận tiếp theo. Ngược lại, chúng tôi phân chia lỗi thành lỗi phân tích phản hồi, lỗi thực thi chức năng, và lỗi thời gian chạy khác. Đối với lỗi phân tích phản hồi và lỗi thực thi chức năng, chúng tôi tiết lộ chúng cho LLM với thông tin lỗi chi tiết để sửa chữa trong lần lặp lý luận-hành động tiếp theo, để lại các lỗi thời gian chạy khác cho các nhà phát triển.

6.1 Tùy chỉnh cho Nhà phát triển Có kinh nghiệm

AgentScope hỗ trợ các nhà phát triển tùy chỉnh cao hướng dẫn công cụ và định dạng gọi chức năng của họ. Để tùy chỉnh hướng dẫn công cụ, service toolkit trong AgentScope cung cấp mô tả JSON schema tự động, cung cấp cách có cấu trúc để giải thích chi tiết cách một chức năng nên được gọi, bao gồm tên, mục đích, đối số, và các chi tiết liên quan khác của nó. Những mô tả được định dạng này có thể được đưa trực tiếp vào một số API mô hình tiên tiến, ví dụ: OpenAI và DashScope Chat APIs. Đối với người dùng muốn tùy chỉnh sâu hướng dẫn công cụ của họ, họ có thể xây dựng hướng dẫn dựa trên mô tả JSON schema.

Ngoài hướng dẫn công cụ, AgentScope cũng cung cấp tính linh hoạt lớn, tức là AgentScope cung cấp các parser phản hồi mô hình khác nhau, bao gồm khối mã được đánh dấu Markdown, khối mã đối tượng JSON, và nội dung được gắn thẻ có thể tùy chỉnh, như được thể hiện trong Hình 7. Đối với người dùng muốn tùy chỉnh định dạng gọi chức năng, khối mã được đánh dấu Markdown và khối mã đối tượng JSON cho phép họ nhanh chóng xây dựng hướng dẫn định dạng và phân tích phản hồi LLM theo loại nội dung. Đối với người dùng muốn có được nhiều trường từ LLMs, nội dung được gắn thẻ đa cho phép các nhà phát triển kết hợp các nội dung được gắn thẻ khác nhau theo ý muốn và trích xuất chúng dễ dàng từ phản hồi thành từ điển Python. Với những parser này, các nhà phát triển có thể tùy chỉnh định dạng gọi riêng của họ một cách dễ dàng.

7 Agent với Tạo sinh Tăng cường Truy xuất

Với các ứng dụng ngày càng tăng của LLMs, một số trường hợp yêu cầu kiến thức không được chứa trong bộ dữ liệu huấn luyện, ví dụ: kiến thức trong các lĩnh vực chuyên môn cao hoặc không có sẵn công khai. Ngay cả khi có các bộ dữ liệu yêu cầu, việc tinh chỉnh hoặc huấn luyện lại LLMs vẫn đắt đỏ. Theo đó, tạo sinh tăng cường truy xuất (RAG), một cách tiếp cận sáng tạo nhằm tăng cường sức mạnh của LLMs trong lĩnh vực kiến thức tùy chỉnh (Gao et al., 2023; Lewis et al., 2020b), đang nhận được sự chú ý ngày càng tăng trong văn học.

Phương pháp luận của RAG có thể được coi là chèn một bước tiền xử lý vào pipeline sử dụng phổ biến của LLMs. Tức là, cho một tập hợp tài liệu chứa kiến thức cần thiết, một chỉ mục dựa trên độ tương tự được xây dựng, và đầu vào người dùng gốc được nén với những phần thông tin liên quan nhất và chuyển đổi thành prompt, sau đó được đưa vào LLMs. Do đó, phương pháp luận của RAG bao gồm nhiều giai đoạn, tức là thu thập tài liệu chứa thông tin cần thiết, phân đoạn tài liệu, lập chỉ mục các đoạn (còn gọi là chunk hoặc node), truy xuất chỉ mục dựa trên độ tương tự, hợp nhất truy vấn gốc (tức là đầu vào người dùng) và kết quả được truy xuất, tạo thành prompt, và cuối cùng, tạo ra phản hồi hợp lý từ LLM dựa trên prompt có thông tin.

Tóm lại, RAG kết hợp cả sức mạnh của truy xuất thông tin và khả năng tạo sinh của LLMs, và cung cấp dịch vụ LLM nâng cao với kiến thức lĩnh vực tùy chỉnh với chi phí thấp. Đồng thời, được hỗ trợ bởi RAG, ảo giác có thể được tránh và độ chính xác sự thật có thể được cải thiện đáng kể.

Như một nền tảng đa-agent hướng nhà phát triển, AgentScope cung cấp hỗ trợ RAG toàn diện cho các ứng dụng đa-agent. Cho các khung RAG phổ biến như ví dụ: LlamaIndex (Liu, 2022), LangChain (Langchain-AI, 2023), v.v., AgentScope được thiết kế với các quy trình trừu tượng có tính linh hoạt cao để tương thích với những khung đó. Trong phần tiếp theo, chúng tôi giới thiệu một số tính năng chính của AgentScope RAG.

Cấu hình Một Điểm Dừng. Do sự phức tạp của pipeline làm việc, việc cấu hình dịch vụ RAG rất phức tạp và thường gây đau đầu cho người dùng. Trong khi dịch vụ RAG được cung cấp bởi AgentScope là toàn diện và cũng bao gồm quy trình làm việc đa-agent, AgentScope cung cấp giải pháp cấu hình một điểm dừng đơn giản bằng cách sử dụng một tệp .json duy nhất để nhóm tất cả cấu hình liên quan đến RAG.

Với giao diện cấu hình có hệ thống cao này, người dùng chỉ cần tập trung vào việc xây dựng quy trình làm việc, mà không bị phân tâm bởi các cấu hình lặp đi lặp lại. Ví dụ, các agent được trao quyền RAG có thể bao gồm một tập hợp rộng lớn các cơ sở kiến thức cần được cấu hình chi tiết. Với tính năng "Một Điểm Dừng" này, các điều chỉnh tương ứng của các mô-đun (có thể dẫn đến hiệu suất khác nhau) được tích hợp như việc chỉnh sửa chỉ đơn giản một tệp duy nhất. Hơn nữa, giải pháp này cũng tự nhiên thích ứng với AgentScope Workstation, trong đó cấu hình dựa trên hộp thoại có thể dễ dàng được xuất ra các tệp có thể thực thi và sau đó được tải trong các chương trình Python.

Quản lý Dữ liệu Hướng Kiến thức. Việc áp dụng RAG trong hoàn cảnh đa-agent phức tạp hơn so với việc áp dụng trên một agent đơn lẻ. Ví dụ, đối với một agent đơn lẻ, người ta có thể trực tiếp đóng gói kiến thức cần thiết cho agent. Do đó, việc khởi tạo mỗi agent RAG bao gồm toàn bộ pipeline chuyển đổi từ tài liệu gốc sang chỉ mục được lưu trữ vector với retriever. Tuy nhiên, trong các ứng dụng đa-agent, việc các agent chia sẻ kiến thức là tự nhiên, do đó việc thực thi tính toán chỉ mục lặp đi lặp lại cho mỗi agent là không cần thiết. Do đó, AgentScope giới thiệu khái niệm knowledge bank.

Knowledge bank có thể được coi là một tập hợp các container kiến thức, nơi đơn vị có thể quản lý nhỏ nhất là một đối tượng tùy chỉnh (sẽ được gọi là "đối tượng RAG" trong bối cảnh tiếp theo). Quy trình làm việc bắt đầu với việc khởi tạo knowledge bank, chủ yếu dựa vào thông tin chứa trong tệp cấu hình .json. Thông tin bao gồm thư mục và phần mở rộng (chẳng hạn như .py hoặc .md) của tài liệu, độ chi tiết và lựa chọn công cụ phân đoạn (ví dụ: splitter trong Llama-Index) cho tài liệu, và lựa chọn mô hình để lập chỉ mục. Sau khi khởi tạo, kết quả tính toán được lưu trữ vào thư mục được chỉ định để sử dụng sau này và chúng ta cũng có được knowledge bank bao gồm các đối tượng RAG, mỗi cái được đánh dấu với knowledge_id duy nhất, liên kết với chỉ mục của tài liệu tương ứng, một information retriever, và các thuộc tính khác. Lưu ý rằng AgentScope cho phép mỗi agent RAG tải với nhiều hơn một đối tượng RAG.

Agent với RAG. Việc áp dụng agent với RAG trong AgentScope rất đơn giản. Ví dụ, trước tiên chúng ta cần khởi tạo KnowledgeBank với một số khung RAG, ví dụ: LlamaIndex, và tất cả tài liệu. Sau đó, chúng ta cấu hình agent RAG và tải nó với knowledge bank. Sau đó, việc khởi tạo hoàn tất và chúng ta có thể sử dụng agent RAG như bất kỳ agent nào khác trong AgentScope. Đáng chú ý rằng nếu KnowledgeBank được có được với khung LlamaIndex, thì chúng ta cần sử dụng LlamaIndexAgent (được kế thừa từ RAGAgentBase). Độc giả có thể tham khảo Phần 9.5 cho một mẫu ứng dụng cụ thể, triển khai copilot cho AgentScope sử dụng agent RAG của chúng tôi. Nhìn chung, các tính năng chính của agent RAG được tóm tắt như sau:

• Agent RAG được phép tải một số đối tượng RAG (tức là bất kỳ tập con nào của knowledge bank). Người ta có thể chọn tải các đối tượng RAG gốc từ knowledge bank (trong trường hợp như vậy, việc sửa đổi đối tượng có thể ảnh hưởng đến tất cả agent sử dụng nó) hoặc một bản sao của nó.

• Trong khi các agent được khởi tạo với đối tượng KnowledgeBank, các agent được phép cập nhật kiến thức theo thời gian. Các hoạt động bao gồm chèn, xóa, hoặc thay thế các phần kiến thức. Hơn nữa, chúng tôi cung cấp giải pháp bằng cách giám sát các thư mục nhất định và giữ cho đối tượng RAG được cập nhật với nội dung trong các thư mục.

• Cơ chế hợp nhất của kết quả được truy xuất từ nhiều đối tượng RAG hoàn toàn có thể tùy chỉnh. Ví dụ, vì kiến thức có thể có tầm quan trọng hoặc độ tin cậy khác nhau, agent có thể đặt trọng số cho thông tin được truy xuất từ các đối tượng RAG khác nhau cho các quy trình tiếp theo.

• Agent RAG được phép tái cấu trúc truy vấn trong các lần lặp có thể cấu hình và tiến hành nhiều truy vấn để có câu trả lời toàn diện hơn.

8 Khung Phân tán Dựa trên Actor

Hiệu quả và khả năng mở rộng là thiết yếu khi xây dựng các ứng dụng cấp công nghiệp trên hệ thống đa-agent. Tốc độ suy luận của các agent trong ứng dụng đa-agent có thể thay đổi đáng kể. Ví dụ, giả sử một agent trong ứng dụng đa phương thức sử dụng mô hình text-to-video. Trong trường hợp đó, thời gian phản hồi của nó có thể dài hơn đáng kể so với agent được thiết kế để điền chi tiết câu chuyện. Song song hóa, như một ý tưởng kinh điển, nên được giới thiệu để tăng hiệu quả. Ngoài ra, các ứng dụng đa-agent có thể bao gồm các agent được phân phối vật lý trên các máy khác nhau. Một trường hợp sử dụng điển hình là một công ty có thể bọc các kỹ thuật được cấp bằng sáng chế hoặc cơ sở kiến thức riêng tư của họ thành một agent trên máy cục bộ của họ được kết nối với internet và cung cấp dịch vụ tự động cho các thực thể khác thông qua tương tác agent.

Tuy nhiên, khi nói đến hệ thống đa-agent, một thách thức là các nhà phát triển cần đưa ra quyết định giữa hai cặp lộ trình công nghệ sau. Vì không có bữa trưa miễn phí, bất kỳ sự kết hợp nào cũng có lợi ích và nhược điểm của chúng.

• Điều phối tập trung v.s. phi tập trung. Trong bối cảnh hệ thống phân tán, điều phối tập trung có nghĩa là nhiều nút tính toán được quản lý bởi một nút trung tâm, chẳng hạn như mô hình máy chủ-khách hàng. Cơ chế đa-agent với điều phối tập trung có nghĩa là việc thực thi các agent được lên lịch bởi, và thông điệp giữa các agent được chuyển tiếp bởi một thành phần điều phối trung tâm. Ngược lại, điều phối phi tập trung không dựa vào bất kỳ thành phần trung tâm nào để lên lịch hoặc chuyển tiếp thông điệp, nhưng các agent trong hệ thống như vậy có thể được gọi tự động và gửi thông điệp trực tiếp đến các agent downstream để xử lý thêm.

Trong khi điều phối tập trung là phong cách đơn giản có thể được hiểu và dễ gỡ lỗi, nhược điểm của nó bao gồm dễ bị lỗi nút trung tâm, áp đặt lưu lượng nặng lên nút trung tâm, và khó khăn trong việc mở rộng hoặc mở rộng đến các ứng dụng phức tạp. Ngược lại, điều phối phi tập trung có thể yêu cầu nỗ lực thêm để phát triển và duy trì nhưng có độ mạnh mẽ cao hơn chống lại lỗi của bất kỳ nút đơn lẻ nào.

• Thiết kế quy trình làm việc tĩnh vs. động. Một so sánh tương tự có thể được tìm thấy giữa đồ thị tính toán tĩnh được sử dụng trong các phiên bản đầu của TensorFlow (Abadi et al., 2016) và đồ thị tính toán động được sử dụng trong PyTorch Paszke et al. (2019). Trong bối cảnh ứng dụng đa-agent, việc lựa chọn giữa quy trình làm việc tĩnh và động tương tự như việc chọn giữa thực thi được biên dịch trước và thông dịch. Thiết kế quy trình làm việc tĩnh có thể cho phép tối ưu hóa cấp độ đồ thị quy trình làm việc cho thời gian chạy và phân bổ tài nguyên. Tuy nhiên, thiết kế quy trình làm việc tĩnh yêu cầu đồ thị quy trình làm việc phải được biết trước khi thực thi, điều này hạn chế việc thích ứng vào ứng dụng, đặc biệt là những ứng dụng có cấu trúc vòng lặp trong thiết kế. Ngược lại, quy trình làm việc động cung cấp tính linh hoạt lớn hơn với chi phí của tiềm năng tối ưu hóa. Điều này đặc biệt liên quan khi xử lý các mô hình ngôn ngữ lớn nơi đường dẫn thực thi có thể thay đổi dựa trên dữ liệu đầu vào hoặc kết quả suy luận mô hình.

Chế độ phân tán trong AgentScope. AgentScope cân bằng những lộ trình công nghệ này bằng cách triển khai chế độ phân tán dựa trên actor có tính đến nhu cầu độc đáo của hệ thống LLM đa-agent, với các tính năng quan trọng sau:

• Tối ưu hóa song song tự động mà không có đồ thị tĩnh. AgentScope tận dụng mô hình actor để cho phép tối ưu hóa song song tự động, cho phép các nhà phát triển tránh được sự phức tạp của lập trình đồ thị tĩnh. Cách tiếp cận này liền mạch phù hợp với bản chất động và thường không thể dự đoán của LLMs, nơi đồ thị tính toán có thể thay đổi dựa trên ngữ cảnh phát triển và trạng thái hội thoại.

• Lập trình quy trình làm việc với độ phức tạp tối thiểu. Trái ngược với các mô hình actor truyền thống và triển khai peer-to-peer (P2P) yêu cầu thứ tự thực thi phức tạp cho các agent phân tán, AgentScope đơn giản hóa lập trình quy trình làm việc thành một phong cách quy trình đơn lẻ trong hàm Python. Thiết kế này làm phẳng đáng kể đường cong học tập cho các nhà phát triển, làm cho việc xây dựng LLMs đa-agent tinh vi trở nên dễ tiếp cận hơn.

• Hỗ trợ agent cục bộ và phân tán kết hợp. Tính linh hoạt của AgentScope mở rộng để hỗ trợ chế độ kết hợp nơi một số agent hoạt động cục bộ trong khi những agent khác được phân tán. Tính năng này đặc biệt có lợi khi tích hợp LLMs với yêu cầu tính toán khác nhau, cho phép các mô hình tốn tài nguyên được phân tán trong khi các agent ít đòi hỏi vẫn ở cục bộ, tất cả mà không cần nhà phát triển phân biệt giữa hai trong quá trình triển khai.

Cụ thể, chúng ta có thể mô tả ngắn gọn cách AgentScope kết hợp mô hình actor như sau. Trong khung khái niệm này, một "actor" hoạt động như một thực thể độc lập xử lý tính toán khi nhận được tất cả thông điệp cần thiết. Mô hình này đảm bảo rằng mỗi agent, tương ứng với một actor, chỉ tham gia vào tính toán khi thông điệp đầu vào yêu cầu đã sẵn sàng, do đó đạt được tối ưu hóa song song tự động.

Tuy nhiên, quy trình làm việc dựa trên mô hình actor đưa ra thách thức lập trình: việc truyền biến (tức là thông điệp) giữa các actor (tức là agent) có thể là placeholder mà không có ý nghĩa thực tế nào ở đầu. Để giảm nhẹ điều này, AgentScope giới thiệu "placeholder" message, một cấu trúc dữ liệu mới cho phép quy trình chính tiếp tục mà không bị chặn, trong khi bảo tồn thông tin cần thiết để truy xuất giá trị thực sau này (Hình 8). Cơ chế này đặc biệt có lợi cho hệ thống LLM đa-agent, nơi luồng thực thi phải thích ứng với đầu ra biến đổi của mô hình ngôn ngữ.

```python
# thiết lập agent phân tán: agent1
...

input_msg = Msg("system", "Which agent should respond next, agent2 or agent3?")

# biến choice là một placeholder
choice: placeholder = host_agent(input_msg)

if choice["content"] == "agent2":
    response = agent2()
elif choice["content"] == "agent3":
    response = agent3()
```
Ví dụ 9: Minh họa việc sử dụng placeholder trong luồng điều khiển trong AgentScope.

Một loạt thách thức khác phát sinh khi placeholder được sử dụng trong các câu lệnh luồng điều khiển (ví dụ: if-else, vòng lặp) mà không có giá trị thực của chúng. Một ví dụ được thể hiện trong Ví dụ 9, nơi một placeholder được yêu cầu để đưa ra quyết định. Trong những trường hợp này, AgentScope tạm thời chặn quy trình để truy xuất giá trị thực tế của nó, do đó đảm bảo tính liên tục của luồng điều khiển.

Chế độ phân tán dựa trên actor trong AgentScope không chỉ cung cấp tối ưu hóa song song tự động và đơn giản hóa trải nghiệm nhà phát triển mà còn thể hiện hiệu quả cao cho các ứng dụng LLM đa-agent phân tán. Nó cho phép các nhà phát triển tập trung vào triển khai logic agent, đặc biệt là chức năng "reply", mà không quan tâm đến sự phức tạp phân tán cơ bản. Cách tiếp cận hợp lý này đối với hệ thống đa-agent phân tán có thể thúc đẩy lĩnh vực LLMs bằng cách làm cho việc phát triển, chạy và gỡ lỗi các kiến trúc đa-agent tinh vi và có thể mở rộng trở nên dễ dàng hơn.

Triển khai một cú nhấp chuột trong AgentScope. Để tiến thêm một bước trong việc tạo thuận lợi cho triển khai phân tán, AgentScope cung cấp máy chủ agent và trung tâm thông điệp thống nhất, có tên là AgentScope Studio.

Cụ thể, máy chủ agent được giữ trong các máy từ xa, nhận yêu cầu từ ứng dụng AgentScope, và khởi tạo các agent yêu cầu của họ trong máy được triển khai tự động. Điều đó có nghĩa là, các nhà phát triển có thể thiết lập các instance agent từ xa, mà không cần lập trình trong các máy khác nhau. Tính năng như vậy cung cấp tính linh hoạt cao, đặc biệt cho các mô phỏng quy mô lớn, nơi số lượng lớn instance agent sẽ được thiết lập trong các máy từ xa.

Đối với AgentScope Studio, nó cung cấp giao diện hiển thị thống nhất cho các ứng dụng đa-agent phân tán, nơi thông điệp từ tất cả agent phân tán sẽ được thu thập và hiển thị trong studio này, và cho phép các nhà phát triển chuyển tiếp những thông điệp này đến giao diện hiển thị riêng của họ. Ngoài ra, AgentScope studio hỗ trợ quản lý máy chủ agent, tức là trong studio này các nhà phát triển có thể kiểm tra việc triển khai agent phân tán, mở hoặc đóng máy chủ agent từ xa. Với studio này, các nhà phát triển có thể quản lý ứng dụng của họ dễ dàng hơn nhiều.

9 Ứng dụng Đặc trưng của AgentScope

Như đã giới thiệu trong các phần trước, AgentScope là một nền tảng đa-agent được thiết kế tỉ mỉ để tích hợp và điều phối các mô hình quy mô lớn một cách thân thiện với người dùng và chịu lỗi, và nó là một nền tảng lý tưởng cho một phổ ứng dụng rộng lớn. AgentScope có thể triển khai các ứng dụng trải dài từ hội thoại đơn giản agent đơn lẻ với người dùng đến trò chơi nhập vai tương tác nhiều người chơi phức tạp như werewolf. Hơn nữa, ngoài triển khai tập trung, AgentScope có thể mở rộng đến các cuộc trò chuyện phân tán bao gồm hoạt động song song trên nhiều máy. Trong phần này, chúng tôi xem xét một số ứng dụng đặc trưng của AgentScope thuyết phục minh họa khả năng xuất sắc và đa dạng của khung làm việc. Tất cả ví dụ được tham chiếu ở đây đều có thể truy cập trong kho GitHub của chúng tôi để cộng đồng sử dụng và đóng góp.

9.1 Dialog Agent: Cuộc trò chuyện Cơ bản

Ứng dụng đơn giản nhưng cơ bản nhất của AgentScope là cuộc trò chuyện cơ bản, nơi người dùng tương tác trực tiếp với dialog agent. Ứng dụng này là điểm khởi đầu tuyệt vời cho người dùng mới của AgentScope để nhanh chóng nắm bắt cơ chế truyền thông điệp cốt lõi trong khung làm việc của chúng tôi.

Ví dụ cuộc trò chuyện cơ bản thể hiện việc sử dụng hai agent có sẵn cơ bản trong AgentScope, UserAgent và DialogAgent, tạo thuận lợi cho đầu vào từ người dùng và phản hồi từ LLMs, tương ứng. Thông thường, như được minh họa trong Ví dụ 10, bước đầu tiên của tất cả ứng dụng là khởi tạo, là tải cấu hình mô hình (được chỉ định trong tệp model_configs.json) thông qua giao diện init của AgentScope, gán các agent được trao quyền LLM với các mô hình được chọn. Hiện tại, AgentScope tương thích với nhiều nền tảng và APIs khác nhau, bao gồm nhưng không giới hạn ở OpenAI chat/embedding/DALL-E tiêu chuẩn, HuggingFace, ModelScope, và một tập hợp các mô hình được lưu trữ cục bộ với FastChat, vllm, và Flask. Hơn nữa, giao diện init cũng chỉ định các tùy chọn chi tiết như lưu trữ tệp, logging, cấu hình agent, v.v. Với tất cả cấu hình được thiết lập, nó đã sẵn sàng để xây dựng luồng trò chuyện, tức là cơ chế trao đổi thông điệp giữa người dùng/agent, là khối xây dựng thiết yếu cho tất cả ứng dụng dựa trên agent. Trong quy trình làm việc này, AI agent sẽ luôn phản hồi đầu vào của người dùng, cuộc trò chuyện có thể tạo thành vòng lặp vô tận cho đến khi người dùng quyết định thoát.

Để triển khai các ứng dụng tinh vi hơn, AgentScope tạo thuận lợi cho pipeline, cung cấp khung làm việc có cấu trúc tốt và có thể mở rộng cho tương tác agent phức tạp (về mặt thông điệp). Như được minh họa trong Ví dụ 11, chúng ta có thể triển khai ví dụ cuộc trò chuyện cơ bản với pipeline tuần tự hoặc pipeline vòng lặp. Độc giả cũng có thể tham khảo Phụ lục A cho lịch sử cuộc trò chuyện khi chạy mã demo.

9.2 Dialog Agent: Cuộc trò chuyện Nhóm với Mentions

Ngoài cuộc trò chuyện cơ bản giữa người dùng và dialog agent đơn lẻ, AgentScope hỗ trợ cuộc trò chuyện nhóm. Để cải thiện tính tương tác, chúng tôi giới thiệu tính năng "mentions", cho phép người dùng hoặc agent gọi một agent cụ thể bằng cách đơn giản "@ agent_name". Tính năng "mention" được hỗ trợ bằng cách áp dụng chức năng filter_agents, lọc thông điệp và xác định xem có agent nào được đề cập trong nội dung thông điệp hay không.

Trong ví dụ này, chúng tôi đầu tiên khởi tạo các agent tham gia vào cuộc trò chuyện như được thể hiện trong Ví dụ 12. Ở đây, đặc điểm của các agent có thể được tùy chỉnh trong tệp agent_config.json, ví dụ: sử dụng sys_prompt để tùy chỉnh phong cách phản ứng hoặc chức năng của các agent. Ngoài ra, chúng tôi sử dụng message hub (msghub) để tạo thuận lợi cho việc chuyển giao thông điệp giữa một nhóm agent. Msghub cho phép chia sẻ thông tin công khai (ví dụ: thông báo) và cho phép các agent phát sóng thông điệp đến tất cả agent. Cuộc trò chuyện sẽ kết thúc nếu đạt giới hạn timeout, hoặc người dùng gõ "exit".

```python
import agentscope
from agentscope.agents import DialogAgent, UserAgent

# đọc cấu hình mô hình
agentscope.init(model_configs="./openai_model_configs.json")

# Tạo dialog agent và user agent
assistant_agent = DialogAgent(
    name="Assistant",
    sys_prompt="You are a helpful assistant",
    model="gpt-4"
)
user_agent = UserAgent()

# Phiên bản cơ bản
x = None
while x is None or x.content != "exit":
    x = assistant_agent(x)
    x = user_agent(x)
```
Ví dụ 10: Ví dụ mã của ví dụ cuộc trò chuyện cơ bản.

```python
# Phiên bản nâng cao với sequential pipeline
from agentscope.pipelines.functional import sequentialpipeline
x = None
while x is None or x.content != "exit":
    x = sequentialpipeline([dialog_agent, user_agent], x)

# Phiên bản nâng cao với while loop pipeline
from agentscope.pipelines.functional import whilelooppipeline
x = whilelooppipeline(
    [assistant_agent, user_agent],
    condition_func=lambda _, x: x is None or x.content != "exit",
    x=None)
```
Ví dụ 11: Triển khai dựa trên pipeline của ví dụ cuộc trò chuyện cơ bản.

9.3 Dialog Agent: Trò chơi Werewolf

Cuộc trò chuyện nhóm và tính năng mention là các khối xây dựng cơ bản cho ứng dụng đa-agent. Ở đây chúng tôi trình bày một ứng dụng tinh vi hơn, trò chơi werewolf, là một trò chơi nhập vai tương tác nhiều người chơi phổ biến. Chúng tôi nhằm triển khai trò chơi với AgentScope chỉ trong một trăm dòng mã. Ví dụ này bao gồm sáu người chơi được chia thành hai đội đối lập, werewolves và villages. Sau nhiều vòng trò chuyện và thảo luận, trò chơi kết thúc khi tất cả werewolves bị loại bỏ (tức là chiến thắng của villager) hoặc số lượng werewolves bằng hoặc nhiều hơn villagers (tức là chiến thắng của werewolf).

Như một trò chơi nhập vai được trao quyền LLM, chúng tôi bắt đầu thiết lập trò chơi với phân bổ cho các vai trò và khởi tạo cho các agent. Như được thể hiện trong Ví dụ 13, AgentScope hỗ trợ thiết lập nhanh, bao gồm cấu hình agent mặc định cho người dùng khởi tạo các đối tượng agent với các vai trò tương ứng trong một cú nhấp chuột, các thiết lập chi tiết được bao gồm trong tệp agent_configs.json.

Đáng chú ý rằng trò chơi werewolf dựa trên khả năng cuộc trò chuyện nhóm của AgentScope, do đó các werewolves có thể trò chuyện trong "giai đoạn đêm" và tất cả những người tham gia có thể thảo luận trong "giai đoạn ngày". Tương tự như ví dụ cuộc trò chuyện nhóm, message hub (msghub) của AgentScope được sử dụng để tạo thuận lợi cho các cuộc trò chuyện. Như được thể hiện trong Ví dụ 13, sau khi host (người điều khiển) đưa ra thông báo, các werewolves thảo luận tối đa MAX_WEREWOLF_DISCUSSION_ROUND vòng và kết luận khi đạt được thỏa thuận. Ở đây, các agent được yêu cầu sử dụng thuộc tính "agreement" trong thông điệp phản hồi, được thực thi trong prompt định nghĩa vai trò. Để có quy trình làm việc hoàn chỉnh, ví dụ về lịch sử hội thoại, và thông tin liên quan khác, vui lòng tham khảo Phụ lục B.

```python
import agentscope

# Đọc cấu hình mô hình và agent, và khởi tạo agent tự động
npc_agents = agentscope.init(
    model_configs="./configs/model_configs.json",
    agent_configs="./configs/agent_configs.json",
)
user = UserAgent()
agent = list(npc_agents) + [user]
...
# Chúng tôi sử dụng msghub để điều phối các cuộc trò chuyện, 'hint' là thông điệp được thông báo đến tất cả agent
with msghub(agents, announcement=hint):
    while True:
        try:
            x = user(timeout=USER_TIME_TO_SPEAK)
            if x.content == "exit":
                break
        except TimeoutError:
            x = {"content": ""}
            logger.info(
                f"User has not typed text for "
                f"{USER_TIME_TO_SPEAK} seconds, skip.",
            )
        # nếu người dùng đề cập bất kỳ npc_agent nào trong thông điệp, nó sẽ được thêm vào speak_list
        speak_list += filter_agents(x.get("content", ""), npc_agents)

        # nếu speak_list không rỗng, các agent được đề cập sẽ phản hồi theo cách tuần tự
        if len(speak_list) > 0:
            next_agent = speak_list.pop(0)
            x = next_agent()
        # ngược lại, tất cả agent sẽ phản hồi từng cái một.
        else:
            next_agent = select_next_one(npc_agents, rnd)
            x = next_agent()
        # nếu phản hồi đề cập bất kỳ agent nào, nó sẽ được thêm vào speak_list
        speak_list += filter_agents(x.content, npc_agents)
```
Ví dụ 12: Ví dụ mã của cuộc trò chuyện nhóm.

```python
import agentscope
# Đọc cấu hình mô hình và agent, và khởi tạo agent tự động
survivors = agentscope.init(
    model_configs="./configs/model_configs.json",
    agent_configs="./configs/agent_configs.json",
)

# Định nghĩa các vai trò trong trò chơi.
roles = ["werewolf", "werewolf", "villager", "villager", "seer", "witch"]

# Dựa trên vai trò của họ, gán các agent đã được khởi tạo cho các biến.
wolves, villagers, witch, seer = survivors[:2], survivors[2:-2], survivors[-1], survivors[-2]
...
# Giai đoạn đêm: werewolves thảo luận
hint = HostMsg(content=Prompts.to_wolves.format(n2s(wolves)))
with msghub(wolves, announcement=hint) as hub:
    ...
    for _ in range(MAX_WEREWOLF_DISCUSSION_ROUND):
        x = sequentialpipeline(wolves)
        if x.agreement:
            break
    ...
```
Ví dụ 13: Ví dụ mã của trò chơi werewolf.

9.4 Agent Triển khai Phân tán

Chúng ta đã thấy các ứng dụng về cuộc trò chuyện liên quan đến dialog agent, nhưng những ví dụ đó cơ bản theo nghĩa là các agent được triển khai theo cách tập trung, tức là các agent được lưu trữ trên một máy đơn lẻ và trong một quy trình đơn lẻ. Để cho phép các agent được lưu trữ bởi các máy hoặc quy trình riêng biệt, AgentScope cho phép các agent được triển khai phân tán trong hai chế độ, chế độ đa quy trình máy đơn lẻ, và chế độ đa quy trình đa máy. Trong phần tiếp theo, chúng tôi trình bày ví dụ để thể hiện tính năng này.

Chế độ Đa Quy trình Máy Đơn lẻ: Đối với chế độ này, tất cả agent được triển khai trên một máy đơn lẻ, nhưng chạy trong các quy trình riêng biệt. Để so sánh tốt hơn, chúng tôi triển khai ví dụ cuộc trò chuyện cơ bản trong chế độ này (xem Ví dụ 14 cho mã hoàn chỉnh). So với Ví dụ 10 và 11, chúng tôi sử dụng chức năng to_dist để chuyển đổi instance agent hiện tại thành phiên bản phân tán. Sau đó, assistant_agent sẽ được triển khai trên localhost với cổng được phân bổ tự động. Ngoài những khác biệt đã đề cập, chế độ đa quy trình máy đơn lẻ giống hệt với triển khai cục bộ, nhưng nó đã được tối ưu hóa cho thực thi song song.

Chế độ Đa Quy trình Đa Máy: Để thể hiện chế độ này, chúng tôi khởi tạo dịch vụ agent (một DialogAgent) trên máy từ xa (như được thể hiện trong Ví dụ 15), và xây dựng quy trình làm việc (như được thể hiện trong Ví dụ 16). Người ta có thể lưu ý rằng sự khác biệt duy nhất so với chế độ triển khai cục bộ là máy chủ agent cần được kết nối bằng URLs và cổng được chỉ định trước khi thiết lập quy trình làm việc.

Nhìn chung, đối với AgentScope, chúng ta có thể chuyển đổi mượt mà từ chế độ triển khai cục bộ sang chế độ phân tán và ngược lại, chỉ với những thay đổi tối thiểu đối với cấu hình agent và không cần sửa đổi quy trình làm việc.

```python
from agentscope.agents import UserAgent, DialogAgent
import agentscope
# chúng ta sử dụng .to_dist() để chuyển đổi agent sang chế độ phân tán.
assistant_agent = DialogAgent(
    name="Assistant",
    sys_prompt="You are a helpful assistant",
    model="gpt-4"
).to_dist()
user_agent = UserAgent()

x = None
while x is None or not x.content != "exit":
    x = sequentialpipeline([assistant_agent, user_agent], x)
```
Ví dụ 14: Ví dụ triển khai agent trong chế độ đa quy trình máy đơn lẻ.

```python
from agentscope.agents.rpc_agent import RpcAgentServerLauncher
from agentscope.agents import DialogAgent

# tải cấu hình mô hình
agentscope.init(model_configs="configs/model_configs.json")
# thiết lập máy chủ cho agent từ xa
server_launcher = RpcAgentServerLauncher(
    agent_class=DialogAgent,
    agent_kwargs={
        "name": "Assistant",
        "sys_prompt": "You are a helpful assistant.",
        "model": "gpt-4"
    },
    host="xxx.xxx.xxx.xxx",
    port=12010,
)
# khởi động máy chủ
server_launcher.launch()
server_launcher.wait_until_terminate()
```
Ví dụ 15: Triển khai agent từ xa trong chế độ đa quy trình đa máy.

```python
agentscope.init(model_configs="configs/model_configs.json")

assistant_agent = DialogAgent(
    name="Assistant",
    model="gpt-4"
).to_dist(
    host="xxx.xxx.xxx.xxx",  # URL đích của máy chủ agent
    port=12010,  # Cổng đích của máy chủ agent
    launch_server=False,  # Sử dụng máy chủ agent từ xa
)
user_agent = UserAgent()

x = None
while x is None or not x.content != "exit":
    x = sequentialpipeline([assistant_agent, user_agent], x)
```
Ví dụ 16: Ví dụ thiết lập quy trình phụ cho agent trong chế độ đa quy trình đa máy.

9.5 Agent RAG: AgentScope Copilot

Như đã giới thiệu trước đó trong Phần 7, Tạo sinh Tăng cường Truy xuất (RAG) cho phép các nhà phát triển tận dụng đầy đủ khả năng tạo sinh ngôn ngữ của LLMs kèm theo bể kiến thức tùy chỉnh. Theo đó, AgentScope giới thiệu agent RAG để tạo thuận lợi cho chức năng như vậy. Trong ví dụ tiếp theo (như được thể hiện trong Ví dụ 17), chúng tôi thể hiện cách sử dụng một tập hợp agent RAG dựa trên Llama-index (tức là LlamaIndexAgent được kế thừa từ RAGAgentBase) để xây dựng copilot đa-agent cho AgentScope.

Chúng tôi đầu tiên khởi tạo các agent. Lưu ý rằng tính năng quan trọng nhất của agent RAG là ngoài tính cách tùy chỉnh và phong cách hành vi được cấu hình bởi system prompt, mỗi agent được tải với kiến thức bên ngoài, được chỉ định trong agent_configs chứa thông tin cấu hình như thư mục lưu trữ dữ liệu, loại tệp đích, thiết lập chunking tài liệu, thiết lập indexing và embedding, v.v.

Quy trình làm việc của copilot được thiết kế như sau, người dùng đầu tiên nhập thông điệp, và nếu người dùng đề cập một số agent RAG cụ thể như chúng ta định nghĩa, thì các agent tương ứng sẽ phản hồi, ngược lại, guide_agent sẽ quyết định agent phù hợp nhất để phản hồi truy vấn. Do giới hạn không gian, chúng tôi chỉ thể hiện mã đơn giản hóa ở đây và vui lòng tham khảo repository và tài liệu để biết thêm chi tiết.

```python
import agentscope
from agentscope.agents import UserAgent, DialogAgent, LlamaIndexAgent
...
# khởi tạo agentscope với cấu hình mô hình
agentscope.init(model_configs="configs/model_configs.json")

# khởi tạo agent RAG dựa trên các cấu hình khác nhau
tutorial_agent = LlamaIndexAgent(**agent_configs[0]["args"])
code_agent = LlamaIndexAgent(**agent_configs[1]["args"])
api_agent = LlamaIndexAgent(**agent_configs[2]["args"])
search_agent = LlamaIndexAgent(**agent_configs[3]["args"])
...
# khởi tạo dialog agent cơ bản như "trợ lý tiền sảnh" và user agent
guide_agent = DialogAgent(**agent_configs[4]["args"])
user_agent = UserAgent()
...
while True:
    x = user_agent()
    # quy trình làm việc kết thúc khi người dùng không nhập gì hoặc "exit"
    if len(x["content"]) == 0 or str(x["content"]).startswith("exit"):
        break
    # tìm ra các agent được đề cập trong đầu vào của người dùng
    speak_list = filter_agents(x.get("content", ""), rag_agent_list)
    if len(speak_list) == 0:
        # nếu không có agent nào được đề cập, guide agent sẽ quyết định gọi agent nào
        guide_response = guide_agent(x)
        speak_list = filter_agents(
            guide_response.get("content", ""),
            rag_agent_list,
        )
    # các agent được gọi bởi guide agent sẽ được ghi lại
    agent_name_list = [agent.name for agent in speak_list]
    # các agent được liệt kê phản hồi truy vấn lần lượt
    for agent_name, agent in zip(agent_name_list, speak_list):
        if agent_name in rag_agent_names:
            agent(x)
```
Ví dụ 17: Ví dụ sử dụng agent RAG để xây dựng copilot cho AgentScope.

9.6 Agent Tìm kiếm Web và Truy xuất

Chúng ta đã thấy ví dụ về agent tạo ra phản hồi bằng khả năng của LLM (DialogAgent) và thông tin được truy xuất từ thư viện kiến thức bên ngoài (LlamaIndexAgent). Tuy nhiên, chúng ta cũng có thể sử dụng tài nguyên internet để xây dựng agent, như được giới thiệu trong ví dụ tiếp theo.

Như được trình bày trong Ví dụ 18, việc khởi tạo bao gồm ba loại agent - UserAgent nhận đầu vào người dùng, SearcherAgent chuyển đổi câu hỏi của người dùng thành từ khóa và gọi công cụ tìm kiếm để truy xuất trang web từ internet, và AnswererAgent truy xuất thông tin từ trang web để soạn câu trả lời.

Đáng chú ý rằng, vì số lượng lớn trang web có thể được trả về bởi agent tìm kiếm. Trong chế độ quy trình đơn lẻ tiêu chuẩn, nhiều instance AnswererAgent chỉ có thể thực hiện tìm kiếm web và trả lời câu hỏi theo cách tuần tự trên một máy đơn lẻ. Để có hiệu quả tốt hơn, việc cho phép nhiều instance của AnswererAgent chạy song song là có lợi, tức là chế độ đa quy trình đa máy của agent AgentScope.

```python
import agentscope
from searcher_agent import SearcherAgent
from answerer_agent import AnswererAgent
from agentscope.agents.user_agent import UserAgent

agentscope.init(model_configs="configs/model_configs.json")

# chúng ta có thể thực hiện nhiều tìm kiếm cùng một lúc
WORKER_NUM = 3
searcher = SearcherAgent(
    name="Searcher",
    model_config_name="my_model",
    result_num=args.num_workers,
    search_engine_type=args.search_engine,
    api_key=args.api_key,
    cse_id=args.cse_id,
)
# khởi tạo các answerer agent
answerers = []
for i in range(args.num_workers):
    answerer = AnswererAgent(
        name=f"Answerer-{i}",
        model_config_name="my_model",
    )
    # nếu chúng ta muốn đặt agent trong chế độ phân tán (song song)
    if args.use_dist:
        answerer = answerer.to_dist(lazy_launch=False)
    answerers.append(answerer)
user_agent = UserAgent()

msg = user_agent()
while not msg.content == "exit":
    msg = searcher(msg)
    results = []
    for page, worker in zip(msg.content, answerers):
        results.append(worker(Msg(**page)))
    for result in results:
        logger.chat(result)
    msg = user_agent()
```
Ví dụ 18: Ví dụ sử dụng agent tìm kiếm web và truy xuất.

9.7 Agent ReAct: Chuyển đổi Ngôn ngữ Tự nhiên thành Truy vấn SQL

Natural Language to SQL query (NL2SQL) là một nhiệm vụ kinh điển nhưng đầy thách thức trong cả cộng đồng cơ sở dữ liệu và xử lý ngôn ngữ tự nhiên, nhằm chuyển đổi câu hỏi đầu vào của con người bằng ngôn ngữ tự nhiên thành truy vấn SQL. Trong cộng đồng nghiên cứu, có một tập hợp công trình khám phá tiềm năng của LLMs trong NL2SQL, và sẽ rất thú vị để khám phá nhiệm vụ này với agent được trao quyền LLM.

Trong AgentScope, chúng tôi cung cấp một lớp agent đặc biệt, agent ReAct (reasoning and acting). Cụ thể hơn, chúng ta có thể tạo ra chức năng dịch vụ mới, bằng cách sử dụng mô-đun ServiceToolkit, cho agent ReAct và LLMs tương ứng. Trong ví dụ này, chúng tôi cố gắng trang bị agent ReAct với thuật toán NL2SQL tiên tiến, DAIL-SQL.

Như bước đầu tiên (như được thể hiện trong Ví dụ 19), chúng ta cần khởi tạo cấu hình mô hình và cơ sở dữ liệu SQL, sau đó khởi tạo và cung cấp đường dẫn cơ sở dữ liệu tương ứng ở định dạng sqlite. Ở đây chúng tôi tạo ra tệp SQLite sử dụng các lệnh SQL được cung cấp. Bạn cũng có thể sử dụng tệp định dạng .sqlite trực tiếp.

Sau đó, như được thể hiện trong Ví dụ 20, chúng tôi định nghĩa các công cụ cho ReAct Agent để thực thi truy vấn SQL. Cụ thể, agent của chúng ta nên có thể tạo ra truy vấn SQL cho đầu vào ngôn ngữ tự nhiên và thực thi truy vấn SQL để có kết quả. Chúng tôi tham khảo công cụ Text-to-SQL của bên thứ ba DAIL-SQL để tạo ra prompt Text-to-SQL. Chúng tôi sử dụng chức năng dịch vụ query_sqlite trong mô-đun agentscope.service. Bây giờ, chúng ta có thể khởi tạo ReAct Agent sử dụng các công cụ đã định nghĩa và tương tác với agent, như được thể hiện trong Ví dụ 21.

```python
import agentscope
from sql_utils import create_sqlite_db_from_schema
...
agentscope.init(model_configs="configs/model_configs.json")
create_sqlite_db_from_schema(db_schema_path, db_sqlite_path)
...
```
Ví dụ 19: Ví dụ sử dụng agent tìm kiếm web và truy xuất.

```python
from agentscope.service import (
    ServiceResponse,
    ServiceExecStatus,
    ServiceToolkit,
    query_sqlite,
)
from sql_utils import DailSQLPromptGenerator

def generate_sql_query(question: str, db_path: str, model: Callable) -> ServiceResponse:
    prompt_helper = DailSQLPromptGenerator(db_path)
    prepared_prompt = prompt_helper.generate_prompt({"content": question})

    def get_response_from_prompt(prompt: dict, model: Callable) -> str:
        ...
    sql_response = get_response_from_prompt(
        prepared_prompt["prompt"], model=model
    )
    return ServiceResponse(
        ServiceExecStatus.SUCCESS,
        sql_response
    )

# Sử dụng Service Toolkit để thiết lập chức năng công cụ cho LLMs
service_toolkit = ServiceToolkit()
service_toolkit.add(generate_sql_query, db_path=db_sqlite_path, model=loaded_model)
service_toolkit.add(query_sqlite, database=db_sqlite_path)
```
Ví dụ 20: Ví dụ sử dụng agent tìm kiếm web và truy xuất.

```python
from agentscope.agents import ReActAgent
agent = ReActAgent(
    name="assistant",
    model_config_name='gpt-4',
    service_toolkit=service_toolkit,
    sys_prompt="You are a helpful agent that preform SQL queries base on natural language instructions.",
    verbose=True,  # đặt verbose thành True để hiển thị quy trình lý luận
)
...
mss = Msg(
    name="user",
    content="How many singers do we have?",
    role="user"
)
logger.chat(mss)

sql_query_mss1 = agent(mss)
...
```
Ví dụ 21: Ví dụ sử dụng agent tìm kiếm web và truy xuất.

9.8 AgentScope Workstation

AgentScope cung cấp bộ công cụ phát triển rất tiện lợi và thân thiện với người dùng dưới dạng "kéo cửa sổ", Workstation. Ở đây, việc triển khai ứng dụng của AgentScope sử dụng bộ công cụ phát triển này có chi phí thấp theo nghĩa là, các nhà phát triển cấp độ nhập môn hoặc những người không có bất kỳ kinh nghiệm lập trình nào có thể dễ dàng phát triển ứng dụng của riêng họ một cách thoải mái bằng cách đơn giản kéo những mô-đun liên quan đến agent và kết nối chúng theo cách rất đơn giản. Ví dụ, như được thể hiện trong Hình 9, chúng tôi triển khai ví dụ cuộc trò chuyện cơ bản trong Workstation. Như chúng ta có thể thấy, chúng ta không cần viết bất kỳ mã nào, chỉ đơn giản gõ vào các cấu hình như thiết lập chi tiết và APIs vào các cửa sổ tương ứng, liên kết các cửa sổ để xây dựng phụ thuộc và kết nối, và sau đó chỉ với một cú nhấp chuột, Workstation sẽ sẵn sàng khởi chạy tự động. Đồng thời, Workstation cũng giới thiệu quy tắc kiểm tra tĩnh để đảm bảo tính đúng đắn của các cấu hình.

AgentScope Workstation cũng cung cấp hỗ trợ toàn diện cho các nhà phát triển nâng cao. Các nhà phát triển có thể xuất cấu hình trên các mô-đun như tệp .json và thực thi bằng engine AgentScope Workstation. Ngoài ra, người ta cũng có thể sử dụng AgentScope Workstation Compiler để chuyển đổi tất cả cấu hình thành mã Python để chỉnh sửa thêm hoặc phát triển để triển khai các điều chỉnh tùy chỉnh hơn.

10 Công trình Liên quan

Việc phát triển AgentScope phù hợp với bối cảnh phát triển nhanh chóng của các khung làm việc tận dụng các mô hình ngôn ngữ lớn (LLMs) để tạo ra agent ngôn ngữ và hệ thống đa-agent. Ở đây, chúng tôi giới thiệu ngắn gọn các công trình liên quan chặt chẽ đến AgentScope từ hai lĩnh vực phụ liên quan: Khung Agent Ngôn ngữ, tập trung vào khả năng agent cá nhân, và Khung Đa-Agent, nhấn mạnh sự hợp tác giữa nhiều agent. Để có công trình liên quan rộng hơn, độc giả có thể tham khảo (Wang et al., 2023; Xi et al., 2023).

Khung Agent Ngôn ngữ. Khung agent ngôn ngữ là then chốt để phát triển ứng dụng có thể diễn giải và tương tác bằng ngôn ngữ con người.

Thư viện Transformers (Huggingface, 2023) đã giới thiệu API ngôn ngữ tự nhiên để giao diện với các mô hình transformer trong các cập nhật gần đây (Transformers-Agents). API này sử dụng một bộ công cụ có thể tùy chỉnh, cho phép mô hình diễn giải hướng dẫn và tạo ra các đoạn mã tương ứng. Nó cung cấp hỗ trợ cho các endpoint mô hình mã nguồn mở và độc quyền khác nhau, đáp ứng nhu cầu nhà phát triển đa dạng. LangChain (Langchain-AI, 2023) cung cấp khung làm việc để xây dựng ứng dụng có nhận thức ngữ cảnh và có khả năng lý luận. Nó bao gồm thư viện và mẫu tạo thuận lợi cho việc tích hợp nhiều thành phần thành kiến trúc nhận thức thống nhất. LangServe và LangSmith mở rộng khả năng của khung làm việc bằng cách cho phép triển khai như REST API và cung cấp công cụ nhà phát triển để gỡ lỗi và giám sát chuỗi được xây dựng trên bất kỳ khung LLM nào. AutoGPT (AutoGPT-Team, 2023) minh họa cách tiếp cận khác, cho phép LLM lặp lại thực hiện hành động và đưa ra quyết định. Như một agent tổng quát, AutoGPT không cụ thể nhiệm vụ; nó được thiết kế để thực hiện nhiều nhiệm vụ dựa trên máy tính, phản ánh bản chất thích ứng của LLMs. ModelScope-Agent (Li et al., 2023a) là khung agent có thể tùy chỉnh khai thác LLMs mã nguồn mở để thực hiện nhiệm vụ và kết nối với APIs bên ngoài. Nó tạo thuận lợi cho việc tích hợp liền mạch với API mô hình và API phổ biến trong khi cung cấp cơ sở hạ tầng toàn diện cho thu thập dữ liệu, truy xuất công cụ, và huấn luyện mô hình tùy chỉnh, tất cả nhằm thực hiện ứng dụng thế giới thực thực tế.

Khung Đa-Agent. Xây dựng trên khả năng của agent cá nhân, khung đa-agent khám phá sự hợp tác và tương tác giữa nhiều agent để giải quyết các nhiệm vụ phức tạp.

AutoGen (Wu et al., 2023) cung cấp cơ sở hạ tầng tổng quát cho phép các nhà phát triển lập trình mô hình tương tác sử dụng cả ngôn ngữ tự nhiên và mã. Khung làm việc này cho phép phát triển ứng dụng đa dạng bằng cách tạo thuận lợi cho cuộc trò chuyện giữa các agent có thể tùy chỉnh và có thể sử dụng nhiều kết hợp khác nhau của LLMs, đầu vào con người, và công cụ. MetaGPT (Hong et al., 2023) kết hợp meta-programming để tăng cường hợp tác đa-agent. Bằng cách mã hóa Quy trình Vận hành Tiêu chuẩn (SOP) vào prompt, khung làm việc này đảm bảo quy trình làm việc hợp lý và giảm lỗi, minh họa phân chia nhiệm vụ hiệu quả giữa các agent. AGENTS (Zhou et al., 2023) là thư viện mã nguồn mở hỗ trợ agent ngôn ngữ tự động với các tính năng như lập kế hoạch, bộ nhớ, và giao tiếp đa-agent. Nó được thiết kế thân thiện với người dùng, giúp người không chuyên triển khai agent ngôn ngữ tiên tiến, và thân thiện với nghiên cứu, với thiết kế mô-đun hóa để mở rộng. OpenAgents (Xie et al., 2023) cung cấp nền tảng mở để sử dụng agent ngôn ngữ với chức năng thực tế có thể truy cập thông qua giao diện web. Khung làm việc này nhấn mạnh việc tạo thuận lợi cho tương tác agent thế giới thực và bao gồm agent chuyên biệt cho các nhiệm vụ khác nhau, chẳng hạn như phân tích dữ liệu và duyệt web. ChatDev (Qian et al., 2023) khai thác LLMs cho phát triển phần mềm, tạo ra công ty ảo được cung cấp năng lượng trò chuyện tuân theo mô hình thác nước. Nó thu hút "agent phần mềm" ở các giai đoạn khác nhau của quy trình phát triển, tạo thuận lợi cho sự hợp tác và giao tiếp có nhận thức ngữ cảnh. CAMEL (Li et al., 2023b) đề xuất khung làm việc mới cho sự hợp tác tự động giữa các agent giao tiếp sử dụng kỹ thuật nhập vai, cho phép tạo ra dữ liệu trò chuyện để nghiên cứu hành vi và khả năng agent. Cuối cùng, AgentSims (Lin et al., 2023) giới thiệu môi trường sandbox để đánh giá LLMs trong các tình huống dựa trên nhiệm vụ, cung cấp cơ sở hạ tầng cho các nhà nghiên cứu kiểm tra khả năng LLM cụ thể trong môi trường mô phỏng.

Những khung làm việc này đại diện cho những bước tiến đáng kể trong việc sử dụng LLMs cho cả nhiệm vụ agent cá nhân và hợp tác. AgentScope được đặt trong bối cảnh này, đóng góp bằng cách giải quyết nhu cầu về một khung làm việc thân thiện với người dùng, chịu lỗi và linh hoạt được thiết kế để quản lý các tương tác và quy trình phức tạp vốn có trong hệ thống LLM đa-agent. Bằng cách tập trung vào tính dễ sử dụng và độ tin cậy, AgentScope nhằm tạo thuận lợi cho việc tạo ra các ứng dụng mạnh mẽ và linh hoạt trên các lĩnh vực đa dạng.

11 Kết luận

Trong công trình này, chúng tôi đề xuất AgentScope, một nền tảng đứng đầu trong việc phát triển hệ thống đa-agent, kết hợp thiết kế hướng người dùng với khả năng tiên tiến của LLMs. Thông qua các cơ chế giao tiếp và phân tán sáng tạo, AgentScope thể hiện tiềm năng thúc đẩy sự hợp tác giữa các agent, cho phép hoạt động hiệu quả, chịu lỗi và tương tác đa phương thức. Bằng cách trừu tượng hóa sự phức tạp và cung cấp một loạt tiện ích phát triển, AgentScope giảm đáng kể rào cản gia nhập, thúc đẩy cộng đồng nhà phát triển bao gồm và sáng tạo hơn.

Nhìn về phía trước, AgentScope mở ra nhiều con đường cho nghiên cứu và phát triển thêm. Công việc tương lai có thể đi sâu vào tích hợp sâu hơn của tạo sinh tăng cường truy xuất, và khám phá các giao thức giao tiếp thích ứng và modal tương tác phát triển cùng với yêu cầu nhiệm vụ. Tác động của nền tảng đối với việc tăng tốc triển khai hệ thống đa-agent trên các ngành công nghiệp, từ chăm sóc sức khỏe đến dịch vụ khách hàng, hứa hẹn sẽ sâu sắc, có thể dẫn đến các công nghệ thông minh và phản ứng hơn để tăng cường sự hợp tác người-máy. Với AgentScope, chúng tôi mời cộng đồng nghiên cứu và phát triển rộng lớn hơn xây dựng trên nền tảng của chúng tôi, thúc đẩy những đổi mới sẽ định hình thế hệ tiếp theo của ứng dụng đa-agent thông minh.
