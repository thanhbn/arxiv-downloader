# 2207.10739.pdf
# Được chuyển đổi từ PDF sang TXT
# Đường dẫn nguồn: /home/admin88/arxiv-downloader/benchmark/2207.10739.pdf
# Kích thước tệp: 322142 bytes

===============================================
NỘI DUNG TỆP PDF
===============================================


--- TRANG 1 ---
arXiv:2207.10739v2  [cs.LG]  4 Tháng 5 2023Được xuất bản như một bài báo hội nghị tại ICLR 2023
BIGISSUE: MỘT ĐIỂM CHUẨN ĐỊNH VỊ LỖI THỰC TẾ

Paul Kassianik∗
Salesforce Research
pkassianik@salesforce.comErik Nijkamp∗
Salesforce Research
erik.nijkamp@salesforce.com

Bo Pang
Salesforce Research
bo.pang@salesforce.comYingbo Zhou
Salesforce Research
yingbo.zhou@salesforce.com

Caiming Xiong
Salesforce Research
cxiong@salesforce.com

TÓM TẮT
Khi các công cụ học máy tiến bộ, câu hỏi không thể tránh khỏi phát sinh: Làm thế nào học máy có thể giúp chúng ta viết code tốt hơn? Với tiến bộ đáng kể được đạt được trong xử lý ngôn ngữ tự nhiên với các mô hình như GPT-3 và BERT, việc áp dụng các kỹ thuật xử lý ngôn ngữ tự nhiên vào code đang bắt đầu được khám phá. Hầu hết nghiên cứu đã tập trung vào sửa chữa chương trình tự động (APR), và trong khi kết quả trên các tập dữ liệu tổng hợp hoặc được lọc cao là hứa hẹn, các mô hình như vậy khó áp dụng trong các tình huống thực tế vì hiệu suất kém của các kỹ thuật định vị lỗi. Chúng tôi đề xuất BigIssue: một điểm chuẩn định vị lỗi thực tế. Mục tiêu của điểm chuẩn này gồm hai phần. Chúng tôi cung cấp (1) hai điểm chuẩn tổng quát với sự đa dạng của các lỗi Java thực và tổng hợp và (2) một động lực để cải thiện khả năng định vị lỗi của các mô hình thông qua mã hóa ngữ cảnh dài hơn. Với việc giới thiệu BigIssue, chúng tôi hy vọng sẽ thúc đẩy tình trạng hiện đại trong định vị lỗi, từ đó cải thiện hiệu suất APR và tăng khả năng ứng dụng của nó vào chu kỳ phát triển hiện đại.

1 GIỚI THIỆU
Những tiến bộ gần đây trong xử lý ngôn ngữ tự nhiên (NLP) (Brown et al., 2020; Devlin et al., 2018; Liu et al., 2019b) đã tăng sự quan tâm đến việc áp dụng các kỹ thuật NLP vào hiểu code. Với sự phát triển của các bộ mã hóa code (Feng et al., 2020a; Kanade et al., 2020), nhiệm vụ này đang trở nên ngày càng dễ tiếp cận và hấp dẫn hơn. Khi nghiên cứu đã nhảy vọt vào nhiệm vụ Sửa chữa Chương trình Tự động (APR), kết quả đã không đầy đủ. Mặc dù các tập dữ liệu tổng hợp đã phần lớn được giải quyết (xem Phần 2.1), các mô hình đã có hiệu suất đáng ngạc nhiên kém trên các tập dữ liệu thực tế, nhiều mô hình thậm chí không thể sửa chữa một phần tư số lỗi trong điểm chuẩn Defects4J (xem Phần 2.2 và Lutellier et al. (2020)). Điều này bất chấp nghiên cứu cho thấy rằng các điểm chuẩn APR hiện tại thiếu sự đa dạng (Durieux et al., 2019). Kết quả là, nhiều mô hình APR dễ bị overfitting với các tập dữ liệu cụ thể (Mousavi et al., 2020). Mặc dù thú vị từ góc độ học thuật, các công cụ như vậy sẽ khó hữu ích trong tình huống công nghiệp thực tế.

Chúng tôi cho rằng ba hạn chế chính đối với các phương pháp APR được sử dụng ngày nay là: (1) huấn luyện để sửa các lỗi đã được định vị thay vì tìm lỗi và sửa chúng, (2) không khả năng của các mô hình để tính đến ngữ cảnh lớn, và (3) sự phụ thuộc vào thông tin bên cạnh code thuần túy. Hạn chế đầu tiên là đơn giản: các bản vá có ngữ cảnh hạn chế bên ngoài các dòng ngay trước và sau mỗi bản vá. Đã được chứng minh rằng hiệu suất APR cải thiện đáng kể nếu một thuật toán định vị lỗi tốt được sử dụng để phát hiện các vị trí code bị lỗi (Durieux et al., 2019; Liu et al., 2019a). Hạn chế thứ hai

∗Đóng góp ngang nhau
1

--- TRANG 2 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023
ngăn cản các mô hình tìm các lỗi phụ thuộc vào ngữ cảnh của chương trình. Ngay cả đối với người đọc, nhiều lỗi thực tế đòi hỏi rất nhiều ngữ cảnh cụ thể của chương trình để có thể phát hiện được. Một trong những bộ mã hóa code phổ biến nhất hiện nay (Feng et al., 2020a) chỉ hỗ trợ mã hóa các chuỗi lên đến 512 token, không đủ để xử lý hầu hết các tệp Java trong các chương trình thực tế (trung bình 7.5k token với bộ tokenizer RoBERTa (Liu et al., 2019b)). Hạn chế thứ ba phát sinh từ thực tế rằng một trong những phương pháp định vị lỗi phổ biến nhất, SBFL (Jones & Harrold, 2005), phụ thuộc nhiều vào các test case để lộ các vị trí có thể bị lỗi.

Để thúc đẩy tình trạng hiện đại của cả các mô hình BL (Định vị Lỗi) và APR (Sửa chữa Chương trình Tự động), chúng tôi giới thiệu BigIssue. Các đóng góp chính của BigIssue bao gồm:

• Một bộ sưu tập lớn các lỗi thực tế đã được xác nhận với chú thích ở cấp độ dòng. Mỗi lỗi đã được báo cáo bởi người dùng thực tế cho hệ thống theo dõi lỗi GitHub Issues và được sửa qua một commit hoặc pull request. Tập dữ liệu chứa tổng cộng 10.905 lỗi từ 4.233 kho lưu trữ Java.

• Một tập dữ liệu lỗi tổng hợp chuỗi dài. Các nhiễu loạn trong code thực được thu thập từ GitHub được tạo ra bởi InCoder (Fried et al., 2022), một mô hình tạo code hiện đại.

• Một minh chứng thực nghiệm về độ khó của điểm chuẩn thực so với điểm chuẩn tổng hợp. Ngay cả với các kỹ thuật tạo lỗi tổng hợp tiên tiến, hiệu suất trên lỗi thực của các mô hình được huấn luyện trên dữ liệu tổng hợp sẽ không đầy đủ, điều này đòi hỏi nghiên cứu thêm về phát hiện lỗi thực tế.

Bằng cách cung cấp một tập dữ liệu lớn và đa dạng của các lỗi tổng hợp và thực từ nhiều dự án mà không có bất kỳ thông tin bổ sung nào bên ngoài code, chúng tôi hy vọng sẽ thúc đẩy hướng nghiên cứu về định vị lỗi ngữ cảnh dài ở cấp độ dòng để có hiệu suất tốt hơn trên các nhiệm vụ APR.

2 NGHỆ THUẬT TRƯỚC ĐÂY

2.1 SỬA CHỮA CHƯƠNG TRÌNH TỰ ĐỘNG
Vì định vị lỗi liên quan cơ bản đến sửa chữa chương trình tự động, chúng tôi cung cấp một cuộc khảo sát ngắn gọn về các điểm chuẩn APR hiện có và những nhược điểm của chúng.

Điểm chuẩn Thực tế Tập dữ liệu Defects4J của Just et al. (2014) đã được sử dụng rộng rãi trong sửa chữa chương trình tự động. Nó bao gồm 357 (835 là phiên bản 2) lỗi từ 10 (100) dự án Java mã nguồn mở hàng đầu. Các lỗi được xem xét thủ công và mỗi lỗi có ít nhất 1 test case để lộ lỗi. Tuy nhiên, các phương pháp APR không đủ thành công trên Defects4J để gợi ý tính hữu ích trong các ứng dụng thực tế. Mô hình hiện đại nhất gần đây chỉ có thể sửa 67 trong số 357 lỗi (Yuan et al., 2022), trong khi hai mô hình hiện đại trước đó chỉ có thể sửa 44 (Lutellier et al., 2020) và 57 (Jiang et al., 2021) lỗi. Điều này bất chấp nghiên cứu gần đây cho thấy các phương pháp APR đang có hiệu suất cao hơn trên Defects4J so với các điểm chuẩn tương tự khác (Durieux et al., 2019).

Bugs.jar (Saha et al., 2018) là một tập dữ liệu tương tự nhưng với phạm vi mở rộng của 8 dự án phổ biến từ Apache foundation.

iBugs (Dallmeier & Zimmermann, 2007) trình bày một phương pháp trích xuất lỗi bán tự động từ kho lưu trữ, và cung cấp một tập dữ liệu cụ thể áp dụng phương pháp vào dự án ASPECTJ. Phương pháp liên quan đến việc phân tích nhật ký commit để tìm dấu hiệu cho thấy sửa lỗi, trích xuất các phiên bản trước commit và sau commit của kho lưu trữ, và xác định các test case đại diện cho việc sửa lỗi. Tuy nhiên, tập dữ liệu này khá nhỏ và chỉ được lấy từ một kho lưu trữ.

Một tập dữ liệu được sử dụng rộng rãi khác là tập dữ liệu ManySStubs4J (Karampatsis & Sutton, 2020). Đây là một bộ sưu tập nhiều lỗi "ngu ngốc" được khai thác từ 100 (1.000) kho lưu trữ Java mã nguồn mở hàng đầu. Bộ sưu tập chỉ bao gồm những thay đổi mà thay đổi là một dòng code duy nhất và thuộc một trong 16 loại lỗi được xác định trước. Mặc dù thuận tiện, nó thiếu các lỗi phức tạp và tiêu chí chọn lọc cao.

Learning-fixes (Tufano et al., 2018) là một bộ sưu tập khoảng 58.350 phương thức ngắn được khai thác từ GitHub. Mỗi phương thức đã được chuẩn hóa ngữ nghĩa và được trình bày trong điểm chuẩn. Hạn chế chính của tập dữ liệu này là nó là tập dữ liệu cấp độ phương thức: mỗi lỗi nên có thể xác định và sửa được dựa trên ngữ cảnh chỉ có trong phương thức cụ thể đó. Đối với lỗi thực, điều này thường không phải là trường hợp.

2

--- TRANG 3 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

DLFix (Li et al., 2020) là một tập dữ liệu khác nhắm vào các nhiệm vụ APR. Tập dữ liệu bao gồm gần 5 triệu phương thức, được tăng cường với metadata, và các phiên bản đã sửa tương ứng của phương thức cho một kho lưu trữ cụ thể. Mặc dù thú vị cho các trường hợp hạn chế, độ chi tiết ở cấp độ phương thức cũng như sự cần thiết xây dựng metadata cho mỗi phương thức hạn chế tính hữu ích của nó, đặc biệt trên các phương thức dài hơn.

Bảng 1 trình bày so sánh các điểm chuẩn APR hiện có.

Điểm chuẩn Tổng hợp Một cách tự nhiên để đối phó với việc thiếu đa dạng dữ liệu trong các điểm chuẩn thực tế hiện tại là tạo điểm chuẩn tổng hợp bằng cách làm nhiễu code. Cách đơn giản nhất để tạo nhiễu loạn code là áp dụng nhiễu loạn dựa trên quy tắc vào một corpus code (Kanade et al., 2020) hoặc qua một oracle tĩnh (như một linter) (Berabi et al., 2021). Các tập dữ liệu khác được tạo ra qua một mô hình nhiễu loạn riêng biệt. SPoC (Kulal et al., 2019) sử dụng một LSTM đơn giản để tạo các dòng code có thể có lỗi. DeepDebug (Drain et al., 2021) sử dụng một mô hình phức tạp hơn được huấn luyện trên các git commit đảo ngược để tạo lỗi tổng hợp. Mặc dù hấp dẫn, có bằng chứng đáng kể rằng hiệu suất tốt trên các điểm chuẩn này không chuyển đổi thành hiệu suất tốt trên lỗi thực tế (Durieux et al., 2019). Chúng tôi cũng thực hiện thí nghiệm trong Phần 5 cho thấy rằng ngay cả hiệu suất tốt trên các tập dữ liệu nhiễu loạn tinh vi cũng không chuyển đổi tốt sang sửa lỗi thực.

2.2 SỬ DỤNG CÁC ĐIỂM CHUẨN HIỆN CÓ CHO ĐỊNH VỊ LỖI

Định vị lỗi ở cấp độ dòng và dự đoán lỗi riêng lẻ đã bị nghiên cứu nghiêm trọng thiếu. Trong khi định vị ở cấp độ tệp có thể đạt được điểm độ chính xác top-5 lên đến 70% (Lam et al., 2017), các phương pháp định vị ở cấp độ dòng không thành công như vậy. Theo một khảo sát gần đây của Zou et al. (2019), các phương pháp định vị và dự đoán lỗi hiện tại thậm chí không thể định vị một nửa số lỗi trong tập dữ liệu Defects4J (Just et al., 2014). Phương pháp được sử dụng rộng rãi nhất cho định vị lỗi là Định vị lỗi dựa trên phổ (SBFL) (Jones & Harrold, 2005). Mặc dù cơ bản và đơn giản để triển khai, nó phụ thuộc nhiều vào chất lượng và số lượng test case, đặc biệt đối với các chương trình lớn (Keller et al., 2017). Các phương pháp học sâu mới hơn như TRANSFER-FL (Meng et al., 2022) cũng không thể định vị dòng code bị lỗi một cách nhất quán (chỉ 84/395 ví dụ).

Tập dữ liệu Kích thước Độ chi tiết Độ dài Lỗi Ngữ cảnh # Kho lưu trữ Bộ lọc
BigIssue 10.905 Dòng Đa dòng Kho lưu trữ 4233 Không
Defects4J(Just et al., 2014) 357 (835) Dòng Đa dòng Kho lưu trữ 5 (17) Không
Bugs.jar(Saha et al., 2018) 1158 Dòng Đa dòng Kho lưu trữ 8 Không
ManySStubs4J
(Karampatsis & Sutton,
2020)10.231
Dòng Dòng đơn Kho lưu trữ100
Có (63.923) (1000)
iBugs
(Dallmeier & Zimmermann,
2007)369 Dòng Đa dòng Kho lưu trữ 1 Không
Learning-Fixes
(Tufano et al., 2018)58.350 Dòng Đa dòng Phương thức - Không
DLFix (Li et al., 2020) 4.973.000 Phương thức Đa dòng Kho lưu trữ 8 Không

Bảng 1: So sánh các Tập dữ liệu Phát hiện Lỗi Java Chính.

3 TẬP DỮ LIỆU TỔNG HỢP BIGISSUE

3.1 ĐỘNG LỰC

Đánh giá các cách tiếp cận định vị lỗi đòi hỏi việc xây dựng một tập dữ liệu với các lỗi ground-truth đã biết. Một phương pháp để tạo tập dữ liệu như vậy là xem xét code hiện có và đưa ra các nhiễu loạn sai sót dưới dạng các mẫu được rút ra từ một mô hình tạo sinh. Trong nghệ thuật trước đây

3

--- TRANG 4 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

Kulal et al. (2019), các nhiễu loạn tổng hợp đã được áp dụng ở mức độ chi tiết cấp hàm với các mô hình tạo sinh yếu như LSTM nhỏ. Phân phối cơ bản của tập dữ liệu tổng hợp như vậy có thể khá khác biệt so với phân phối của các lỗi thực tế, xảy ra trong kỹ thuật phần mềm (Durieux et al., 2019). Để giảm sự khác biệt này, chúng tôi sẽ tiến bộ khái niệm này lên dữ liệu cấp tệp và mẫu nhiễu loạn từ một mô hình tạo sinh mạnh.

Tập dữ liệu tổng hợp của chúng tôi áp dụng phương pháp thu thập code "thực" như quan sát và đưa ra các nhiễu loạn tổng hợp trong các quan sát. Ở đây, nhiễu loạn là một viết lại của chuỗi code gốc thành một chuỗi code bị nhiễu loạn. Trong cách tiếp cận của chúng tôi, một phần của code gốc được "che đi" và một mô hình tạo sinh được tuyển dụng để "điền vào" code bị che đi. Phần "được điền vào" của code tạo thành nhiễu loạn tổng hợp. Nhiễu loạn của code gốc được giả định là có khả năng chứa "lỗi".

Mặc dù cách tiếp cận dựa trên nhiễu loạn ở trên có thể xuất hiện rõ ràng và tầm thường, việc xây dựng các tập dữ liệu như vậy là thách thức. Điều này do các điều kiện sau: (1) code hiện có không được đảm bảo không có lỗi, (2) định nghĩa hoặc bản thể học của một "lỗi" hoặc "bug" bản thân nó là không tầm thường, (3) việc tạo ra các nhiễu loạn tổng hợp khó phân biệt với các quan sát gốc nhưng vẫn phản ánh phân phối của lỗi "thực" là khó.

Nghệ thuật trước đây giải quyết những vấn đề này bằng cách (1) giảm phạm vi của code xuống cấp hàm hoặc dòng, có hiệu quả giảm khoảng của code xuống n dòng code (Kanade et al., 2020; Yasunaga & Liang, 2020; 2021), (2) đưa ra các quy tắc nhiễu loạn heuristic hoặc xác định trước một tập hợp các loại mà "lỗi" rơi vào (Kanade et al., 2020; Drain et al., 2021), hoặc (3) làm nhiễu loạn một dòng code duy nhất trong các chương trình đơn giản (Yasunaga & Liang, 2020; Drain et al., 2021). Mặc dù việc đơn giản hóa quá mức này là một bước đầu hợp lý, tập dữ liệu kết quả có thể khá khác biệt so với lỗi thực tế mà việc định vị được coi là "hữu ích" cho một người thực hành.

Công việc của chúng tôi giải quyết (1) và (2) bằng cách loại bỏ khái niệm về "lỗi" và thay vào đó chuyển suy nghĩ khái niệm về phân phối của quan sát "gốc" và "bị nhiễu loạn". Nghĩa là, tập dữ liệu của chúng tôi được giả định chứa lỗi không được xác định trong nhãn ground-truth. Nhiệm vụ định vị lỗi được nới lỏng thành nhiệm vụ định vị nhiễu loạn. Việc nới lỏng này cho phép chúng tôi xem xét các quan sát cấp tệp mà không cần định nghĩa nghiêm ngặt về "lỗi". Định nghĩa nới lỏng như vậy phù hợp với việc xây dựng một tập dữ liệu "kiểm tra tỉnh táo" để kiểm tra khả năng của mô hình trong việc phát hiện code khác biệt so với thực hành mã hóa tiêu chuẩn. Trong phần sau, chúng tôi sẽ cung cấp chi tiết về việc tạo tập dữ liệu như vậy và đặc biệt giải quyết (3).

3.2 XÂY DỰNG TẬP DỮ LIỆU

Phương pháp cơ bản của việc tạo tập dữ liệu này là (1) thu thập lượng lớn quan sát cấp tệp (tức là, code thực), (2) đưa ra các nhiễu loạn tổng hợp từ một mô hình tạo sinh mạnh sao cho việc phân biệt quan sát "gốc" và "bị nhiễu loạn" là không tầm thường, (3) và nới lỏng nhiệm vụ "định vị lỗi" thành nhiệm vụ "định vị nhiễu loạn". Trong phần này, chúng tôi mô tả việc xây dựng tập dữ liệu như vậy.

Quan sát Để có được số lượng lớn quan sát cho việc học và đánh giá các mô hình định vị, tập dữ liệu được đề xuất là một biên soạn thông tin công khai, phi cá nhân từ GitHub bao gồm code Java được cấp phép cho phép vào tháng 10 năm 2021. Cụ thể, chúng tôi thu thập 8 triệu kho lưu trữ từ tháng 1 năm 2014 đến tháng 10 năm 2021 được chú thích với ít nhất 1 sao và xem xét tập con các tệp chứa trong đó có code Java. Các tệp phải có độ dài trung bình ≤100 ký tự và độ dài dòng tối đa là 1.000. Các tệp mà ≥90% ký tự là chữ số thập phân hoặc thập lục phân cũng được loại bỏ. Cuối cùng, các bản sao chính xác dựa trên hash SHA-256 của chúng được loại bỏ, chiếm một phần đáng kể của dữ liệu thô do fork và sao chép kho lưu trữ. Tập dữ liệu kết quả bao gồm 96,56 GB text thô.

Nhiễu loạn Đối với các nhiễu loạn thực tế, chúng tôi sử dụng một phương pháp được gọi là "inpainting" cho hình ảnh hoặc "infilling" cho lĩnh vực văn bản. Nghĩa là, một phần của một quan sát nhất định bị che khuất (hoặc bị che đi). Sau đó, sự che khuất được tái tạo hoặc "điền vào" bởi một mẫu được rút ra từ một mô hình tạo sinh có điều kiện trên ngữ cảnh không bị che khuất. Gần đây, các mô hình ngôn ngữ nhân quả tự hồi quy, như Brown et al. (2020), đã chứng minh xuất sắc trong nhiệm vụ này mà prompt có thể được coi như ngữ cảnh và mẫu tự hồi quy có điều kiện trên prompt như in-painting trong khi bảo tồn

4

--- TRANG 5 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

các quy luật thống kê của dữ liệu huấn luyện. Tuy nhiên, phân phối kết hợp trên token thường được nhân tử hóa theo thứ tự từ trái sang phải theo thời gian, mà mặt nạ nhân quả hạn chế các mẫu infill chỉ tính đến ngữ cảnh quá khứ, nhưng không phải token tương lai. Trong trường hợp của chúng tôi về lấy mẫu các nhiễu loạn thực tế tại các khoảng ngẫu nhiên trong một quan sát nhất định, chúng tôi muốn tính đến cả code trước và sau khoảng bị che đi để đảm bảo tính nhất quán cấp tệp. Để giải quyết vấn đề này, chúng tôi tuyển dụng một bộ lấy mẫu tự hồi quy sắp xếp lại chuỗi đầu vào và mặt nạ nhân quả liên quan sao cho việc lấy mẫu có điều kiện trên cả ngữ cảnh quá khứ và tương lai (Du et al., 2022; Fried et al., 2022). Để giảm thêm khoảng cách giữa các chuỗi "thực" và "bị nhiễu loạn", chúng tôi chọn một mô hình ngôn ngữ quy mô lớn, InCoder (Fried et al., 2022), với 1 tỷ tham số, và hạ nhiệt độ của lấy mẫu nucleus tự hồi quy xuống 0.8. Giá trị nhiệt độ này được chọn bằng thí nghiệm thủ công.

Được trang bị bộ lấy mẫu như vậy, một khoảng ngẫu nhiên trong quan sát được loại bỏ và được infill với một mẫu được rút ra từ mô hình InCoder. Độ dài của khoảng được rút ra từ phân phối đều với độ dài tối thiểu là 64 token và độ dài tối đa là 128 token. Mẫu được tạo ra bị hạn chế tối đa là độ dài của khoảng.

Để cải thiện thêm chất lượng của các nhiễu loạn, chúng tôi sử dụng lấy mẫu từ chối từ mô hình InCoder trong đó các mẫu được rút ra không thỏa mãn ngữ pháp chính thức của ngôn ngữ lập trình bị từ chối. Cụ thể, chúng tôi (1) từ chối bất kỳ tệp nào không chính xác về mặt cú pháp¹, (2) từ chối các tệp chứa ít hơn 2.048 token, (3) từ chối các nhiễu loạn mà 10 lần thử lấy mẫu infill (với độ dài khoảng tối thiểu là 64 và số token tối đa là 128) không dẫn đến một nhiễu loạn chính xác về mặt cú pháp, (4) từ chối các mẫu mà khoảng cách Levenshtein giữa chuỗi không bị nhiễu loạn và bị nhiễu loạn nhỏ hơn 64 token hoặc lớn hơn 192 token.

Nhiệm vụ Nhiệm vụ "định vị nhiễu loạn" được đề xuất của chúng tôi có thể được biểu thị dưới dạng phân loại nhị phân mà mỗi dòng được gắn nhãn là "gốc" hoặc "bị nhiễu loạn". Như vậy, nhãn ground-truth chỉ ra liệu dòng có phải là một chuỗi con của quan sát hay đã (có thể một phần) bị nhiễu loạn bởi bộ lấy mẫu. Mỗi tệp chứa tối đa một nhiễu loạn như vậy. Độ dài của chuỗi đầu vào bị hạn chế tối đa 8.192 token dưới bộ tokenizer RoBERTa (Liu et al., 2019b) với tối đa 512 dòng mỗi tệp.

3.3 CÁC VÍ DỤ VÀ ARTIFACT TẬP DỮ LIỆU

Một số mẫu từ tập dữ liệu tổng hợp được trình bày trong Phụ lục E, và tất cả chi tiết artifact có thể được tìm thấy trong Phụ lục A.

4 ĐIỂM CHUẨN THỰC TẾ BIGISSUE

4.1 ĐỘNG LỰC

Dựa trên các quan sát của chúng tôi về các điểm chuẩn hiện có từ Phần 2, chúng tôi kết luận rằng cần một điểm chuẩn mới để thúc đẩy tình trạng hiện đại tiến lên. Do đó, chúng tôi tạo ra một điểm chuẩn ưu tiên số lượng hơn chất lượng được nhận thức và một điểm chuẩn tập trung cụ thể vào định vị lỗi cấp dòng dựa trên NL.

Đối với điểm chuẩn này, chúng tôi định nghĩa một dòng là "bị lỗi" nếu nó đã được loại bỏ hoặc sửa đổi trong bản vá issue. Điều này cho phép chúng tôi tránh sử dụng test như ground truth cho lỗi trong code. Định nghĩa này cũng phù hợp tốt với việc sử dụng các bộ mã hóa code như CodeBERT (Feng et al., 2020a) cho phân loại cấp dòng, như được chứng minh trong Phần 5.

4.2 XÂY DỰNG ĐIỂM CHUẨN

Đầu tiên, chúng tôi xem xét các kho lưu trữ Java GitHub được tạo từ tháng 1 năm 2014 đến tháng 10 năm 2021. Để đảm bảo rằng chúng tôi chỉ lọc ra các kho lưu trữ được dự định cho một số hình thức sử dụng công cộng, chúng tôi chỉ kiểm tra các kho lưu trữ có ít nhất 1 sao. Chúng tôi lọc thêm các kho lưu trữ chỉ những kho lưu trữ có GitHub Issues được bật và có giấy phép cho phép sử dụng code của họ (danh sách đầy đủ các giấy phép có sẵn trong Phụ lục C). Điều đó cho chúng tôi 4.233 kho lưu trữ.

¹Để xác minh tính chính xác cú pháp của các chương trình Java, chúng tôi sử dụng thư viện JAVALANG:
https://github.com/c2nes/javalang.

5

--- TRANG 6 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

Sử dụng GitHub API, chúng tôi lọc qua các issue đã đóng trên các kho lưu trữ này. Chúng tôi chỉ sử dụng thông tin công khai, phi cá nhân có sẵn thông qua API. Để chọn các issue tương ứng với việc sửa lỗi trên kho lưu trữ cụ thể đó, chúng tôi chọn các issue chứa "bug", "fix", hoặc "fixed" như các từ riêng biệt trong tiêu đề và nội dung của issue. Chúng tôi cũng bao gồm các issue chứa nhãn "bug". Chúng tôi nhìn vào các issue với sự kiện "close" tương ứng, và chúng tôi nhìn vào commit được đính kèm với sự kiện "close" mới nhất. Điều này cho chúng tôi một tập dữ liệu gồm 23.924 issue đã đóng tổng cộng. Chúng tôi lọc thêm chỉ những lỗi ảnh hưởng đến một tệp Java mà không có code test. Điều đó cho ra 10.905 lỗi.

Để xác minh tính hợp lệ của các bộ lọc của chúng tôi, chúng tôi xác minh thủ công 100 issue mẫu. Chúng tôi xác minh thủ công tính hợp lệ của 84 issue. Một phân tích chi tiết có thể được tìm thấy trong Phụ lục D.

Tương tự như iBugs (Dallmeier & Zimmermann, 2007), để xác định các dòng bị lỗi, chúng tôi kiểm tra dữ liệu từ các hunk trong diff. Nếu một dòng (1) bị loại bỏ từ tệp nguồn và (2) không phải là dòng import (các dòng bắt đầu với import ...), nó được đánh dấu là bị lỗi. Trong các trường hợp mà các hunk chỉ thêm code, chúng tôi đánh dấu hai dòng trong nguồn trước và sau thay đổi là bị lỗi. Xử lý code được thêm không phải lúc nào cũng đơn giản: đôi khi chunk được thêm là một đoạn code được outsource từ một phương thức khác. Tuy nhiên, việc đơn giản hóa quá trình này được thực hiện để tính đến code được thêm trong khi giảm thiểu tác động tiềm tăng của các chunk được outsource đơn giản.

Khung test-running Nhiều điểm chuẩn được trình bày ở trên sử dụng test hoặc như hỗ trợ trong việc sửa lỗi hoặc như một phương pháp lọc lỗi. Chúng tôi không xem xét khung test và test như tiêu chí cho việc liệu một commit có phải là lỗi hay không. Thứ nhất, gần đây đã được chỉ ra rằng unit test riêng lẻ không đảm bảo ít lỗi hơn bên trong code (Chioteli et al., 2021) điều này ngụ ý rằng có thậm chí nhiều lỗi hơn bên trong code không được lộ ra bởi test. Thứ hai, chúng tôi sẽ hạn chế nghiêm trọng sự đa dạng và phạm vi của điểm chuẩn của chúng tôi bằng cách buộc các issue phải bao gồm một test case lộ ra.

4.3 CÁC VÍ DỤ VÀ ARTIFACT ĐIỂM CHUẨN

Một số mẫu từ tập dữ liệu tổng hợp được trình bày trong Phụ lục F, và tất cả chi tiết artifact có thể được tìm thấy trong Phụ lục A.

5 PHÁT HIỆN LỖI TỔNG HỢP VS THỰC TẾ

Trong Phần này, chúng tôi tiến hành phân tích sơ bộ về độ khó của điểm chuẩn BigIssues. Vì độ dài chuỗi vượt quá hạn chế của hầu hết các mô hình ngôn ngữ được huấn luyện trước trên code, chúng tôi tuyển dụng mean pooling để xây dựng các baseline đơn giản. Chúng tôi giả thuyết rằng mặc dù dữ liệu thực tế khó hơn nhiều so với tập dữ liệu tổng hợp, việc sử dụng các bộ mã hóa ngữ cảnh dài cùng với huấn luyện trước tổng hợp sẽ giúp tăng hiệu suất.

5.1 GIẢ THUYẾT

Điểm chuẩn BigIssue được đề xuất chứa hai biến thể: (1) viết lại tổng hợp của code thực được lấy mẫu từ một mô hình tạo sinh mạnh, (2) viết lại thực tế của code thực dựa trên các commit liên quan đến một issue đã đóng trong GitHub.

Nhớ lại, đối với (1) một mô hình ngôn ngữ lớn gần đây đã được tuyển dụng như một bộ lấy mẫu mà, so với nghệ thuật trước đây, không chỉ có kích thước đáng kể theo luật scale, mà hơn nữa thay đổi mặt nạ nhân quả sao cho token tương lai có thể được tính đến như ngữ cảnh. Chúng tôi lập luận rằng những viết lại tổng hợp này không tầm thường để phát hiện so với nghệ thuật trước đây.

Tuy nhiên, giả thuyết của chúng tôi là định vị lỗi thực vẫn là một nhiệm vụ khó khăn hơn đáng kể không thể giải quyết với các mô hình cơ bản và đòi hỏi nghiên cứu đáng kể để được giải quyết. Trong khi các lỗi cục bộ, tầm thường không đòi hỏi ngữ cảnh để được định vị, các lỗi khó hơn không cục bộ thường chỉ có thể được giải quyết khi tính đến toàn bộ tệp, một tập hợp các tệp được import, hoặc toàn bộ kho lưu trữ. Chúng tôi sử dụng các mô hình cơ bản để chỉ ra rằng (a) lỗi tổng hợp dễ phát hiện hơn lỗi thực, và có thể phục vụ như một kiểm tra tỉnh táo cho các mô hình định vị lỗi và (b) chúng tôi sử dụng lỗi tổng hợp để chỉ ra rằng mã hóa ngữ cảnh dài hơn cải thiện hiệu suất trên định vị lỗi.

6

--- TRANG 7 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

5.2 MÔ HÌNH

Kiến trúc của chúng tôi phân vùng một chuỗi đầu vào dài 8.192 token thành các chuỗi con ngắn hơn, tính toán các vector được ngữ cảnh hóa cho mỗi chunk sử dụng một mô hình mã hóa hai chiều, kết hợp các vector được ngữ cảnh hóa thành 512 vector tiềm ẩn với mean-pooling, và cuối cùng chiếu những vector đó thành logit cho phân loại nhị phân cấp dòng.

Xem xét một chuỗi x = (x₀,x₁,...,xₙ) của các token đầu vào với độ dài n = 8.192. Để giải quyết vấn đề (2) của n lớn, chúng tôi phân vùng x thành m = 16 chunk có kích thước bằng nhau x̃ᵢ với i ∈ {0,...,15} mỗi chunk chứa 512 token. Để ngữ cảnh hóa vector embedding của các token, chúng tôi tuyển dụng bộ mã hóa hai chiều được huấn luyện trước f, (như CodeBERT (Feng et al., 2020b)), và tính toán f(x̃ᵢ) cho mỗi phân vùng i. Sau đó, các phân vùng được ngữ cảnh hóa được nối x̂ = (f(x̃₀),f(x̃₁),...,f(x̃ₘ)). Để khôi phục thông tin vị trí toàn cục, chúng tôi áp dụng embedding vị trí sinusoidal cộng tính vào x̂. Một lớp self-attention tích hợp thông tin qua các ranh giới phân vùng. Mean-pooling được áp dụng vào x̂ với độ dài cửa sổ sao cho chuỗi kết quả của các vector tiềm ẩn khớp với số lượng tối đa 512 dòng. Một phép chiếu tuyến tính tiêu chuẩn ánh xạ mỗi vector tiềm ẩn cấp dòng thành logit cho phân loại nhị phân. Mô hình kết quả được fine-tune với binary cross entropy như hàm mục tiêu.

Sự hấp dẫn của mô hình được đề xuất là tận dụng các biểu diễn được học bởi một mô hình backbone mạnh và sự đơn giản trong việc xử lý độ dài biến thiên bao gồm ngắt dòng trong chuỗi đầu vào. CodeBERT đã chứng minh hiệu suất thực nghiệm mạnh trên các nhiệm vụ downstream nên các biểu diễn đã học nên phù hợp tốt cho định vị lỗi. Để chứng minh tính hữu ích của ngữ cảnh dài cho hiểu code, chúng tôi cũng sử dụng Longformer tiêu chuẩn (Beltagy et al., 2020) như một bộ mã hóa. Việc ánh xạ từ các vector được ngữ cảnh hóa thành vector tiềm ẩn cho phép các chuỗi đầu vào có độ dài biến thiên và tránh xử lý đặc biệt của ký tự xuống dòng. Việc căn chỉnh từ các dòng của chuỗi đầu vào thành vector tiềm ẩn cho phân loại được học ngầm bởi supervision.

Mô hình Recall↑ Precision↑ F1↑
Tổng hợp Thực tế Tổng hợp Thực tế Tổng hợp Thực tế
Random 49.58 50.99 2.68 0.96 5.08 1.88
Pooling 93.48 69.43 8.89 2.16 16.24 4.17
Pooling-Attn 95.37 64.66 26.93 1.84 42.00 3.58

Bảng 2: So sánh độ chính xác phân loại nhị phân dưới các baseline khác nhau: (1) Bộ phân loại Bernoulli ngẫu nhiên với p = 0.5, (2) Mô hình mean pooling, (3) Mô hình mean pooling với self-attention giữa các vector tiềm ẩn.

Mô hình Huấn luyện Recall↑ Precision↑ F1↑
Tổng hợp. Thực. Tổng hợp. Thực. Tổng hợp. Thực.
Longformer-4096 Tổng hợp 98.49 42.98 22.62 3.74 36.79 6.88
Longformer-512 Tổng hợp 97.54 46.44 18.78 3.94 31.50 7.27
Longformer-4096 Thực 73.28 75.40 5.92 2.65 10.96 5.12
Longformer-512 Thực 81.28 88.68 5.95 2.46 11.09 4.79

Bảng 3: So sánh các Mô hình Longformer. Các số liệu cho thấy rằng huấn luyện tổng hợp là một nhiệm vụ proxy phù hợp cho phát hiện lỗi thực tế so với huấn luyện thực tế độc quyền và lợi thế của ngữ cảnh dài trên dữ liệu tổng hợp.

5.3 KẾT QUẢ

Để đánh giá độ khó của điểm chuẩn BigIssue nhân tạo và thực tế, mô hình nói trên được huấn luyện trên cả hai tập dữ liệu. Chi tiết huấn luyện có thể được tìm thấy trong Phụ lục B.

7

--- TRANG 8 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

Bảng 2 tóm tắt hiệu suất phân loại nhị phân về recall, precision và F1-score cho ba mô hình baseline với bộ mã hóa CodeBERT: (1) Một bộ phân loại ngẫu nhiên mà các dự đoán cấp dòng được mô hình hóa như một biến ngẫu nhiên Bernoulli mỗi dòng với xác suất p = 0.5, (2) một mô hình dựa trên mean-pooling mà lớp self-attention giữa các vector tiềm ẩn bị bỏ qua, (3) một mô hình dựa trên mean-pooling bao gồm self-attention giữa các vector tiềm ẩn.

Đối với tập dữ liệu tổng hợp, mô hình mean-pooling bao gồm self-attention với F1-score 42.00 cải thiện đáng kể so với baseline Bernoulli ngẫu nhiên với 5.08. Self-attention để tích hợp thông tin qua các vector tiềm ẩn cải thiện điểm số gần 26 điểm, điều này có thể chỉ ra rằng attention qua việc phân vùng 512 token là quan trọng. Người ta có thể giả định với những cải thiện thêm trong mô hình hóa, tập dữ liệu tổng hợp có thể giải quyết được.

Đối với điểm chuẩn thực tế, tuy nhiên, cả hai mô hình baseline mean-pooling đều có hiệu suất tốt hơn ngẫu nhiên. Lớp attention bổ sung không thêm bất kỳ cải thiện nào. Cả hai mô hình đều có xu hướng có giá trị recall cao, nhưng precision đặc biệt thấp đối với điểm chuẩn thực tế.

Để kiểm tra hiệu ứng của các bộ mã hóa ngữ cảnh dài hơn, chúng tôi thay thế bộ mã hóa trong mô hình Mean-Pooling with Attention của chúng tôi bằng một Longformer (Beltagy et al., 2020) có khả năng xử lý các chuỗi lên đến 4096 token. Thay vì chia chuỗi thành 16 chunk của 512, chúng tôi chia nó thành 2 chunk của 4096. Chúng tôi huấn luyện một mô hình Longformer-4096 token Mean-Pooling with Attention. Chúng tôi cũng huấn luyện cùng mô hình chỉ trên dữ liệu thực tế. Kết quả sau 50.000 bước huấn luyện được trình bày trong Bảng 3. Kết quả trên dữ liệu tổng hợp cho thấy rằng các bộ mã hóa ngữ cảnh dài hơn cải thiện hiệu suất. Trong khi mô hình chia 512-chunk có hiệu suất tốt hơn mô hình chia 4096-chunk trên dữ liệu thực tế, sự khác biệt không thể được mô tả là đáng kể do giá trị precision thấp.

Như đã giả thuyết, phát hiện lỗi thực là một thách thức khó khăn hơn nhiều so với dữ liệu tổng hợp. Các mô hình đơn giản không thể giải quyết các lỗi thực tế với sự thành công như các lỗi tổng hợp, cho thấy rằng lỗi tổng hợp là một kiểm tra tỉnh táo phù hợp cho các mô hình định vị lỗi. Các phát hiện cũng cho thấy rằng việc sử dụng ngữ cảnh dài hơn có hiệu quả để bắt lỗi tổng hợp. Chúng tôi hy vọng rằng phát hiện này sẽ thúc đẩy nghiên cứu về mô hình hóa ngữ cảnh dài để tiếp cận nhiệm vụ phát hiện lỗi thực.

6 KẾT LUẬN

Chúng tôi đề xuất một điểm chuẩn thực tế mới cho định vị lỗi cấp dòng không dựa vào bộ test. Chúng tôi cũng cung cấp một điểm chuẩn và tập dữ liệu tổng hợp, được tạo ra với các phương pháp tinh vi hơn so với công việc trước đây. Chúng tôi cũng chỉ ra rằng bất chấp sự khác biệt giữa lỗi tổng hợp và thực tế, các điểm chuẩn tổng hợp có thể được sử dụng như một kiểm tra tỉnh táo cho các mô hình định vị lỗi. Sử dụng tập dữ liệu tổng hợp, chúng tôi chỉ ra rằng mã hóa ngữ cảnh dài giúp ích trong định vị lỗi, và chúng tôi hy vọng rằng những kết quả này thúc đẩy nghiên cứu về ngữ cảnh dài cho kỹ thuật định vị lỗi thực tế.

Chúng tôi hy vọng rằng những đóng góp của chúng tôi sẽ truyền cảm hứng và thúc đẩy nghiên cứu tương lai về các kỹ thuật định vị lỗi thực tế, ngữ cảnh dài, dựa trên NLP. Những tiến bộ trong lĩnh vực này sẽ đưa sửa chữa chương trình tự động đến một trạng thái hữu ích và thay đổi quy trình phát triển phần mềm hiện đại.

TÀI LIỆU THAM KHẢO

Iz Beltagy, Matthew E Peters, and Arman Cohan. Longformer: The long-document transformer.
arXiv preprint arXiv:2004.05150, 2020.

Berkay Berabi, Jingxuan He, Veselin Raychev, and Martin Vechev. Tfix: Learning to fix coding
errors with a text-to-text transformer. In International Conference on Machine Learning, pp.
780–791. PMLR, 2021.

Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal,
Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are
few-shot learners. Advances in neural information processing systems, 33:1877–1901, 2020.

Efstathia Chioteli, Ioannis Batas, and Diomidis Spinellis. Does unit-tested code crash? a case study
of eclipse. In 25th Pan-Hellenic Conference on Informatics, pp. 260–264, 2021.

8

--- TRANG 9 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

Valentin Dallmeier and Thomas Zimmermann. Extraction of bug localization benchmarks from
history. In Proceedings of the twenty-second IEEE/ACM international conference on Automated
software engineering, pp. 433–436, 2007.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep
bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.

Dawn Drain, Colin B Clement, Guillermo Serrato, and Neel Sundaresan. Deepdebug: Fixing python
bugs using stack traces, backtranslation, and code skeletons. arXiv preprint arXiv:2105.09352,
2021.

Zhengxiao Du, Yujie Qian, Xiao Liu, Ming Ding, Jiezhong Qiu, Zhilin Yang, and Jie Tang. Glm:
General language model pretraining with autoregressive blank infilling. In Proceedings of the
60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),
pp. 320–335, 2022.

Thomas Durieux, Fernanda Madeiral, Matias Martinez, and Rui Abreu. Empirical review of java
program repair tools: A large-scale experiment on 2,141 bugs and 23,551 repair attempts. In
Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering, pp. 302–313, 2019.

Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing
Qin, Ting Liu, Daxin Jiang, et al. Codebert: A pre-trained model for programming and natural
languages. arXiv preprint arXiv:2002.08155, 2020a.

Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing
Qin, Ting Liu, Daxin Jiang, et al. Codebert: A pre-trained model for programming and natural
languages. arXiv preprint arXiv:2002.08155, 2020b.

Daniel Fried, Armen Aghajanyan, Jessy Lin, Sida Wang, Eric Wallace, Freda Shi, Ruiqi Zhong,
Wen-tau Yih, Luke Zettlemoyer, and Mike Lewis. Incoder: A generative model for code infilling
and synthesis. arXiv preprint arXiv:2204.05999, 2022.

Nan Jiang, Thibaud Lutellier, and Lin Tan. Cure: Code-aware neural machine translation for automatic program repair. In 2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE), pp. 1161–1173. IEEE, 2021.

James A Jones and Mary Jean Harrold. Empirical evaluation of the tarantula automatic fault-
localization technique. In Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering, pp. 273–282, 2005.

René Just, Darioush Jalali, and Michael D Ernst. Defects4j: A database of existing faults to enable
controlled testing studies for java programs. In Proceedings of the 2014 International Symposium
on Software Testing and Analysis, pp. 437–440, 2014.

Aditya Kanade, Petros Maniatis, Gogul Balakrishnan, and Kensen Shi. Learning and evaluating
contextual embedding of source code. In International Conference on Machine Learning, pp.
5110–5121. PMLR, 2020.

Rafael-Michael Karampatsis and Charles Sutton. How often do single-statement bugs occur? the
manysstubs4j dataset. In Proceedings of the 17th International Conference on Mining Software
Repositories, pp. 573–577, 2020.

Fabian Keller, Lars Grunske, Simon Heiden, Antonio Filieri, Andre van Hoorn, and David Lo. A
critical evaluation of spectrum-based fault localization techniques on a large-scale software system. In 2017 IEEE International Conference on Software Quality, Reliability and Security (QRS),
pp. 114–125. IEEE, 2017.

Sumith Kulal, Panupong Pasupat, Kartik Chandra, Mina Lee, Oded Padon, Alex Aiken, and Percy S
Liang. Spoc: Search-based pseudocode to code. Advances in Neural Information Processing
Systems, 32, 2019.

9

--- TRANG 10 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

An Ngoc Lam, Anh Tuan Nguyen, Hoan Anh Nguyen, and Tien N Nguyen. Bug localization with
combination of deep learning and information retrieval. In 2017 IEEE/ACM 25th International
Conference on Program Comprehension (ICPC), pp. 218–229. IEEE, 2017.

Yi Li, Shaohua Wang, and Tien N Nguyen. Dlfix: Context-based code transformation learning for
automated program repair. In Proceedings of the ACM/IEEE 42nd International Conference on
Software Engineering, pp. 602–614, 2020.

Kui Liu, Anil Koyuncu, Tegawendé F Bissyandé, Dongsun Kim, Jacques Klein, and Yves Le Traon.
You cannot fix what you cannot find! an investigation of fault localization bias in benchmarking
automated program repair systems. In 2019 12th IEEE conference on software testing, validation
and verification (ICST), pp. 102–113. IEEE, 2019a.

Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike
Lewis, Luke Zettlemoyer, and Veselin Stoyanov. Roberta: A robustly optimized bert pretraining
approach. arXiv preprint arXiv:1907.11692, 2019b.

Ilya Loshchilov and Frank Hutter. Decoupled weight decay regularization. arXiv preprint
arXiv:1711.05101, 2017.

Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan. Coconut:
combining context-aware neural translation models using ensemble for program repair. In Proceedings of the 29th ACM SIGSOFT international symposium on software testing and analysis,
pp. 101–114, 2020.

Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu. Improving fault localization and program repair with deep semantic features and transferred knowledge. In Proceedings
of the 44th International Conference on Software Engineering, pp. 1169–1180, 2022.

S Amirhossein Mousavi, Donya Azizi Babani, and Francesco Flammini. Obstacles in fully automatic program repair: A survey. arXiv preprint arXiv:2011.02714, 2020.

Ripon K Saha, Yingjun Lyu, Wing Lam, Hiroaki Yoshida, and Mukul R Prasad. Bugs.jar: a large-
scale, diverse dataset of real-world java bugs. In Proceedings of the 15th international conference
on mining software repositories, pp. 10–13, 2018.

Michele Tufano, Cody Watson, Gabriele Bavota, Massimiliano Di Penta, Martin White, and Denys
Poshyvanyk. An empirical investigation into learning bug-fixing patches in the wild via neural
machine translation. In Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, pp. 832–837, 2018.

Michihiro Yasunaga and Percy Liang. Graph-based, self-supervised program repair from diagnostic
feedback. In International Conference on Machine Learning, pp. 10799–10808. PMLR, 2020.

Michihiro Yasunaga and Percy Liang. Break-it-fix-it: Unsupervised learning for program repair. In
International Conference on Machine Learning, pp. 11941–11952. PMLR, 2021.

Wei Yuan, Quanjun Zhang, Tieke He, Chunrong Fang, Nguyen Quoc Viet Hung, Xiaodong Hao,
and Hongzhi Yin. Circle: Continual repair across programming languages. arXiv preprint
arXiv:2205.10956, 2022.

Daming Zou, Jingjing Liang, Yingfei Xiong, Michael D Ernst, and Lu Zhang. An empirical study of
fault localization families and their combinations. IEEE Transactions on Software Engineering,
47(2):332–347, 2019.

10

--- TRANG 11 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

A MÔ TẢ DỮ LIỆU, CHI TIẾT LƯU TRỮ, VÀ TRUY CẬP DỮ LIỆU

Chúng tôi xuất bản các tập huấn luyện, đánh giá, và xác thực cho dữ liệu tổng hợp. Chúng tôi cũng xuất bản điểm chuẩn thực tế. Những mục này có thể được truy cập trong một bucket Google Cloud Storage tại
https://console.cloud.google.com/storage/browser/bigissue-research.

Tất cả tài liệu được phát hành dưới Giấy phép MIT.

Dữ liệu huấn luyện trước Thực tế Đối với các mô hình Pooling và Pooling-Attention thực tế, chúng tôi tạo ra một tập dữ liệu huấn luyện trước tương tự như các dự án khác. Chúng tôi chọn các kho lưu trữ Java GitHub có từ 5 sao trở lên, chúng tôi clone nhánh chính của kho lưu trữ, trong khi chỉ tải xuống các tệp dưới 2 megabyte. Sau đó chúng tôi lọc các commit bao gồm các từ "error", "bug", "fix", "issue", "mistake", "incorrect", "fault", "defect", "flaw", hoặc "type", sử dụng thực hành tiêu chuẩn trong dự án ManySStubs4J Karampatsis & Sutton (2020). Vì các mô hình của chúng tôi được thiết kế chỉ cho định vị lỗi một tệp, chúng tôi lấy mỗi tệp được sửa đổi và áp dụng quy trình gắn nhãn được mô tả trong bài báo để tạo ra các ví dụ và nhãn. Chúng tôi cắt ngắn các tệp ở 8192 token theo cách tương tự như trong Feng et al. (2020a). Tổng cộng, chúng tôi có khoảng 195 GB dữ liệu để sử dụng cho huấn luyện trước.

B CHI TIẾT HUẤN LUYỆN

Chúng tôi huấn luyện tất cả các mô hình của chúng tôi trên một pod duy nhất với 16 GPU A100. Đối với các mô hình với bộ mã hóa CodeBERT, chúng tôi tối ưu hóa mô hình với bộ tối ưu hóa AdamW lịch trình tuyến tính Loshchilov & Hutter (2017), với tốc độ học bắt đầu là 5e-5, và 10.000 bước warmup. Chúng tôi huấn luyện qua 50.000 bước với batch size là 8. Đối với các mô hình với bộ mã hóa Longformer, chúng tôi tối ưu hóa với bộ tối ưu hóa AdamW lịch trình tuyến tính, tốc độ học bắt đầu là 3e-5, và 1000 bước warmup.

Chúng tôi cung cấp code huấn luyện đầy đủ tại https://anonymous.4open.science/r/BigIssue-8EE2/.

Checkpoint Mô hình Chúng tôi cung cấp các checkpoint mô hình cho các mô hình Pooling và Pooling-Attention được huấn luyện trên dữ liệu thực tế trong kho lưu trữ GitHub https://anonymous.4open.science/r/BigIssue-8EE2/.

C TUYÊN BỐ ĐẠO ĐỨC THU THẬP DỮ LIỆU

Chúng tôi không thu thập bất kỳ thông tin cá nhân nào từ GitHub API. Chúng tôi chỉ thu thập thông tin commit và dữ liệu bên trong các commit, mà không tính đến nguồn gốc hoặc hồ sơ người dùng của người dùng thực hiện thay đổi.

Chúng tôi cũng trình bày ở đây danh sách các giấy phép mà chúng tôi sử dụng trong bài báo của chúng tôi:
https://anonymous.4open.science/r/BigIssue-8EE2/licences.txt

D PHÂN TÍCH LỖI THỰC TẾ

Chúng tôi đã phân tích chất lượng của quy trình lựa chọn của chúng tôi bằng cách lấy mẫu 100 issue ngẫu nhiên. Điều này sẽ cho phép các nhà nghiên cứu khác sử dụng phương pháp này với tính linh hoạt lớn hơn trong cấp phép. Chúng tôi phân tích chúng dựa trên ba tiêu chí: (a) liệu issue có đại diện cho một lỗi hợp lệ (b) liệu bản sửa có đại diện cho một bản sửa hợp lệ cho lỗi và (c) liệu bản sửa có phụ thuộc vào quy ước code hoặc API, và do đó có thể xác định được bởi một con người có kiến thức đầy đủ về những điều trên. Tiêu chí cuối cùng là để đảm bảo khả năng xác định có thể bởi một mô hình: nếu một lỗi chỉ được đánh dấu như vậy vì tiêu chí phần mềm bên ngoài, không có cách hợp lý nào một mô hình có thể học mẫu lỗi đó.

Tổng cộng, chúng tôi đã thu thập:
• 84 issue hợp lệ.
• 3 issue không đại diện cho lỗi hợp lệ.
• 3 issue mà các bản sửa không sửa lỗi.
• 2 issue không phải đối tượng phân tích.

11

--- TRANG 12 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

• 8 issue không thể xác định được mà không có ngữ cảnh bên ngoài.

Mỗi mục trong danh sách sau đây đại diện cho một issue được xem xét cho tập dữ liệu của chúng tôi và được xác định bằng liên kết tương ứng đến github issue. Chúng tôi đặt trước các issue không hợp lệ với "*" để rõ ràng.

1. * -https://github.com/gsantner/markor/issues/314 - Lỗi hợp lệ, nhưng bản sửa không giải quyết vấn đề. Thực tế issue vẫn tồn tại bất chấp issue đã được đóng.

2.https://github.com/ReplayMod/ReplayMod/issues/422 - Lỗi hợp lệ, bản sửa hợp lệ cho lỗi, lỗi có thể xác định thông qua việc sử dụng tương tự code xung quanh khu vực bị lỗi.

3.https://github.com/lingochamp/FileDownloader/issues/855 - Lỗi hợp lệ, bản sửa một dòng hợp lệ cho tệp, lỗi có thể xác định vì 'model.status' đang được đặt trong hầu hết tất cả các phương thức hành động của lớp này.

4.https://github.com/danielCantwell/Fit-Friend/issues/3 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định bởi thực tế rằng các biến được sử dụng trong khu vực code cụ thể đó không được sử dụng chút nào.

5.https://github.com/OpenJEVis/JEVis/issues/1699 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi là trường hợp edge nếu các mẫu JEVis không được lấy mẫu theo khoảng thời gian đều đặn. Lỗi có thể xác định vì sự tương đồng trong tương tác chuỗi thời gian.

6.https://github.com/TechReborn/TechReborn/issues/549 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định vì (a) rất nhiều giá trị được hard-code và (b) một số biến không tuân theo logic con người về những gì một "operator" minecraft được cho là làm (ví dụ không kiểm tra xem có bất kỳ không gian nào trong container đầu ra cho nhiều item hơn để đi vào).

7.https://github.com/milaboratory/mixcr/issues/509 - Lỗi hợp lệ, bản sửa hợp lệ, mặc dù có các sửa style bổ sung. Sửa style là bất cứ khi nào "percentage" được sử dụng, text cho log phải được viết như "percent used ". Điều này tuân theo một mẫu từ những nơi khác trong kho lưu trữ này. Lỗi là các phần trăm đôi khi có thể hơn 100

8. * -https://github.com/Angry-Pixel/The-Betweenlands/issues/895 - Lỗi hợp lệ, và bản sửa hợp lệ, nhưng lỗi không thể xác định chung bởi con người mà không có ngữ cảnh bên ngoài. Lỗi minecraft cho thấy rằng một item nhất định phải không thể sửa chữa, nhưng từ code riêng dường như không có gợi ý rằng item này nên không thể sửa chữa.

9.https://github.com/VazkiiMods/Quark/issues/2920 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định bởi con người nếu họ có kiến thức và ngữ cảnh về thư viện Create không thể chấp nhận FakePlayers như players khi thực hiện các hoạt động trên thế giới.

10.https://github.com/15knots/cmake4eclipse/issues/26 - Lỗi hợp lệ, bản sửa hợp lệ. Bản chất của lỗi là các thư mục build nhất định có thể bị xóa bên ngoài Eclipse, và điều đó cần được xử lý bởi code, đây là một biện pháp bảo vệ chung mà code cần triển khai.

11.https://github.com/TheThirdOne/JSoftFloat/issues/1 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi này nên có thể xác định với kiến thức về tính toán số học dấu phẩy động.

12.https://github.com/ververica/flink-cdc-connectors/issues/326 - Lỗi hợp lệ, bản sửa hợp lệ. Để xác định lỗi này, người ta cần biết rằng một tham số nhất định trong config có thể là null. Cụ thể, nếu không có database history ID được xác định trước, một cái phải được đặt.

13.https://github.com/spring-cloud/spring-cloud-sleuth/issues/333 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định dựa trên việc sử dụng hiện có từ các dịch vụ Callable khác, nơi lớp thường được sử dụng như một wrapper cho các cuộc gọi.

14.https://github.com/tango-controls/rest-server/issues/192 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định với kiến thức về đặc tả API TANGO.

15.https://github.com/guillaume-alvarez/ShapeOfThingsT hatWere/issues/7 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là logic di chuyển camera được gắn với xử lý frame, và nếu mẫu đó được biết thì lỗi có thể xác định.

12

--- TRANG 13 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

16.https://github.com/spring-cloud/spring-cloud-config/issues/128 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định bằng các mẫu tải environment chung.

17.https://github.com/BentoBoxWorld/TwerkingForTrees/issues/9 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định bằng logic minecraft không cho phép players sửa đổi block bên ngoài biên giới thế giới.

18.https://github.com/requery/requery/issues/63 - Lỗi hợp lệ, bản sửa hợp lệ: vấn đề đã biết trong SQLite https://stackoverflow.com/questions/28385069/sqlite openhelper-setwriteaheadloggingenabled-causes-an-error-log-line.

19. * -https://github.com/mpcjanssen/ubiquitous-capture/issues/4 - Lỗi hợp lệ, bản sửa hợp lệ. Không thể xác định vì đây cơ bản là lỗi UX.

20.https://github.com/assertj/assertj-vavr/issues/141 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định dựa trên các mẫu khác trong cùng kho lưu trữ.

21.https://github.com/smartdevicelink/sdl_java_suite/issues/53 - Issue hợp lệ, bản sửa hợp lệ. Có thể xác định thông qua các mẫu tương tự khác trong code tương tự trong kho lưu trữ.

22.https://github.com/darcy-framework/darcy-webdriver/issues/30 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định thông qua các mẫu tương tự khác trong code tương tự trong kho lưu trữ.

23. * -https://github.com/AlexFalappa/nb-springboot/issues/167 - Lỗi hợp lệ, bản sửa hợp lệ. Không thể xác định.

24.https://github.com/GabrielOlvH/Carrier/issues/2 - Issue hợp lệ, bản sửa không vĩnh viễn, nhưng thực sự chỉ đúng đến vị trí của vấn đề. Vấn đề, nói chung, được gây ra bởi thực tế rằng entity Wolf khác với tất cả các entity khác, và do đó việc gọi phương thức updateHolding trên nó sẽ gây ra vấn đề.

25.https://github.com/AgriCraft/AgriCraft/issues/82 - Issue hợp lệ, bản sửa hợp lệ. Đó là logic có thể xác định bởi con người bằng cách nhìn vào tên biến và việc sử dụng dự định.

26.https://github.com/rasmus-saks/aken-ajalukku/issues/65 - Issue hợp lệ, bản sửa hợp lệ. Có thể xác định dựa trên ngữ cảnh của ứng dụng, thực tế rằng đây thực sự là một "walking tour", do đó chế độ trên google maps nên là cho "walking" thay vì lái xe.

27.https://github.com/CJMinecraft01/DoubleSlabs/issues/81 - Issue hợp lệ, bản sửa hợp lệ. Bản sửa có thể xác định về nguyên tắc, nhưng cần rất nhiều ngữ cảnh về cách minecraft slab tương tác.

28.https://github.com/hzi-braunschweig/SORMAS-Project/issues/6832 - Issue hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định, ngày bắt đầu được thay thế bằng Ngày kết thúc trong một số trường hợp trên records.

29.https://github.com/MachinePublishers/jBrowserDriver/issues/67 - Issue hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định trong ngữ cảnh dài và với kiến thức về mẫu tạo cookie chung. Vấn đề là domain cho cookie không được đặt, vì vậy nó không được sử dụng bởi web-driver trong các lần truy cập lặp lại vào một website.

30.https://github.com/release-engineering/pom-manipulation-ext/issues/240 - Issue hợp lệ, bản sửa hợp lệ. Cái này chỉ sửa một NPE, nhưng nó chứa rất nhiều thay đổi style/whitespace.

31.https://github.com/Angry-Pixel/The-Betweenlands/issues/948 - Lỗi hợp lệ, bản sửa hợp lệ. Cái này về nguyên tắc có thể xác định với kiến thức về mẫu trong các server minecraft để có các loại block khác nhau tạo thành một "entity" duy nhất (một cánh cửa trong trường hợp này).

32.https://github.com/ehcache/ehcache3/issues/2638 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi đơn giản và có thể xác định.

13

--- TRANG 14 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

33.https://github.com/thingsboard/thingsboard/issues/3992 - Lỗi hợp lệ, bản sửa hợp lệ. Bản chất là phương thức getDeviceTypes nên gọi api endpoint "/devices/types" thay vì "/devices". Nên có thể xác định dựa trên ngữ cảnh ngữ nghĩa.

34.https://github.com/vert-x3/vertx-config/issues/20 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi dễ xác định vì (a) Vertx thường được sử dụng trong code, và (b) biến "host" được để không sử dụng bất chấp được khai báo, và chỉ có một nơi logic mà nó có thể được sử dụng tiềm năng.

35.https://github.com/metarhia/jstp-java/issues/24 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định với ngữ cảnh về lớp ExecutionHandler.

36. * -https://github.com/Cassiobsk8/Industrial_Renewal/issues/126 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi này khó xác định vì (a) bản sửa là ghi đè một phương thức cụ thể của lớp và (b) không rõ ràng rằng có thể có một sự cản trở với giường tầng.

37.https://github.com/Tamaized/AoV/issues/13 - Lỗi hợp lệ, bản sửa hợp lệ. Chứa một số bổ sung whitespace ngoài việc sửa lỗi. Lỗi liên quan đến một tùy chọn config nhất định không được sử dụng, có thể xác định thông qua hiểu biết ngữ nghĩa về code.

38. * -https://github.com/PyvesB/advanced-achievements/issues/172 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi khó xác định, vì nó đòi hỏi ngữ cảnh về hoạt động brewing stand.

39.https://github.com/eclipse/vorto/issues/442 - Lỗi hợp lệ, bản sửa hợp lệ. Issue có thể xác định bởi thực tế rằng resource id được hard-code thành "0" thay vì biến "resourceId" được cung cấp. Cũng có thể xác định về mặt ngữ nghĩa. Chứa các thay đổi whitespace cũng.

40.https://github.com/hsyyid/AdminShop/issues/5 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định.

41. * -https://github.com/labhackercd/edm/issues/5 - Lỗi hợp lệ, không chắc chắn nếu bản sửa hợp lệ. Lỗi có ít thông tin, và crash mà lỗi báo cáo dường như không thể xác định từ code riêng (có thể phụ thuộc vào thiết bị, nhưng mẫu được sử dụng được coi là lỗi được khuyến nghị rộng rãi, xem https://stackoverflow.com/questions/2422562/how-to-change-theme-for-alertdialog).

42.https://github.com/Haptic-Apps/Slide/issues/655 - Lỗi hợp lệ, bản sửa hợp lệ. Một exception run-time từ một phương thức nên được bắt.

43. * -https://github.com/PortuguesDoSeculoXXI/PortuguesDoSeculoXXI/issues/48 - Không chắc chắn, khó xác định, có rất nhiều text bằng tiếng Bồ Đào Nha

44.https://github.com/OpenJEVis/JEVis/issues/840 - Lỗi hợp lệ, bản sửa hợp lệ. Mặc dù text bằng tiếng Đức, lỗi về xử lý một danh sách items thành menu thay vì chỉ một. Đây không phải là "feature" mới, vì các items cần xử lý luôn được đóng gói trong một "list" có độ dài biến thiên.

45.https://github.com/commons-app/apps-android-commons/issues/587 - Lỗi hợp lệ, bản sửa hợp lệ. Links cần được sanitized.

46.https://github.com/twizmwazin/CardinalPGM/issues/86 - Lỗi hợp lệ, bản sửa hợp lệ. Một lịch trình chu kỳ bản đồ chỉ được đặt khi thời gian dưới 5 giây, vì vậy việc lên lịch cần được di chuyển ra khỏi câu lệnh if cụ thể đó.

47. * -https://github.com/assemblits/eru/issues/100 - Không phải lỗi hợp lệ. Thay đổi chỉ là thay đổi tiêu đề của một alert để đặt nó thành tên lớp thay vì thông báo "connection failure" chung.

48.https://github.com/MachinePublishers/jBrowserDriver/issues/21 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là cookies đến trong rất nhiều định dạng, và không phải tất cả đều được hỗ trợ bởi jBrowser.

49.https://github.com/lucas-tulio/server-simulator/issues/6 - Lỗi hợp lệ, bản sửa không hợp lệ.

14

--- TRANG 15 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

50.https://github.com/spring-cloud/spring-cloud-netflix/issues/1724 - Lỗi hợp lệ, bản sửa hợp lệ. Thuộc tính cho preferIPAddress không được tính đến. Config cần để có thể xác định issue này.

51.https://github.com/Col-E/Recaf/issues/344 - Lỗi hợp lệ, bản sửa hợp lệ. Phiên bản trước thay thế tất cả $ trong tên lớp bằng ., nhưng chỉ cái cuối cùng cần được thay thế theo quy ước.

52.https://github.com/plan-player-analytics/Plan/issues/1313 - Lỗi hợp lệ, bản sửa hợp lệ. Front-end gọi endpoint sai, và backend được điều chỉnh để front-end gọi endpoint đúng để lấy danh sách players cho một server.

53. * -https://github.com/cabaletta/baritone/issues/330 - Không thực sự là lỗi, giống như feature bổ sung hơn. Cũng có tag "enhancement".

54.https://github.com/sosy-lab/java-common-lib/issues/19 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là một trong các iterator trong một phương thức trả về danh sách đã sắp xếp của hai collections không được sử dụng hết hoàn toàn.

55.https://github.com/Cactiw/Timetable/issues/4 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là một nhiệm vụ update không được đặt vào một cuộc gọi async, và do đó gây ra vấn đề downstream. Đặt nó trong async sửa issue.

56.https://github.com/jooby-project/jooby/issues/1489 - Lỗi hợp lệ, bản sửa hợp lệ. Khá dễ xác định rằng factory được đóng thay vì session vừa được kiểm tra trong câu lệnh if xung quanh.

57.https://github.com/Gaming32/ArrayV-v4.0/issues/43 - Lỗi hợp lệ, bản sửa hợp lệ. Phương thức rõ ràng nên được synchronized dựa trên code xung quanh không được synchronized.

58.https://github.com/Zedd7/ZHorse/issues/25 - Lỗi hợp lệ, bản sửa hợp lệ. Con ngựa duplicate không được gán tên, vì vậy khi "xóa" nó thì thông báo nên hiển thị tên con ngựa gốc.

59.https://github.com/neo4j-contrib/neo4j-apoc-procedures/issues/303 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là hai node không thể có cùng "main key", và khi merge hai node thì node trước không được xóa do đó gây ra exception. Giải pháp là các thuộc tính của source node nên được lưu trữ, source node bị xóa, và sau đó các thuộc tính của source node phải được tải vào target node từ biến đã lưu trữ.

60.https://github.com/mikepenz/CrossfadeDrawerLayout/issues/15 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi là khi mở/đóng drawer, trạng thái không nhất thiết được cập nhật. Bản sửa là ghi đè các phương thức thích hợp để cập nhật trạng thái. Có thể xác định bằng mẫu chung của cập nhật trạng thái khi gọi các phương thức lớp cha nhất định.

61.https://github.com/wultra/powerauth-webflow/issues/345 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là thông báo của logger không phù hợp với exception được bắt. Cũng có một số thay đổi whitespace được thêm trong commit.

62.https://github.com/TeamLapen/Vampirism/issues/333 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi off-by-one, có thể xác định bằng cách biết về minecraft item stack cũng như nhìn chung nhìn quanh code.

63.https://github.com/home-climate-control/dz/issues/144 - Lỗi hợp lệ, bản sửa hợp lệ. Các tham số authentication được truyền cho bean thực sự không được đặt khi tạo bean. Lỗi có thể xác định.

64.https://github.com/kontalk/androidclient/issues/1264- Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là dịch vụ push notification sẽ không được khởi động như một dịch vụ foreground và hệ thống sẽ kill nó sau 15 giây. Bản sửa là khởi động nó trong foreground trước. Có thể xác định vì đây là mẫu chung trong các ứng dụng nhắn tin.

65.https://github.com/BetonQuest/BetonQuest/issues/734 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là phương thức được sử dụng trước đây để phát hiện cái chết entity trong Minecraft dưới tối ưu, và nó được thay thế bằng một phương thức tốt hơn được thấy trong một minecraft plugin khác. Có thể xác định với kiến thức về các mẫu sử dụng thư viện spigot.

15

--- TRANG 16 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

66.https://github.com/jmockit/jmockit1/issues/98 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là đôi khi các loại nên là null không được mock như null objects. Bản sửa giải quyết những trường hợp này với cascading types. Lỗi có thể xác định với kiến thức về các mẫu mocking.

67. * -https://github.com/Freeyourgadget/Gadgetbridge/issues/529 - Issue không hợp lệ đã bị xóa.

68.https://github.com/scenerygraphics/sciview/issues/181 - Lỗi hợp lệ, bản sửa hợp lệ. Người ta cần gọi setSize trên panel trước khi hiển thị nó, và bản sửa giải quyết điều đó.

69.https://github.com/ramack/ActivityDiary/issues/153 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định thông qua ngữ cảnh app.

70.https://github.com/decarbonization/android-fonz/issues/26 - Lỗi hợp lệ, bản sửa hợp lệ. Type mismatch trong settings làm crash app. Có thể xác định từ các quy ước thuộc tính android.

71.https://github.com/ICIJ/datashare/issues/41 - Lỗi hợp lệ, bản sửa hợp lệ. Sửa các biểu diễn mã ISO của ngôn ngữ bằng a) thêm nhiều enum hơn và b) sử dụng cả mã iso1 và iso2 để xác định một ngôn ngữ. Nên dễ xác định vì cả tham số iso1 và iso2 đều được truyền vào.

72.https://github.com/twizmwazin/CardinalPGM/issues/645- Lỗi hợp lệ, bản sửa hợp lệ. Bản sửa là sử dụng API cấp cao hơn được cung cấp bởi thư viện được đề cập, và đơn giản hóa code hiện có đáng kể và thêm hỗ trợ để phát hiện thiệt hại TNT và tính điểm. Nên có thể xác định với toàn bộ ngữ cảnh thư viện.

73. * -https://github.com/manoelcampos/cloudsimplus/issues/368 - Lỗi hợp lệ, bản sửa hợp lệ. Đây là một issue khó xác định vì nó dựa trên configuration/resource usage, và phụ thuộc vào các tham số hệ thống rất nhiều.

74. * -https://github.com/almosr/android-svg-code-render/issues/67 - Lỗi hợp lệ, bản sửa hợp lệ. Không thể xác định do lỗi trong templating.

75.https://github.com/dcm4che/dcm4chee-arc-light/issues/523 - Lỗi hợp lệ, bản sửa hợp lệ. Khi một nghiên cứu bị xóa, số lượng nghiên cứu mà bệnh nhân của nghiên cứu này tham gia phải được giảm. Có thể xác định với hiểu biết về mối quan hệ giữa bệnh nhân và nghiên cứu.

76. * -https://github.com/BCA-Team/Buildcraft-Additions/issues/356 - Lỗi hợp lệ, bản sửa hợp lệ. Laser Minecraft được bắn dưới nước bị kẹt. Bản sửa triển khai logic tiêu tan laser một khi nó chạm lava hoặc nước. Không thể xác định mà không biết logic trong app về laser và hành vi mong đợi khi chạm nước hoặc lava.

77.https://github.com/TotalHamman/BetterBlockExchanger/issues/7 - Lỗi hợp lệ, bản sửa hợp lệ. App đang đọc trạng thái từ trạng thái "previous" trong một swap thay vì trạng thái "current", gây ra NPE.

78.https://github.com/BasicAirData/GPSLogger/issues/132- Lỗi hợp lệ, bản sửa hợp lệ. Nội dung của một biến mà switch được điều kiện có thể là null, và điều đó gây ra NPE.

79.https://github.com/OfficeDev/ews-java-api/issues/8 - Lỗi hợp lệ, bản sửa hợp lệ. Lỗi có thể xác định bởi thực tế rằng có một biến được sử dụng, và nơi duy nhất mà nó có thể được sử dụng hợp lý là trong một method override của một phương thức được kế thừa từ lớp cha.

80.https://github.com/dcm4che/dcm4chee-arc-light/issues/1180 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là chương trình gán "type" của một SOP instance không theo đặc tả DICOM. Kiến thức về đặc tả DICOM cần thiết để xác định lỗi.

81.https://github.com/LMBishop/Quests/issues/281 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là player quest không được khôi phục cho player object một khi player tham gia server. Có thể xác định với các mẫu quest/server chung.

16

--- TRANG 17 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

82. * -https://github.com/danielricci/solitaire/issues/90 - Lỗi hợp lệ, bản sửa không hợp lệ.

83.https://github.com/hv0905/SchoolStoryCollection/issues/2 - Lỗi hợp lệ, bản sửa hợp lệ, có thể xác định bởi con người.

84.https://github.com/davidcorbin/mygcc-api/issues/21 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là khi xử lý một hình ảnh, code tìm kiếm lần xuất hiện cuối cùng của ".jpg", nhưng điều này không thể tìm thấy và ném lỗi nếu URL hình ảnh là chữ hoa.

85.https://github.com/Tamaized/AoV/issues/104 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là một player có thể chỉ nhảy vào và ra khỏi giường để nạp lại các khả năng nhất định, nhưng thực tế họ cần ngủ đầy đủ trong giường để làm điều đó. Lỗi có thể xác định vì đây là mẫu chung (bạn cần thực sự ngủ) trong nhiều game minecraft.

86.https://github.com/Electroblob77/Wizardry/issues/513- Lỗi hợp lệ, bản sửa hợp lệ. Bản sửa bao gồm việc sử dụng stream và filter api để tránh loại bỏ items từ một list có thể được sửa đổi đồng thời. Có thể xác định với kiến thức về cơ chế concurrency.

87.https://github.com/tsandmann/ct-sim/issues/62 - Lỗi hợp lệ (vì code không tương ứng với comment tài liệu), bản sửa hợp lệ. Thú vị là tài liệu bằng tiếng Đức.

88.https://github.com/voxelwind/voxelwind/issues/33 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là dự án triển khai một server cho Minecraft: Pocket Edition, và nó không tuân thủ đầy đủ với hợp đồng API, đặc biệt đối với các tham số yaw mà client truyền vào. Có thể xác định với kiến thức về API.

89.https://github.com/phrack/ShootOFF/issues/651 - Lỗi hợp lệ, bản sửa hợp lệ. Lớp sai được sử dụng để kiểm tra xem màu shot có khớp với các hằng số nhất định không. Có thể xác định.

90. * -https://github.com/rmichela/GiantTrees/issues/31 - Không thực sự là lỗi, điều này chỉ triển khai cơ chế làm im lặng cảnh báo nếu các tệp tài nguyên nhất định không tồn tại.

91.https://github.com/sriharshachilakapati/SilenceEngine/issues/38 - Lỗi hợp lệ, bản sửa hợp lệ. Nếu các vertex cho một polygon nhất định bị xóa, một số tham số được đặt thành vô cực tối đa và tối thiểu, và một số phương thức downstream ném lỗi. Bản sửa là sửa đổi các phương thức này để tính đến các trường hợp khi vertex là 0.

92.https://github.com/lsfusion/platform/issues/164 - Lỗi hợp lệ, bản sửa hợp lệ. Phương thức sẽ không tính đến các tệp ftp không tồn tại, và sửa đổi cho phép phương thức xử lý các tệp ftp không tồn tại cũng như vậy.

93.https://github.com/spring-cloud/spring-cloud-sleuth/issues/1816 - Lỗi hợp lệ, bản sửa hợp lệ. Thư viện sleuth đang can thiệp vào khả năng circuitbreaker của openfeign, bản sửa là tạo feign bean có điều kiện chỉ nếu circuitbreaker bị vô hiệu hóa. Có thể xác định bởi con người.

94.https://github.com/vinaygaba/CreditCardView/issues/13 - Lỗi hợp lệ, bản sửa hợp lệ. Issue là các phương thức setter không sửa đổi trạng thái thực tế của lớp. Dễ xác định bởi con người.

95.https://github.com/AludraTest/aludratest/issues/36 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định với ngữ cảnh của thư viện Selenium.

96.https://github.com/VazkiiMods/Quark/issues/3374 - Lỗi hợp lệ, bản sửa hợp lệ. Bản sửa đơn giản để sửa định dạng của các sự kiện chat trong các trường hợp nhất định của item link.

97.https://github.com/Tamaized/AoV/issues/93 - Lỗi hợp lệ, bản sửa hợp lệ. Vấn đề là casting spell furious howl chỉ nên áp dụng cho một target được chọn. Có thể xác định thông qua các ví dụ khác của spell được cast trên một target cụ thể trong thư viện.

98.https://github.com/spring-projects/spring-boot-data-geode/issues/55 - Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định với kiến thức về Spring bean.

17

--- TRANG 18 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

99.https://github.com/twizmwazin/CardinalPGM/issues/657- Lỗi hợp lệ, bản sửa hợp lệ. Có thể xác định thông qua các quy ước Bukkit/game: game đặt metadata player, nhưng không loại bỏ nó khi match kết thúc.

100.https://github.com/rundeck/rundeck-cli/issues/43 - Lỗi hợp lệ, bản sửa hợp lệ. Text annotation không phù hợp với tài liệu về việc sử dụng tùy chọn command line trong phần còn lại của code.

E CÁC MẪU TẬP DỮ LIỆU TỔNG HỢP

E.1 VÍ DỤ NHIỄU LOẠN INCODER

Chúng tôi trình bày một ví dụ của một mẫu nhiễu loạn được tạo ra bởi mô hình InCoder trong Hình 1. Quan sát gốc ở bên trái, và quan sát bị nhiễu loạn ở bên phải.

package com . g i t h u b . y t . m ybatis . u t i l s ;
i m p o r t com . g i t h u b . y t . base . e x c e p t i o n .
B a s e E r r o r E x c e p t i o n ;
i m p o r t or g . apache . commons . lang3 . S t r i n g U t i l s ;
i m p o r t j a v a . l a n g . r e f l e c t . F i e l d ;
p u b l i c c l a s s B e a n U t i l s {
p u b l i c s t a t i c ChainMap< S t r i n g , Object >
getValueMap ( O b j e c t . . . o b j s ) {
t r y {
ChainMap< S t r i n g , Object > map =
new ChainMap < >() ;
f o r ( O b j e c t o b j : o b j s ) {
i f(n u l l == o b j ) {
c o n t i n u e ;
}
f o r ( Class <?> c = o b j . g e t C l a s s ( ) ;
O b j e c t . c l a s s != c ; c = c . g e t S u p e r c l a s s ( ) ) {
f o r ( F i e l d f i e l d : c .
g e t D e c l a r e d F i e l d s ( ) ) {
f i e l d . s e t A c c e s s i b l e ( t r u e ) ;
O b j e c t v a l u e = f i e l d . g e t ( o b j )
;
i f(n u l l == v a l u e ) {
c o n t i n u e ;
}
i f( f i e l d . getType ( ) .
i s A s s i g n a b l e F r o m ( S t r i n g . c l a s s ) && S t r i n g U t i l s .
isEmpty ( ( S t r i n g ) v a l u e ) ) {
c o n t i n u e ;
}
map . p u t ( f i e l d . getName ( ) ,
v a l u e ) ;
}
}
}
r e t u r n map ;
}c a t c h ( E x c e p t i o n e ) {
thr ow new B a s e E r r o r E x c e p t i o n ( " O b j e c t t o
Map c o n v e r t E r r o r " , e ) ;
}
}
}package com . g i t h u b . y t . m ybatis . u t i l s ;
i m p o r t com . g i t h u b . y t . base . e x c e p t i o n .
B a s e E r r o r E x c e p t i o n ;
i m p o r t or g . apache . commons . lang3 . S t r i n g U t i l s ;
i m p o r t j a v a . l a n g . r e f l e c t . F i e l d ;
p u b l i c c l a s s B e a n U t i l s {
p u b l i c s t a t i c ChainMap< S t r i n g , Object >
getF ieldMap ( O b j e c t . . . o b j s ) {
ChainMap < S t r i n g , Object > map =
new ChainMap< S t r i n g , Object > ( ) ;
t r y {
i f( o b j s != n u l l && o b j s . l e n g t h == 1) {
O b j e c t o b j = o b j s [ 0 ] ;
f o r( Class <?> c = o b j . g e t C l a s s ( ) ;
O b j e c t . c l a s s != c ; c = c . g e t S u p e r c l a s s ( ) ) {
f o r ( F i e l d f i e l d : c .
g e t D e c l a r e d F i e l d s ( ) ) {
f i e l d . s e t A c c e s s i b l e ( t r u e ) ;
O b j e c t v a l u e = f i e l d . g e t ( o b j )
;
i f(n u l l == v a l u e ) {
c o n t i n u e ;
}
i f( f i e l d . getType ( ) .
i s A s s i g n a b l e F r o m ( S t r i n g . c l a s s ) && S t r i n g U t i l s .
isEmpty ( ( S t r i n g ) v a l u e ) ) {
c o n t i n u e ;
}
map . p u t ( f i e l d . getName ( ) ,
v a l u e ) ;
}
}
}
r e t u r n map ;
}c a t c h ( E x c e p t i o n e ) {
thr ow new B a s e E r r o r E x c e p t i o n ( " O b j e c t t o
Map c o n v e r t E r r o r " , e ) ;
}
}
}

Quan sát gốc. Quan sát bị nhiễu loạn.

Hình 1: Mẫu nhiễu loạn được lấy mẫu giới thiệu một viết lại không tầm thường, có thể được coi là một "lỗi". Trái: Code Java gốc lặp qua một danh sách các object được cho (highlight màu xanh lá cây). Phải: Code Java bị nhiễu loạn chỉ xem xét object đầu tiên trong danh sách, nếu danh sách chứa chính xác một phần tử (highlight màu đỏ).

Đáng chú ý, cả hai chuỗi đều xuất hiện là code chính xác về mặt cú pháp. Bộ lấy mẫu tự hồi quy đã tính đến token tương lai. Ví dụ, việc giải quyết loại của object map có thể được giải quyết bởi chữ ký return của hàm public static ChainMap<...> không bị che đi và việc gọi map.put(...). Trong khi code gốc lặp qua

18

--- TRANG 19 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

danh sách các object obj, code bị nhiễu loạn chỉ xem xét phần tử đầu tiên của danh sách, nếu danh sách chứa một phần tử duy nhất. Việc liệu các viết lại có tạo thành "lỗi" hay không phụ thuộc vào định nghĩa của thuật ngữ, như đã thảo luận trước đó. Tuy nhiên, với ngữ cảnh, người ta có thể lập luận rằng việc triển khai được viết lại dường như ít có khả năng tuân theo ý định cơ bản.

E.2 CÁC MẪU TỔNG HỢP VỚI GIẢI THÍCH

Trong phần này chúng tôi cung cấp một vài mẫu của lỗi được tạo ra trong bản sửa đổi thứ hai của tập dữ liệu tổng hợp cũng như giải thích ngắn gọn về các nhiễu loạn trong Hình 2, 3, và 4. Các dòng màu đỏ đánh dấu các dòng bị ảnh hưởng bởi các nhiễu loạn.

Trong Mẫu 1 (2), lỗi rõ ràng được giới thiệu vì chuỗi password đang được in ra STDOUT. Đây là code Java hợp lệ, nhưng là một sự khác biệt đáng kể so với thực hành mã hóa an toàn.

Code trong Mẫu 2 (3) là vòng lặp đệ quy vô tận. Code trong Mẫu 3 (4) là từ một ứng dụng Spring điều khiển một API Planet. Mỗi khi một cuộc gọi đến API addPlanet được thực hiện, API trả về HttpStatus.BAD_REQUEST mỗi lần bất kể hoạt động có thành công hay không.

@Override
p r o t e c t e d A u t h e n t i c a t i o n I n f o d o G e t A u t h e n t i c a t i o n I n f o ( A u t h e n t i c a t i o n T o k e n token ) thr ows
A u t h e n t i c a t i o n E x c e p t i o n {
System . o u t . p r i n t l n ( "==ç ´Z˙zå¡ ¸ Tè ˝ od'è´ r ˛ A == " ) ;
/ / ç ˇ n ˇ näÿ ˘Aæ ˇ eïijŽä ˙z˝Otokenäÿ å´R˝Uå˘Gžç ˇT´læ´L ˚ uå ˇR
S t r i n g r ealnam e = ( S t r i n g ) token . g e t P r i n c i p a l ( ) ;
/ / ç ˇ n ˇ näž ˇNæ ˇ eïijŽæ ˘ a ´ zæ ˝ oçˇT´læ´L ˚ uå ˇR ä˙z˝Oæ ¸ Tˇ ræ ˝ oåž ¸ S è ˝O˚ uå ´R˝UçˇT´læ´L˚ u
User u s e r = n u l l ;
t r y {
u s e r = u s e r S e r v i c e . findObjectByName ( r ealnam e ) ;
}c a t c h ( E x c e p t i o n e1 ) {
/ / TODO Auto − g e n e r a t e d c a t c h block
e1 . p r i n t S t a c k T r a c e ( ) ;
}
i f( u s e r == n u l l ) {
r e t u r n new S i m p l e A u t h e n t i c a t i o n I n f o ( " çˇT´læ´L ˚ uäÿ åŸåIJ ´l ! ",f a l s e , getName ( ) ) ;
}
/ / å´ r ˛ Eç ˘ a ˛ A
S t r i n g passwor d = getP asswor dEncoder ( ) . e n c o d e T o S t r i n g ( u s e r . getP asswor d ( ) ) ;
System . o u t . p r i n t l n ( " è ˝ od'è´ r ˛ Aå ˛ E ˇE"+ passwor d ) ;
/ / ç ˇ n ˇ näÿL 'æ ˇ eïijŽæ ˘ a ´ zæ ˝ oçˇT´læ´L ˚ uå ˇRï£¡è£ ˇTå˙Z¯dè ˝ od'è´ r ˛ Aä£ ˛ aæ ˛ A´ rAuthenticationInfo
/ / activeUser åˇ r ´ sæŸ´ r ç ˇT´læ´L ˚ uè ž ´ nä ˙z¡ ä£ ˛ a æ ˛ A ´ r
A c t i v e U s e r a c t i v e U s e r = new A c t i v e U s e r ( ) ;
a c t i v e U s e r . setRealnam e ( u s e r . getRealnam e ( ) ) ;
a c t i v e U s e r . s e t P h o n e ( u s e r . getP hone ( ) ) ;
a c t i v e U s e r . s e t V a l i d ( u s e r . g e t V a l i d ( ) ) ;
/ / System . o u t . p r i n t l n ( " è ˝ od'è´ r ˛ Aå ˛ E ˇE"+ a c t i v e U s e r ) ;
/ / è˘GłåŁ ´lå ˝ oˇNæ´LˇRå´ r ˛ Eç ˘ a ˛ Aæ´ r ˇTå´ r ´ z − å´ r ˛ Eç ˘ a ˛ AçŽ ˇDæ´ r ˇTå´ r ´ z :
/ / é˘AŽè£ ˘G A u t h e n t i c a t i n g R e a l m çŽ ˇD c r e d e n t i a l s M a t c h e r å´ s ¯dæ˘A ˘ gæ ˙I ˇ eè£ ˙Zè ˛ aˇNçŽ ˇDå´ r ˛ Eç ˘ a ˛ AçŽ ˇDæ´ r ˇTå´ r ´ z!
S i m p l e A u t h e n t i c a t i o n I n f o i n f o =
new S i m p l e A u t h e n t i c a t i o n I n f o ( a c t i v e U s e r , password , c r e d e n t i a l s S a l t , getName ( ) ) ;
S e c u r i t y U t i l s . g e t S u b j e c t ( ) . g e t S e s s i o n ( ) . s e t A t t r i b u t e (" c u r r e n t U s e r " , u s e r ) ;
r e t u r n i n f o ;
}
}

Hình 2: Mẫu 1 Tập dữ liệu Tổng hợp Đã sửa đổi

F CÁC MẪU ĐIỂM CHUẨN THỰC TẾ

Để chỉ ra sự cần thiết của các mô hình ngôn ngữ ngữ cảnh dài cho định vị lỗi, chúng tôi minh họa một ví dụ của một lỗi phụ thuộc cao vào ngữ cảnh bên ngoài bên ngoài phạm vi của tệp nơi lỗi được đặt. Issue² được đề cập liên quan đến một lỗi trong dự án phần mềm Catnip cung cấp wrapper API Discord³ trong Java. Lỗi là plugin Java sử dụng java.awt.Color⁴

²https://github.com/mewna/catnip/issues/105
³https://discord.com
⁴https://docs.oracle.com/javase/7/docs/api/java/awt/Color.html

19

--- TRANG 20 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

p u b l i c c l a s s LazyFragment e x t e n d s Fragment {
p r o t e c t e d L a y o u t I n f l a t e r i n f l a t e r ;
p r i v a t e View contentView ;
p r i v a t e Context c o n t e x t ;
p r i v a t e ViewGroup c o n t a i n e r ;
@Override
p u b l i c void o n C r e a t e ( Bundle s a v e d I n s t a n c e S t a t e ) {
s u p e r . o n C r e a t e ( s a v e d I n s t a n c e S t a t e ) ;
c o n t e x t = g e t A c t i v i t y ( ) . g e t A p p l i c a t i o n C o n t e x t ( ) ;
}
@Override
p u b l i c View onCreateView ( L a y o u t I n f l a t e r i n f l a t e r , ViewGroup c o n t a i n e r , Bundle s a v e d I n s t a n c e S t a t e ) {
t h i s . i n f l a t e r = i n f l a t e r ;
t h i s . c o n t a i n e r = c o n t a i n e r ;
onCr eateiew ( i n f l a t e r , c o n t a i n e r , s a v e d I n s t a n c e S t a t e ) ;
r e t u r n contentView ;
}
@Override
p u b l i c void onDestroyView ( ) {
s u p e r . onDestroyView ( ) ;
contentView = n u l l ;
c o n t a i n e r = n u l l ;
i n f l a t e r = n u l l ;
}

Hình 3: Mẫu 2 Tập dữ liệu Tổng hợp Đã sửa đổi

để lưu trữ tham số Color cho embed. Lớp này không chỉ lưu trữ các bit RGB của màu, mà còn 8 bit alpha bổ sung, tạo thành biểu diễn 64 bit của mỗi màu. Tuy nhiên, API Discord chỉ chấp nhận biểu diễn 48 bit của màu. Do đó, bản sửa bao gồm việc che 8 bit đầu tiên của biểu diễn màu của java.awt.Color và truyền điều đó vào API. Hunk sửa được hiển thị trong Hình 5.

Để một con người có thể hiểu và xác định issue này, họ cần biết về API Discord, các mẫu chung của việc gọi API Discord, các đặc thù của biểu diễn màu trong lớp java.awt.Color, và cách thực hiện các phép toán bit. Chúng tôi trình bày một đoạn code⁵ có sẵn online minh họa việc gọi discord API. Code này truyền vào một màu cho khung embed như một chữ số 48-bit (Hình 6). Các ví dụ như này trong huấn luyện hoặc trong ngữ cảnh là cần thiết để mô hình có cơ hội định vị lỗi này. Không có ngữ cảnh, ngay cả một quan sát viên con người cũng không thể đánh dấu điều này như code bị lỗi một cách đáng tin cậy.

⁵https://discordjs.guide/popular-topics/embeds.html#embed-preview

20

--- TRANG 21 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

@ C o n t r o l l e r
@RequestMapping ( v a l u e = " / a p i " )
@CrossOrigin ( o r i g i n s = "*")
/ / @CrossOrigin ( o r i g i n s = " h t t p : / / l o c a l h o s t : 4 2 0 0 " )
p u b l i c c l a s s P l a n e t C o n t r o l l e r {
/ / p r i v a t e P l a n e t S e r v i c e p l a n e t S e r v i c e ; I DONT HAVE A SERVI CE AT THE M OM E NT
p r i v a t e P lanetRepo p l a n e t R e p o ;
p u b l i c P l a n e t C o n t r o l l e r ( P lanetRepo p l a n e t R e p o ) {
s u p e r ( ) ;
t h i s . p l a n e t R e p o = p l a n e t R e p o ;
}
/ / @RequestMapping ( v a l u e = " / g e t P l a n e t s " , method = Reques tMethod . GET )
@GetMapping( v a l u e = " / g e t P l a n e t s " )/ / These a r e i d e n t i c a l i n c o n f i g u r a t i o n . h t t p : / / l o c a l h o s t : 8 0 8 0 / SpringMVC /
mvc / a p i / g e t P l a n e t s
p u b l i c @ResponseBody L i s t < P l a n e t > g e t A l l P l a n e t s ( ) {
r e t u r n p l a n e t R e p o . s e l e c t A l l ( ) ;
}
@GetMapping( v a l u e = " / g e t P l a n e t s W i t h P a r a m " , p r o d u c e s= " a p p l i c a t i o n / j s o n " , params = { " i d " }) / / h t t p : / / l o c a l h o s t
: 8 0 8 0 / SpringMVC / mvc / a p i / g e t P l a n e t s W i t h P a r a m ? i d =2
p u b l i c R e s p o n s e E n t i t y < P l a n e t > g e t P l a n e t B y I d ( i n t i d ) {
r e t u r n new R e s p o n s e E n t i t y < P l a n e t >( p l a n e t R e p o . s e l e c t P l a n e t B y I d ( i d ) , H t t p S t a t u s . INSUFFICIENT_STORAGE ) ;
}
@ResponseS tatus ( v a l u e = H t t p S t a t u s . ALREADY_REPORTED)
@GetMapping( v a l u e = " / g e t P l a n e t W i t h U r l / { num} " )
p u b l i c @ResponseBody P l a n e t getP lanetByI dTwo ( @P athVar iable ( "num" )i n t i d ) {
r e t u r n p l a n e t R e p o . s e l e c t P l a n e t B y I d ( i d ) ;
}
@ResponseS tatus ( v a l u e = H t t p S t a t u s . BAD_REQUEST)
@PostMapping( v a l u e = " / a d d P l a n e t " )
p u b l i c @ResponseBody S t r i n g a d d P l a n e t ( @RequestBody P l a n e t i n c o m i n g P l a n e t ) {
/*
*This method i s e x e c u t e d when t h e u s e r r e q u e s t s t o add a new p l a n e t t o
*t h e d a t a b a s e .
*
*The d e f a u l t b e h a v i o r f o r M VC i s t o i g n o r e t h e incom ing JSON
*and t r e a t i t l i k e i f i t were a GET r e q u e s t .
*
*I n our example , we would e x p e c t t h i s r e q u e s t t o I f t h e incom in g JSON does NOT HAVE a l l t h e f i e l d s , i t
w i l l p r o v i d e j u s t d e f a u l t v a l u e s .
*/
p l a n e t R e p o . i n s e r t ( i n c o m i n g P l a n e t ) ;
r e t u r n " S uccess " ;
}
@GetMapping( v a l u e = " / a l l T h e H e a d e r s " )
p u b l i c R e s p o n s e E n t i t y < S t r i n g > a l l H e a d e r s ( @RequestHeader Map< S t r i n g , S t r i n g > a l l H e a d e r s ) {
/ / THIS IS NOTHING TO DO WITH M VC
/ / This i s from C o l l e c t i o n s ( Week 1)
f o r( Entr y < S t r i n g , S t r i n g > e n t r y : a l l H e a d e r s . e n t r y S e t ( ) ) {
System . o u t . p r i n t l n ( e n t r y . getKey ( ) + " \ t " + e n t r y . g e t V a l u e ( ) ) ;
}
HttpHeader s r e s p o n s e H e a d e r = new HttpHeader s ( ) ;
r e s p o n s e H e a d e r . s e t ( "Name" ," Bobby" ) ;
r e s p o n s e H e a d e r . s e t ( " s u p e r S e c r e t s " ,"******** ") ;
r e t u r n new R e s p o n s e E n t i t y < S t r i n g >( " S uccess " , r esponseHeader , H t t p S t a t u s . FORBIDDEN ) ;
}
}

Hình 4: Mẫu 3 Tập dữ liệu Tổng hợp Đã sửa đổi

21

--- TRANG 22 ---
Được xuất bản như một bài báo hội nghị tại ICLR 2023

@CheckReturnValue
p u b l i c EmbedBuilder c o l o r ( @Nullable f i n a l Color c o l o r ) {
i f( c o l o r != n u l l ) {
t h i s . c o l o r = c o l o r . getRGB ( ) ;
/ / Mask o f f t h e a l p h a b i t s
t h i s . c o l o r = c o l o r . getRGB ( ) & 0x00FFFFFF ;
}
r e t u r n t h i s ;
}

Hình 5: Hunk từ issue mẫu từ Catnip. Lỗi này minh họa sự cần thiết của ngữ cảnh nhiều hơn thông tin cấp tệp.

c o n s t exampleEmbed = new EmbedBuilder ( )
. s e t C o l o r ( 0 x0099FF )
. s e t T i t l e ( ' Some t i t l e ' )
. setURL ( ' h t t p s : / / d i s c o r d . j s . or g / ' )
. s e t A u t h o r ( { name : 'Some name ' ,
iconURL : ' h t t p s : / / i . imgur . com / AfFp7pu . png ' ,
u r l : ' h t t p s : / / d i s c o r d . j s . org ' })
. s e t D e s c r i p t i o n ( ' Some d e s c r i p t i o n her e ' )
. s e t T h u m b n a i l ( ' h t t p s : / / i . imgur . com / AfFp7pu . png ' )
. a d d F i e l d s (
{ name : ' Regular f i e l d t i t l e ' , v a l u e : 'Some v a l u e her e ' } ,
{ name : ' \ u200B ' , v a l u e : ' \ u200B ' } ,
{ name : ' I n l i n e f i e l d t i t l e ' , v a l u e : ' Some v a l u e her e ' , i n l i n e : t r u e } ,
{ name : ' I n l i n e f i e l d t i t l e ' , v a l u e : ' Some v a l u e her e ' , i n l i n e : t r u e } ,
)
. a d d F i e l d s ( { name : ' I n l i n e f i e l d t i t l e ' , v a l u e : ' Some v a l u e her e ' , i n l i n e : t r u e })
. s e t I m a g e ( ' h t t p s : / / i . imgur . com / AfFp7pu . png ' )
. setTim estam p ( )
. s e t F o o t e r ( { t e x t : 'Some f o o t e r t e x t her e ' , iconURL : ' h t t p s : / / i . imgur . com / AfFp7pu . png ' }) ;

Hình 6: Ví dụ gọi API Discord với biểu diễn màu RGB (24-bit) trong khi RGBA (32-bit) được mong đợi

22