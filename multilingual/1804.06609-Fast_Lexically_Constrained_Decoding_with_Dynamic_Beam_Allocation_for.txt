# 1804.06609.pdf
# Converted from PDF to TXT
# Source path: /home/admin88/arxiv-downloader/multilingual/1804.06609.pdf
# File size: 1587979 bytes

===============================================
PDF FILE CONTENT
===============================================


--- PAGE 1 ---
Fast Lexically Constrained Decoding with Dynamic Beam Allocation for
Neural Machine Translation
Matt Post andDavid Vilar
Amazon Research
Berlin, Germany
Abstract
The end-to-end nature of neural machine
translation (NMT) removes many ways of
manually guiding the translation process that
were available in older paradigms. Recent
work, however, has introduced a new capa-
bility: lexically constrained orguided de-
coding, a modiÔ¨Åcation to beam search that
forces the inclusion of pre-speciÔ¨Åed words and
phrases in the output. However, while theoret-
ically sound, existing approaches have com-
putational complexities that are either linear
(Hokamp and Liu, 2017) or exponential (An-
derson et al., 2017) in the number of con-
straints. We present an algorithm for lexi-
cally constrained decoding with a complex-
ity ofO(1)in the number of constraints. We
demonstrate the algorithm‚Äôs remarkable abil-
ity to properly place these constraints, and use
it to explore the shaky relationship between
model and BLEU scores. Our implementation
is available as part of S OCKEYE .1
1 Introduction
One appeal of the phrase-based statistical ap-
proach to machine translation (Koehn et al., 2003)
was that it provided control over system output.
For example, it was relatively easy to incorporate
domain-speciÔ¨Åc dictionaries, or to force a transla-
tion choice for certain words. These kinds of in-
terventions were useful in a range of settings, in-
cluding interactive machine translation or domain
adaptation. In the new paradigm of neural ma-
chine translation (NMT), these kinds of manual
interventions are much more difÔ¨Åcult, and a lot of
time has been spent investigating how to restore
them (cf. Arthur et al. (2016)).
At the same time, NMT has also provided new
capabilities. One interesting recent innovation is
1https://awslabs.github.io/sockeye/
inference.html#lexical-constraints
No one has the intention of building a wall.‚Äúerrichten‚ÄùNiemand hat die Absicht, eine Mauer zu bauen.‚Ä®‚ÄúNo one has the intention, a wall to build.‚ÄùNiemand hat die Absicht, eine Mauer zu errichten.‚Ä®‚ÄúNo one has the intention, a wall to construct.‚Äù‚ÄúKeiner‚Äù‚ÄúKeiner‚Äù‚Ä®"errichten‚ÄùKeiner hat die Absicht, eine Mauer zu bauen.‚Ä®‚ÄúNo one has the intention, a wall to build.‚ÄùKeiner hat die Absicht, eine Mauer zu errichten.‚Ä®‚ÄúNo one has the intention, a wall to construct.‚ÄùFigure 1: An example translating from English to Ger-
man. The Ô¨Årst translation is unconstrained, whereas
the remaining ones have one or two constraints im-
posed. A word-for-word translation of the German
output has been provided for the convenience of non-
German speaking readers.
lexically constrained decoding , a modiÔ¨Åcation to
beam search that allows the user to specify words
and phrases that must appear in the system output
(Figure 1). Two algorithms have been proposed
for this: grid beam search (Hokamp and Liu,
2017, GBS) and constrained beam search (Ander-
son et al., 2017, CBS). These papers showed that
these algorithms do a good job automatically plac-
ing constraints and improving results in tasks such
as simulated post-editing, domain adaptation, and
caption generation.
A downside to these algorithms is their runtime
complexity: linear (GBS) or exponential (CBS) in
the number of constraints. Neither paper reported
decoding speeds, but the complexities alone sug-
gest a large penalty in runtime. Beyond this, other
factors of these approaches (a variable sized beam,
Ô¨Ånite-state machinery) change the decoding pro-
cedure such that it is difÔ¨Åcult to integrate with
other operations known to increase throughput,
like batch decoding.
We propose and evaluate a new algorithm, dy-
namic beam allocation (DBA), that is constant in
the number of provided constraints (Table 1). OurarXiv:1804.06609v2  [cs.CL]  9 Nov 2018

--- PAGE 2 ---
work complexity
Anderson et al. (2017) O(Nk2C)
Hokamp and Liu (2017) O(NkC )
This work O(Nk)
Table 1: Complexity of decoding (sentence length N,
beam sizek, and constraint count C) with target-side
constraints under various approaches.
algorithm works by grouping together hypotheses
that have met the same number of constraints into
banks (similar in spirit to the grouping of hypothe-
ses into stacks for phrase-based decoding (Koehn
et al., 2003)) and dynamically dividing a Ô¨Åxed-size
beam across these banks at each time step. As a re-
sult, the algorithm scales easily to large constraint
sets that can be created when words and phrases
are expanded, for example, by sub-word process-
ing such as BPE (Sennrich et al., 2016). We com-
pare it to GBS and demonstrate empirically that it
is signiÔ¨Åcantly faster, making constrained decod-
ing with an arbitrary number of constraints feasi-
ble with GPU-based inference. We also use the al-
gorithm to study beam search interactions between
model and metric scores, beam size, and pruning.
2 Beam Search and Grid Beam Search
Inference in statistical machine translation seeks
to Ô¨Ånd the output sequence, ^y, that maximizes
the probability of a function parameterized by a
model,, and an input sequence, x:
^y= argmaxy2Yp(yjx)
The space of possible translations, Y, is the set of
all sequences of words in the target language vo-
cabulary,VT. It is impossible to explore this en-
tire space. Models decompose this problem into a
sequence of time steps, t. At each time step, the
model produces a distribution over VT. The sim-
plest approach to translation is therefore to run the
steps of the decoder, choosing the most-probable
token at each step, until either the end-of-sentence
token,h=si, is generated, or some maximum out-
put length is reached. An alternative, which ex-
plores a slightly larger portion of the search space,
is beam search.
In beam search (Lowerre, 1976; Sutskever et al.,
2014), the decoder maintains a beam of sizekcon-
taining a set of active hypotheses (Algorithm 1).
At each time step t, the decoder model is used toAlgorithm 1 Beam search. Inputs: max output
lengthN, beam size k.Output: highest-scoring
hypothesis.
1:function BEAM -SEARCH (N;k)
2: beam DECODER -INIT(k)
3: fortime steptin 1..Ndo
4: scores = DECODER -STEP (beam)
5: beam KBEST (scores)
6: return beam[0]
7:function KBEST (scores)
8: beam = ARGMAX K(k, scores)
9: return beam
produce a distribution over the target-language vo-
cabulary,VT, for each of these hypotheses. This
produces a large matrix of dimensions kjVTj,
that can be computed quickly with modern GPU
hardware. Conceptually, a (row, column) entry
(i;j)in this matrix contains the state obtained
from starting from the ith state in the beam and
generating the target word corresponding to the
jth word ofVT. The beam for the next time step
is Ô¨Ålled by taking the states corresponding to the
k-best items from this entire matrix and sorting
them.
A principal difference between beam search for
phrase-based and neural MT is that in NMT, there
is no recombination: each hypothesis represents
a complete history, back to the Ô¨Årst word gener-
ated. This makes it easy to record properties of
the history of each hypothesis that were not possi-
ble with dynamic programming. Hokamp and Liu
(2017) introduced an algorithm for forcing certain
words to appear in the output called grid beam
search (GBS). This algorithm takes a set of con-
straints, which are words that must appear in the
output, and ensures that hypotheses have met all
these constraints before they can be considered to
be completed. For Cconstraints, this is accom-
plished by maintaining C+ 1 separate beams or
banks ,B0;B1;:::;BC, whereBigroups together
hypotheses that have generated (or met)iof the
constraints. Decoding proceeds as with standard
beam decoding, but with the addition of bookkeep-
ing that tracks the number of constraints met by
each hypothesis, and ensures that new candidates
are generated, such that each bank is Ô¨Ålled at each
time step. When beam search is complete, the
hypothesis returned is the highest-scoring one in
bankBC. Conceptually, this can be thought of as

--- PAGE 3 ---
adding an additional dimension to the beam, since
we multiply out some base beam size bby (one
plus) the number of constraints.
We note two problems with GBS:
Decoding complexity is linear in the num-
ber of constraints: The effective beam size,
k(C+ 1) , varies with the number of con-
straints.
It is impractical. The beam size changes
for every sentence, whereas most decoders
specify the beam size at model load time in
order to optimize computation graphs, spe-
cially when running on GPUs. It also compli-
cates beam search optimizations that increase
throughput, such as batching.
Our extension, fast lexically-constrained decoding
via dynamic beam allocation (DBA), addresses
both of these issues. Instead of maintaining C+ 1
beams, we maintain a single beam of size k, as
with unconstrained decoding. We then dynami-
cally allocate the slots of this beam across the con-
straint banks at each time step. There is still book-
keeping overhead, but this cost is constant in the
number of constraints, instead of linear. The result
is a practical algorithm for incorporating arbitrary
target-side constraints that Ô¨Åts within the standard
beam-decoding paradigm.
3 Dynamic Beam Allocation ( DBA )
Our algorithm (Algorithm 2) is based on a small
but important alteration to GBS. Instead of multi-
plying the beam by the number of constraints, we
divide . A Ô¨Åxed beam size is therefore provided
to the decoder, just as in standard beam search.
As different sentences are processed with differing
numbers of constraints, the beam is dynamically
allocated to these different banks. In fact, the allo-
cation varies not just by sentence, but across time
steps in processing each individual sentence.
We need to introduce some terminology. A
word constraint provided to the decoder is a sin-
gle token in the target language vocabulary. A
phrasal constraint is a sequence of two or more
contiguous tokens. Phrasal constraints come into
play when the user speciÔ¨Åes a multi-word phrase
directly (e.g., high-ranking member ), or when a
word gets broken up by subword splitting (e.g.,
thou@ @ ghtful ). The total number of constraints
is the sum of the number of tokens across all wordand phrasal constraints. It is easier for the decoder
to place multiple sequential tokens in a phrasal
constraint (where the permutation is Ô¨Åxed) com-
pared to placing separate, independent constraints
(see discussion at the end of x5), but the algorithm
does not distinguish them when counting.
DBA Ô¨Åts nicely within standard beam decod-
ing; we simply replace the kbest implementation
from Algorithm 1 with one that involves a bit more
bookkeeping. Instead of selecting the top- kitems
from thekVTscores matrix, the new algorithm
must consider two important matters.
1. Generating a list of candidates ( x3.1).
Whereas the baseline beam search simply
takes the top- kitems from the scores matrix
(a fast operation on a GPU), we now need to
ensure that candidates progress through the
set of provided constraints.
2. Allocating the beam across the constraint
banks (x3.2). With a Ô¨Åxed-sized beam and
an arbitrary number of constraints, we need
to Ô¨Ånd an allocation strategy for dividing the
beam across the constraint banks.
3.1 Generating the candidate set
We refer to Figure 2 for discussion of the algo-
rithm. The set of candidates for the beam at time
stept+ 1is generated from the hypotheses in the
current beam at step t, which are sorted in de-
creasing order, with the highest-scoring hypoth-
esis at position 1. The DECODER -STEP function
of beam search generates a matrix, scores , where
each rowrcorresponds to a probability distribu-
tion over all target words, expanding the hypoth-
esis in position rin the beam. We build a set of
candidates from the following items:
1. The best ktokens across all rows of scores
(i.e., normal top- k);
2. for each hypothesis in the beam, all unmet
constraints (to ensure progress through the
constraints); and
3. for each hypothesis in the beam, the
single-best token (to ensure consideration of
partially-completed hypotheses).
Each of these candidates is denoted by its coordi-
nates in scores . The result is a set of candidates
which can be grouped into banks according to how

--- PAGE 4 ---
tV0.930.961.090.911.06‚Üí0.951.03‚Üí1.021.04‚Üí1.000.891.08‚ü≤1.071.030.97‚Üí0.980.93‚Üí0.991.020.981.010.910.941.000.940.930.900.96‚¨¶1.03‚Üí0.880.97‚Üí0.880.93‚¨¶‚ü≤1.030.920.900.810.980.870.810.910.930.910.84‚¨¶0.950.900.830.940.830.87generate, allocate, adjustt+1(1, 3)(1, 10)(2, 2)(3, 10)(5, 5)for b in [0.9, 0.88, 0.85, 0.81, 0.79]:
    t = [random.random() for x in range(10)];
    t = [b + x / sum(t) for x in t];
    print('\t'.join(['{:.2f}'.format(x) for x in t]))
Figure 2: A single step of the constrained decoder. Along the left is the beam ( k= 5) at time step t. The shapes
in this beam represent constraints, both met (Ô¨Ålled) and unmet (outlined). The blue square represents a phrasal
constraint of length 2, which must be completed in order (left half, then right half). A step of the decoder produces
akVTmatrix of scores. Each constraint corresponds to a single token in the vocabulary, and is marked along
the bottom. Gray squares denote the set of candidates that are produced ( x3.1) from the kbest items (F), from
extending each hypothesis with all unÔ¨Ålled constraints ( !), and from its single-best next token ( 3). Items that
violate a phrasal constraint (
	) require the phrasal constraint from that hypotheses to be unwound (set to unmet).
From these Ô¨Åfteen candidates, the beam at time step t+ 1is Ô¨Ålled, according to the bank allocation strategy, which
here assigns one slot in the beam to each bank. The Ô¨Ånal beam includes coordinates indicating the provenance of
chosen items (which are also indicated in bold in the grid).
many constraints they have met, and then sorted
within those banks. The new beam for timestep
t+ 1 is then built from this list according to an
allocation policy (next section).
For hypotheses partially through a phrasal con-
straint, special care must be taken. If a phrasal
constraint has been begun, but not Ô¨Ånished, and a
token is chosen that does not match the next word
of the constraint, we must reset or ‚Äúunwind‚Äù those
tokens in this constraint that are marked as having
been met. This permits the decoder to abort the
generation of a phrasal constraint, which is impor-
tant in situations where a partial preÔ¨Åx of a phrasal
constraint appears in the decoded sentence earlier
than the entire phrase.
3.2 Allocating the beam
The task is to allocate a size- kbeam across C+ 1
constraint banks, where Cmay be greater than k.
We use the term bank to denote the portion of the
beam reserved for items having met the same num-
ber of constraints (including one bank for hypothe-
ses with zero constraints met). We use a simple
allocation strategy, setting each bin size to bk=Cc,
irrespective of the timestep. Any remaining slots
are assigned to the ‚Äútopmost‚Äù or maximally con-
strained bank, C.This may at Ô¨Årst appear wasteful. For exam-
ple, space allocated at timestep 1 to a bank rep-
resenting candidates having met more than one
constraint cannot be used, and similarly, for later
timesteps, it seems wasteful to allocate space to
bank 1. Additionally, if the number of candidates
in a bank is smaller than the allocation for that
bank, the beam is in danger of being underÔ¨Ålled.
These problems are mitigated by bank adjustment
(Figure 3). We provide here only a sketch of this
procedure. An overÔ¨Ålled bank is one that has been
allocated more slots than it has candidates to Ô¨Åll.
Each such overÔ¨Ålled bank, in turn, gives its extra
allotments to banks that have more candidates than
slots, looking Ô¨Årst to its immediate neighbors, and
moving outward until it has distributed all of its
extra slots. In this way, the beam is Ô¨Ålled, up to
the minimum of the beam size or the number of
candidates.
3.3 Finishing
Hypotheses are not allowed to generate the end-
of-sentence token, h=si, unless they have met all
of their constraints. When beam search is Ô¨Ånished,
the highest-scoring completed item is returned.

--- PAGE 5 ---
Algorithm 2 k-best extraction with DBA. Inputs: AkjVTjmatrix of model states.
1:function KBEST -DBA(beam, scores)
2: constraints [hyp.constraint for hyp in beam]
3: candidates [(i;j;constraints[i].add(j)] fori;jinARGMAX K(k, scores) .Top overallk
4: for1hkdo .Go over current beam
5: for allw2VTthat are unmet constraints for beam[ h]do.Expand new constraints
6: candidates.append( (h;w; constraints[h].add(w) ) )
7:w=ARGMAX (scores[h;:])
8: candidates.append( ( h;w, constraints[ h].add(w)) ) .Best single word
9: selected ALLOCATE (candidates, k)
10: newBeam [candidates[ i] foriin selected]
11: return newBeam
0123400111candidatesallocationreallocation
Figure 3: Beam reallocation for k= 5 with 4 con-
straints at timestep t. There are eight candidates, each
having met only 0 or 1 constraint. The allocation pol-
icy gives one slot of the beam to each bank. However,
there are no candidates for banks 2‚Äì4 (greyed), so their
slots are redistributed to banks 0 and 1.
4 Experimental Setup
Our experiments were done using S OCKEYE
(Hieber et al., 2017). We used an English‚ÄìGerman
model trained on the complete WMT‚Äô17 train-
ing corpora (Bojar et al., 2017), which we pre-
processed with the Moses tokenizer (preserving
case) and with a joint byte-pair-encoded vocabu-
lary with 32k merge operations (Sennrich et al.,
2016). The model was a 4 layer RNN with atten-
tion. We trained using the Adam optimizer with
a batch size of 80 until cross-entropy on the de-
velopment data (newstest2016) stopped increasing
for 10 consecutive iterations.
For decoding, we normalize completed hy-
potheses (those that have generated h=si), divid-
ing the cumulative sentence score by the num-ber of words. Unless otherwise noted, we apply
threshold pruning to the beam, removing hypothe-
ses whose log probability is not within 20 com-
pared to the best completed hypothesis. This prun-
ing is applied to all hypotheses, whether they are
complete or not. (We explore the importance of
this pruning inx6.3). Decoding stops when either
all hypotheses still on the beam are completed or
the maximum length, N, is reached. All experi-
ments were run on a single a V olta P100 GPU. No
ensembling or batching were used.
For experiments, we used the newstest2014
English‚ÄìGerman test set (the developer version,
with 2,737 sentences). All BLEU scores are com-
puted on detokenized output using SACRE BLEU
(Post, 2018),2and are thus directly comparable to
scores reported in the WMT evaluations.
5 Validation Experiment
We center our exploration of DBA by experiment-
ing with constraints randomly selected from the
references. We extract Ô¨Åve sets of constraints:
from one to four randomly selected words from
the reference ( rand1 torand4 ), and a randomly
selected four-word phrase ( phr4 ). We then apply
BPE to these sets, which often yields a much larger
number of token constraints. Statistics about these
extracted phrases can be found in Table 2.
We simulate the GBS baseline within our
framework. After applying BPE, We group to-
gether translations with the same number of con-
straints,C, and then translate them as a group,
with the beam set for that group set to b(C+ 1) ,
wherebis the ‚Äúbase beam‚Äù parameter. We use
b= 10 as reported in Hokamp et al., but also try
2The signature is BLEU+case.mixed+lang.en-
de+numrefs.1+smooth.exp+test.wmt14+tok.13a+v.1.2.6

--- PAGE 6 ---
num rand1 rand2 rand3 rand4 phr4
1 2,182 0 0 0 0
2 548 3,430 0 0 0
3 516 1,488 4,074 0 0
4 272 1,128 2,316 4,492 4,388
5 150 765 1,860 3,275 2,890
6 30 306 1,218 2,520 2,646
7 42 133 805 1,736 1,967
8 0 112 488 1,096 1,280
9 0 36 171 702 720
10 0 10 140 400 430
11+ 0 22 189 417 575
total 3,726 7,477 11,205 14,885 14,926
mean 1.36 2.73 4.09 5.43 5.45
Table 2: Histogram of the number of token constraints
for some constraint sets after applying BPE (model
trained with 32k merge operations). mean denotes the
mean number of constraints per sentence in the 2,737-
sentence test set.
smaller values of b= 5and 1. Finally, we disable
beam adjustment (x3.2), so that the space allocated
to each constraint bank does not change.
Table 4 compares speeds and BLEU scores (in
the legend) as a function of the number of post-
BPE constraints for the rand3 dataset. We plot
all points for which there were at least 10 sen-
tences. The times are decoding only, and exclude
model loading and other setup. The linear trend
inCis clear for GBS, as is the constant trend
for DBA. In terms of absolute runtimes, DBA im-
proves considerably over GBS, whose beam sizes
quickly become quite large with a non-unit base
beam size. On the Tesla V100 GPU, DBA ( k=
10) takes about 0.6 seconds/sentence, regardless
of the number of constraints.3This is about 3x
slower than unconstrained decoding.
It is difÔ¨Åcult to compare these algorithms ex-
actly because of GBS‚Äôs variable beam size. An
important comparison is that between DBA ( k=
10) and GBS/1 (base beam of 1). A beam of
k= 10 is a common setting for decoding in gen-
eral, and GBS/1 has a beam size of k10for
C9. At this setting, DBA Ô¨Ånds better transla-
tions (BLEU 26.7 vs. 25.6) with the same runtime
and with a Ô¨Åxed, instead of variable-sized, beam.
We note that the bank adjustment correction
of the DBA algorithm allows it to work when
C >=k. The DBA ( k= 5) plot demonstrates
this, while still Ô¨Ånding a way to increase the BLEU
score over GBS (23.5 vs. 22.3). However, while
3On a K80, it is about 1.4 seconds / sentence
Volta decoding rand3‚Ä®beam size = 10 (DBA), 5(C+1) (GBS)GBS/10 (BLEU 27.8, k=(C+1)√ó10)GBS/5 (BLEU 27.5, k=(C+1)√ó5)GBS/1 (BLEU 25.6, k=(C+1)√ó1)DBA (BLEU 27.2, k=20)DBA (BLEU 26.7, k=10)DBA (BLEU 23.5, k=5)unconstrained (k=10)counts31.81011.07570.47251.15380.68170.48050.2133135842.16691.28870.49231.10830.72400.51390.213357952.55801.44200.55561.10520.68740.40120.213337262.89081.64990.58441.04430.68580.42040.213320373.40371.92660.70741.15240.74450.44660.213311583.80062.04440.76421.18470.80120.48020.21336193.95752.19970.80961.18560.80570.46030.213319104.37792.48970.95641.17850.69040.59470.213314114.78452.66891.11811.32840.87350.78860.21338124.86642.96151.26221.55621.08780.84520.21335133.07381.98801.01991.09080.87810.79310.21332154.46522.75491.35391.44131.01560.95480.21331seconds / sentence012345
number of constraints, C (after BPE)345678910
GBS/10 (BLEU 27.8, k=(C+1)√ó10)
GBS/5 (BLEU 27.5, k=(C+1)√ó5)
GBS/1 (BLEU 25.6, k=(C+1)√ó1)
DBA (BLEU 27.2, k=20)
DBA (BLEU 26.7, k=10)
DBA (BLEU 23.5, k=5)
unconstrained (k=10)Volta decoding‚Ä®beam size = 10 (DBA), 5(C+1) (GBS)-1# constraintsphr2phr3phr4rand1rand2rand3010.630320.64070.68620.656030.65340.64040.68650.65840.681740.64930.67990.64390.75030.72670.724050.64410.61650.61410.71770.67060.687460.72850.72190.61950.70960.685870.74260.67650.68830.744580.70910.68190.801290.8327100.553211121314151617threshold30times010.630320.64070.68620.656030.65340.64040.68650.65840.681740.64930.67990.64390.75030.72670.724050.64410.61650.61410.71770.67060.687460.72850.72190.61950.87980.70960.685870.74260.67650.68830.89940.78140.744581.10610.70910.68191.26100.801291.45790.81070.83270.82150.8057100.76940.55321.01030.6904110.79600.80480.62711.41630.8735120.69041.06271.0878130.76131.22630.8781140.96350.76141.0156150.73411617counts001021492167931717653517135517145313984301572110053284554513540060033136356657208467962209736104254520113875715266192257852510542514113219141248113221141411521617# constraints
25.627.527.8
23.526.727.2
 1Figure 4: Running time (seconds / sentence, lower is
better) as a function of the number of constraints, C
(after applying BPE) on the rand3 dataset. The un-
constrained baselines have BLEU scores of 22.3, 22.3,
and 22.1 for k= 5;10, and 20, respectively.
possible, low krelative toCreduces the observed
improvement considerably. Looking at Figure 5
across different constraint sets, we can get a better
feel for this relationship. DBA is still always able
to meet the constraints even with a beam size of 5,
but the quality suffers. This should not be too sur-
prising; correctly placing independent constraints
is at least as hard as Ô¨Ånding their correct permuta-
tion, which is exponential in the number of inde-
pendent constraints. But it is remarkable that the
only failure to beat the baseline in terms of BLEU
is when the algorithm is tasked with placing four
random constraints (before BPE) with a beam size
of 5. In contrast, DBA never has any trouble plac-
ing phrasal constraints (dashed lines).
6 Analysis
6.1 Placement
It‚Äôs possible that the BLEU gains result from a
boost in n-gram counts due to the mere presence of
the reference constraints in the output, as opposed
to their correct placement. This appears not to be
the case. Experience examining the outputs shows
its uncanny ability to sensibly place constrained
words and phrases. Figure 6 contains some exam-
ples from translating a German sentence into En-
glish, manually identifying interesting phrases in
the target, choosing paraphrases of those words,
and then decoding with them as constraints. Note
that the word weak, which doesn‚Äôt Ô¨Åt in the seman-
tics of the reference, is placed haphazardly.
We also conÔ¨Årm this correct placement quanti-

--- PAGE 7 ---
Volta decoding rand3‚Ä®beam size = 10 (DBA), 5(C+1) (GBS)5102030phr431.3435.6836.2936.45phr329.0331.3332.0032.04rand420.7026.9128.4328.76phr226.7227.6628.1328.06rand323.5126.7327.2327.64rand224.6425.6426.1326.22rand124.3824.6024.7124.70unconstrained22.3322.3322.1521.86BLEU152025303540
beam size5102030
phr4
phr3
rand4
phr2
rand3
rand2
rand1
unconstrained
BLEU152025303540
beam size5102030
phr4
phr3
rand4
phr2
rand3
rand2
rand1
unconstrained
 1Figure 5: BLEU score as a function of beam size un-
der DBA. All constraint sets improve as the beam gets
larger (recall that the actual number of constraints in-
creases after BPE and varies by sentence). rand4 per-
forms under the unconstrained baseline if the beam is
too low.
tatively by comparing the location of the Ô¨Årst word
of each constraint in (a) the reference and (b) the
output of the constrained decoder, represented as a
percentage of the respective sentence lengths (Fig-
ure 7). We would not expect these numbers to
be perfectly matched, but the strong correlation is
pretty apparent (Pearson‚Äôs r= 0:82). Together,
Figures 6 and 7 provide conÔ¨Ådence that DBA is
intelligently placing the constraints.
6.2 Reference Aversion
The inference procedure in S OCKEYE maximizes
the length-normalized version of the sentence‚Äôs
log probability. While there is no explicit training
towards the metric, BLEU, modeling in machine
translation assumes that better model scores cor-
relate with better BLEU scores. However, a gen-
eral repeated observation from the NMT literature
is the disconnect between model score and BLEU
score. For example, work has shown that open-
ing up the beam to let the decoder Ô¨Ånd better hy-
potheses results in lower BLEU score (Koehn and
Knowles, 2017), even as the model score rises.
The phenomenon is not well understood, but it
seems that NMT models have learned to travel a
path straight towards their goal; as soon as they
get off this path, they get lost, and can no longer
function (Ott et al., 2018).
Another way to look at this problem is to ask
what the neural model thinks of the references.
Scoring against complete references is easy with
NMT (Sennrich, 2017), but lexically-constrained0 3 5 10 20 30
none 24.4 24.5 24.5 24.4 24.5 24.4
rand1 25.2 25.1 25.2 25.6 25.5 25.3
rand2 26.0 25.3 25.6 26.1 26.7 26.4
rand3 26.5 24.7 24.9 25.7 26.9 27.2
rand4 26.2 23.7 23.9 24.6 26.0 26.9
phr4 35.1 33.5 33.5 34.0 35.0 35.9
Table 3: BLEU scores varying the pruning setting
(beam size 10). Runtimes for unpruned systems (col-
umn 0) are nearly twice those of the other columns.
But it is only at large thresholds that BLEU scores are
higher than the unpruned setting.
decoding allows us to investigate this in Ô¨Åner-
grained detail by including just portions of the
references. We observe that forcing the decoder
to include even a single word from the reference
imposes a cost in model score that is inversely
correlated with BLEU score, and that this grows
with the number of constraints that are added (Fig-
ure 8). The NMT system seems quite averse to the
references, even in small pieces, and even while
it improves the BLEU score. At the same time,
the hypotheses it Ô¨Ånds in this reduced space are
still good, and become better as the beam is en-
largened (Figure 5). This provides a complemen-
tary Ô¨Ånding to that of Koehn and Knowles (2017):
in that setting, higher model scores found by a
larger beam produce lower BLEU scores; here,
lower model scores are associated with signiÔ¨Å-
cantly higher BLEU scores.
6.3 Effects of Pruning
In the results reported above, we used a prun-
ing threshold of 20, meaning that any hypothe-
sis whose log probability is not within 20 of the
best completed hypothesis is removed from the
beam. This pruning threshold is far greater than
those explored in other papers; for example, Wu
et al. (2016) use 3. However, we observed two
things: Ô¨Årst, without pruning, running time for
constrained decoding is nearly doubled. This in-
creased runtime applies to both DBA and GBS
in Figure 4. Second, low pruning thresholds are
harmful to BLEU scores (Table 3). It is only once
the thresholds reach 20 that the algorithm is able
to Ô¨Ånd better BLEU scores compared to the un-
pruned baseline (column 0).

--- PAGE 8 ---
constraint score output
source Einer soll ein hochrangiges Mitglied aus Berlin gewesen sein .
no constraints -0.217 One should have been a high-ranking member from Berlin .
is said to -0.551 One is said to have been a high-ranking member from Berlin .
of them -0.577 One of them was to be a high-ranking member from Berlin .
participant -0.766 One should have been a high-ranking participant from Berlin .
is thought to -0.792 One is thought to have been a high-ranking member from Berlin .
considered -0.967 One is considered to have been a high-ranking member from Berlin .
Hamburg -1.165 One should have been a high-ranking member from Hamburg .
powerful -1.360 One is to have been a powerful member from Berlin .
powerful ,is said to -1.496 One is said to have been a powerful member from Berlin .
powerful ,is said to ,participant -1.988 One is said to have been a powerful participant from Berlin .
weak -1.431 One weak point was to have been a high-ranking member from Berlin .
reference One is said to have been a high-ranking member from Berlin.
Figure 6: Example demonstrating the correct placement of manually chosen constraints (beam size 10). The
unnatural placement of the constraint weak demonstrates what the model does when forced to include a word that
is not a semantic Ô¨Åt.
position in output (%)position in reference (%)
Figure 7: Location of the Ô¨Årst word of each constraint
fromphr3 in the reference versus the constrained out-
put (Pearson‚Äôs r= 0:82). DBA correctly places its
constraints, even though no source word or alignment
information is provided.
6.4 Garbage Generation
Why is the algorithm so slow without pruning?
One might suspect that the outputs are longer,
but mean output length with all constraint sets is
roughly the same. The reason turns out to be that
the the decoder never quits before the maximum
timestep,N. S OCKEYE ‚Äôs stopping criterium is
to wait until all hypotheses on the beam are Ô¨Ån-
ished. Without pruning, the decoder generates
a Ô¨Ånished hypotheses, but continues on until the
maximum timestep N, populating the rest of the
beam with low-cost garbage. An example can be
found in Figure 9. This may be an example of
the well-attested phenomenon where NMT sys-
beam=10runmodelBLEUnone-1039.8622.33rand1-1337.5424.60rand2-1724.9825.64testrand3-2236.2426.73rand4-3082.1726.91phr2-1766.2727.66phr3-2156.1731.33phr4-2681.6235.68ref95.864396.46
010203040
-4,000-3,000-2,000-1,0000
nonerand1rand4phr4phr3rand3rand2phr2
 1Figure 8: BLEU score as a function of model score
(summed over the corpus). The reference model score
is -4,396.
tems become unhinged from the source sentence,
switching into ‚Äúlanguage model‚Äù mode and gen-
erating high-probable output with no end. But
strangely, this doesn‚Äôt seem to affect the best hy-
potheses, but only the rest of the beam. This seems
to be more evidence of reference aversion, where
the decoder, having been forced into a place it
doesn‚Äôt like, does not know how to generate good
competing hypotheses.
An alternative to pruning is early stopping ,
which is to stop when the Ô¨Årst complete hypothe-
sis is generated. In our experiments, while this did
Ô¨Åx the problem of increasing runtimes, the BLEU
scores were lower.
7 Related Work
Hokamp and Liu (2017) was novel in that it

--- PAGE 9 ---
1 2 3 4 5 6 7 8 9 10 11 12 13 14 . . . 41
-0.51hsiEr und Kerr lieben einander noch immer , betonte die 36-J ¬®ahrige .h=si
-0.52hsiEr und Kerr lieben einander noch immer , betonte der 36-J ¬®ahrige .h=si
-0.56hsiEr und Kerr lieben einander noch immer , betonte die 36-j ¬®ahrige .h=si
-0.57hsiEr und Kerr lieben einander noch immer , betonte den 36-j ¬®ahrigen . h=si
-25.11hsiEr und Kerr lieben sich weiterhin einander , betonte die 36-J ¬®ahrige . &#160; . . . &#160;
-27.92hsiEr und Kerr lieben sich weiterhin einander , betonte die 36-J ¬®ahrige . &#160; . . . &#160;
Figure 9: The sentence He and Kerr still love each other , emphasised the 36-year-old . translated with the
constraint noch immer , betonte (BPE removed for readability). The Ô¨Årst column is the log probability, which
is normalized only for Ô¨Ånished hypotheses. The decoder completes a few hypotheses well before the maximum
timestep, but then Ô¨Ålls the lower beam with garbage until forced to stop.
allowed the speciÔ¨Åcation of arbitrary target-side
words as hard constraints, implemented entirely as
a restructuring of beam search. A related approach
was that of Anderson et al. (2017), who similarly
extended beam search with a Ô¨Ånite state machine
whose states marked completed subsets of the set
of constraints, at an exponential cost in the number
of constraints. Both of the approaches make use
of target-side constraints without any reference to
the source sentence. A related line of work is to at-
tempt to force the use of particular translations of
source words and phrases, which allows the incor-
poration of external resources such as glossaries or
translation memories. Chatterjee et al. (2017) pro-
pose a variant on beam search that interleaves de-
coder steps with attention-guided checks to ensure
that glossary annotations on the source sentence
are generated by the decoder. Their implementa-
tion also permits discontinuous phrases and trans-
lation options (these capabilities are not available
in DBA, but could be added). A softer approach
treats external resources as suggestions that are al-
lowed to inÔ¨Çuence, but not necessarily determine,
the choice of words (Arthur et al., 2016) and also
phrases (Tang et al., 2016).
Lexically-constrained decoding also general-
izes preÔ¨Åx decoding (Knowles and Koehn, 2016;
Wuebker et al., 2016), since the hsisymbol can
easily be included as the Ô¨Årst word of a constraint.
Finally, another approach which shares the
hard-decision made by lexically constrained de-
coding is the placeholder approach (Crego et al.,
2016), wherein identiÔ¨Åable elements in the in-
put are transformed to masks during preprocess-
ing, and then replaced with their original source-
language strings during postprocessing.
8 Summary
Neural machine translation removes many of the
knobs from phrase-based MT that provided Ô¨Åne-grained control over system output. Lexically-
constrained decoding restores one of these tools,
providing a powerful and interesting way to in-
Ô¨Çuence NMT output. It requires only the speci-
Ô¨Åcation of the target-side constraints; without any
source word or alignment information, it correctly
places the constraints. Although we have only
tested it here with RNNs, the code works with-
out modiÔ¨Åcation with other architectures generate
target-side words one-by-one, such as the Trans-
former (Vaswani et al., 2017).
This paper has introduced a fast and practical
solution. Building on previous approaches, con-
strained decoding with DBA does away with lin-
ear and exponential complexity (in the number of
constraints), imposing only a constant overhead.
On a V olta GPU, lexically-constrained decoding
with DBA is practical, requiring about 0.6 sec-
onds per sentence on average even with 10+ con-
straints, well within the realm of feasibility even
for applications with strict lattency requirements,
like post-editing tasks. We imagine that there are
further optimizations in reach that could improve
this even further.
Acknowledgments We thank Felix Hieber for
valuable discussions.
References
Peter Anderson, Basura Fernando, Mark Johnson, and
Stephen Gould. 2017. Guided open vocabulary im-
age captioning with constrained beam search. In
Proceedings of the 2017 Conference on Empirical
Methods in Natural Language Processing , pages
936‚Äì945. Association for Computational Linguis-
tics.
Philip Arthur, Graham Neubig, and Satoshi Nakamura.
2016. Incorporating discrete translation lexicons
into neural machine translation. In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing , pages 1557‚Äì1567. Asso-
ciation for Computational Linguistics.

--- PAGE 10 ---
OndÀárej Bojar, Rajen Chatterjee, Christian Federmann,
Yvette Graham, Barry Haddow, Shujian Huang,
Matthias Huck, Philipp Koehn, Qun Liu, Varvara
Logacheva, Christof Monz, Matteo Negri, Matt
Post, Raphael Rubino, Lucia Specia, and Marco
Turchi. 2017. Findings of the 2017 conference on
machine translation (wmt17). In Proceedings of the
Second Conference on Machine Translation , pages
169‚Äì214. Association for Computational Linguis-
tics.
Rajen Chatterjee, Matteo Negri, Marco Turchi, Mar-
cello Federico, Lucia Specia, and Fr ¬¥ed¬¥eric Blain.
2017. Guiding neural machine translation decod-
ing with external knowledge. In Proceedings of the
Second Conference on Machine Translation , pages
157‚Äì168. Association for Computational Linguis-
tics.
Josep Crego, Jungi Kim, Guillaume Klein, Anabel Re-
bollo, Kathy Yang, Jean Senellart, Egor Akhanov,
Patrice Brunelle, Aurelien Coquard, Yongchao
Deng, Satoshi Enoue, Chiyo Geiss, Joshua Johan-
son, Ardas Khalsa, Raoum Khiari, Byeongil Ko,
Catherine Kobus, Jean Lorieux, Leidiana Martins,
Dang-Chuan Nguyen, Alexandra Priori, Thomas
Riccardi, Natalia Segal, Christophe Servan, Cyril Ti-
quet, Bo Wang, Jin Yang, Dakun Zhang, Jing Zhou,
and Peter Zoldan. 2016. Systran‚Äôs pure neural ma-
chine translation systems. CoRR .
Felix Hieber, Tobias Domhan, Michael Denkowski,
David Vilar, Artem Sokolov, Ann Clifton, and Matt
Post. 2017. Sockeye: A toolkit for neural ma-
chine translation. Computing Research Repository ,
abs/1712.05690.
Chris Hokamp and Qun Liu. 2017. Lexically con-
strained decoding for sequence generation using grid
beam search. In Proceedings of the 55th Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers) , pages 1535‚Äì
1546. Association for Computational Linguistics.
Howard Johnson, Joel Martin, George Foster, and
Roland Kuhn. 2007. Improving translation qual-
ity by discarding most of the phrasetable. In Pro-
ceedings of the 2007 Joint Conference on Empirical
Methods in Natural Language Processing and Com-
putational Natural Language Learning (EMNLP-
CoNLL) .
Rebecca Knowles and Philipp Koehn. 2016. Neural
interactive translation prediction. In Proceedings
of the Association for Machine Translation in the
Americas , pages 107‚Äì120.
Philipp Koehn and Rebecca Knowles. 2017. Six chal-
lenges for neural machine translation. In Pro-
ceedings of the First Workshop on Neural Machine
Translation , pages 28‚Äì39. Association for Compu-
tational Linguistics.
Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proceedingsof the 2003 Human Language Technology Confer-
ence of the North American Chapter of the Associa-
tion for Computational Linguistics .
Pierre Lison and J ¬®org Tiedemann. 2016. Opensub-
titles2016: Extracting large parallel corpora from
movie and tv subtitles. In Proceedings of the Tenth
International Conference on Language Resources
and Evaluation (LREC 2016) , Paris, France. Euro-
pean Language Resources Association (ELRA).
Bruce T. Lowerre. 1976. The HARPY speech recogni-
tion system . Ph.D. thesis, Carnegie-Mellon Univer-
sity.
Christopher Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven Bethard, and David McClosky.
2014. The stanford corenlp natural language pro-
cessing toolkit. In Proceedings of 52nd Annual
Meeting of the Association for Computational Lin-
guistics: System Demonstrations , pages 55‚Äì60. As-
sociation for Computational Linguistics.
Myle Ott, Michael Auli, David Grangier, and
Marc‚ÄôAurelio Ranzato. 2018. Analyzing uncer-
tainty in neural machine translation. CoRR ,
abs/1803.00047.
Matt Post. 2018. A call for clarity in report-
ing bleu scores. Computing Research Repository ,
abs/1804.08771.
Rico Sennrich. 2017. How grammatical is character-
level neural machine translation? assessing mt qual-
ity with contrastive translation pairs. In Proceedings
of the 15th Conference of the European Chapter of
the Association for Computational Linguistics: Vol-
ume 2, Short Papers , pages 376‚Äì382. Association
for Computational Linguistics.
Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Neural machine translation of rare words
with subword units. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers) , pages 1715‚Äì
1725. Association for Computational Linguistics.
Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In Z. Ghahramani, M. Welling, C. Cortes,
N. D. Lawrence, and K. Q. Weinberger, editors, Ad-
vances in Neural Information Processing Systems
27, pages 3104‚Äì3112. Curran Associates, Inc.
Yaohua Tang, Fandong Meng, Zhengdong Lu, Hang Li,
and Philip L. H. Yu. 2016. Neural machine transla-
tion with external phrase memory. CoRR .
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. CoRR .
Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V .
Le, Mohammad Norouzi, Wolfgang Macherey,
Maxim Krikun, Yuan Cao, Qin Gao, Klaus

--- PAGE 11 ---
Macherey, Jeff Klingner, Apurva Shah, Melvin
Johnson, Xiaobing Liu, ≈Åukasz Kaiser, Stephan
Gouws, Yoshikiyo Kato, Taku Kudo, Hideto
Kazawa, Keith Stevens, George Kurian, Nishant
Patil, Wei Wang, Cliff Young, Jason Smith, Jason
Riesa, Alex Rudnick, Oriol Vinyals, Greg Corrado,
Macduff Hughes, and Jeffrey Dean. 2016. Google‚Äôs
neural machine translation system: Bridging the gap
between human and machine translation. CoRR ,
abs/1609.08144.
Joern Wuebker, Spence Green, John DeNero, Sasa
Hasan, and Minh-Thang Luong. 2016. Models and
inference for preÔ¨Åx-constrained machine translation.
InProceedings of the 54th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers) , pages 66‚Äì75. Association for Compu-
tational Linguistics.
A Appendix: Failed Experiments
The main contribution of this paper is a fast,
practical algorithmic improvement to lexically-
constrained decoding. While we did not attempt to
corroborate the experiments in interactive transla-
tion and domain adaptation experiments reported
in (Hokamp and Liu, 2017), the gains discovered
there only become more salient with this faster al-
gorithm. We did try to apply lexical constraints in
a few other settings, but without success. In the
spirit of open scientiÔ¨Åc inquiry and reporting, we
provide here a brief report on these experiments.
A.1 Automatic Constraint Selection
Our validation experiments ( x5) demonstrate the
large potential gains in BLEU score when includ-
ing random phrases from the reference. Even in-
cluding just a single random word from the ref-
erence increased BLEU score by a point; an-
other point was gained from including two ran-
dom words, and a four-word phrase yielded 10+
point gains. Only about 18% of these random un-
igrams were present in the unconstrained output
(less for longer n-grams). This raises the question
of whether we can automatically identify words
that are likely to be in the reference and include
them as constraints, in order to improve transla-
tion quality.
In order to do that, we Ô¨Årst extracted a phrase
table using Moses and Ô¨Åltered it with the signiÔ¨Å-
cance testing approach proposed by Johnson et al.
(2007) in order to keep only high quality phrases.
We then selected the best phrase for each input
sentence according to different criteria (longest
phrase, higher signiÔ¨Åcance, highest probability,
combination of those). Unfortunately, adding suchphrases as constraints when translating WMT or
IWSLT data did not help.
A.2 Name Entity Translation
One topic that has received attention in the litera-
ture is the tendency of NMT systems to do poorly
with rare words, and in particular, named entities
(e.g., Arthur et al. (2016)). BPE helps address this
by breaking down words into pieces and allowing
all words to be represented in the decoder‚Äôs vocab-
ulary. But even with BPE, many times the correct
translation does not follow any pattern, even at the
subword level. This is specially true for named
entities; e.g. ‚ÄúAachen‚Äù in German is translated as
‚ÄúAquisgr ¬¥an‚Äù in Spanish or ‚ÄúAix-la-Chapelle‚Äù in
French, which bear little resemblance to the origi-
nal form except for the starting letter. Named en-
tities (NEs) also have the advantage that in several
languages they are not inÔ¨Çected; therefore a simple
lookup in a dictionary, if available, should produce
the correct translation.
To the best of our knowledge, there is no pub-
licly available parallel corpus of named entities. In
order to create one, we downloaded the OpenSub-
titles database (Lison and Tiedemann, 2016) for
German and English and applied a simple method
for extracting named entity correspondences. We
Ô¨Årst tagged the source and target sides with the
Stanford NER system (Manning et al., 2014).
We then selected a subset of the tags that were
produced by both systems (‚ÄúPerson‚Äù, ‚ÄúLocation‚Äù
and ‚ÄúOrganization‚Äù) and selected those sentences
where they appeared only once for each language.
From those we extracted the corresponding NEs,
selecting the most frequent target side at the cor-
pus level as the translation of a given source NE.
Given such a dictionary, we can add the trans-
lation of a NE found in new sentences to translate
as decoding constraints. It didn‚Äôt help. Manual in-
spection showed that the dictionary extracted with
this simple method was still too noisy. We think
that a manual, high-quality dictionary may provide
a way to produce improvements.
