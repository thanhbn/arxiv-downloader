#!/usr/bin/env python3
"""
ArXiv CLI Autocompletion Setup Script
=====================================

This script generates and installs bash/zsh autocompletion for arxivdl_cli.py.
It creates completion scripts that provide command, subcommand, and file completion.

Usage:
    python3 setup_autocompletion.py
    python3 setup_autocompletion.py --install
    python3 setup_autocompletion.py --uninstall
    python3 setup_autocompletion.py --help
"""

import os
import sys
import argparse
import subprocess
from pathlib import Path
from typing import Dict, List, Optional

class AutocompletionSetup:
    """Setup autocompletion for arxivdl_cli.py."""
    
    def __init__(self):
        self.script_dir = Path(__file__).parent
        self.cli_script = self.script_dir / "arxivdl_cli.py"
        self.completion_dir = Path.home() / ".local/share/bash-completion/completions"
        self.zsh_completion_dir = Path.home() / ".zsh/completions"
        
        # Commands from arxivdl_cli.py
        self.commands = {
            'download': ['single', 'batch', 'crawler'],
            'convert': ['main'],
            'translate': ['claude', 'openai', 'check', 'queue', 'cleanup', 'stalled', 'test'],
            'organize': ['enhanced', 'basic', 'simple'],
            'analyze': ['duplicates', 'translations', 'monitor', 'status'],
            'inventory': ['all', 'expected', 'quick'],
            'setup': ['init', 'env', 'simple', 'test', 'direnv', 'completion'],
            'workflow': []
        }
        
        # Command-specific options mapping
        self.command_options = {
            'download': {
                'single': [],  # Uses positional args
                'batch': [],   # Uses positional args
                'crawler': []  # No known options
            },
            'convert': {
                'main': ['--convert', '--rename', '--both', '--collection', '--all', '--help']
            },
            'translate': {
                'claude': ['--workers', '--claude-path', '--queue-file', '--verbose', '--clean-only', '--clean-stale'],
                'openai': [],
                'check': ['--threshold', '--output', '--root-dir', '--move-vi', '--zip-txt', '--add-to-queue'],
                'queue': ['--queue-file', '--recursive', '--force', '--list', '--clear'],
                'cleanup': ['--threshold', '--backup', '--requeue', '--execute', '--verbose'],
                'stalled': ['--execute', '--max-age', '--score'],
                'test': []
            },
            'organize': {
                'enhanced': ['--execute', '--base-dir', '--collections', '--exclude', '--log-level', '--log-file', '--verbose'],
                'basic': [],
                'simple': []
            },
            'analyze': {
                'duplicates': ['--verbose', '--output-file', '--directory'],
                'translations': [],
                'monitor': [],
                'status': []
            },
            'inventory': {
                'all': ['--verbose', '--output-file', '--collections', '--format'],
                'expected': ['--collection', '--collections', '--format'],
                'quick': ['--summary']
            },
            'setup': {
                'init': ['--quick', '--full'],
                'env': [],
                'simple': [],
                'test': ['--verbose'],
                'direnv': [],
                'completion': ['--install', '--uninstall']
            }
        }
        
        # Common file extensions for autocompletion
        self.file_extensions = ['*.txt', '*.pdf', '*.py', '*.json', '*.log']
    
    def generate_bash_completion(self) -> str:
        """Generate bash completion script."""
        script_lines = [
            "#!/bin/bash",
            "# Bash completion for arxivdl_cli.py",
            "# Generated by setup_autocompletion.py",
            "",
            "_arxivdl_cli_completion() {",
            "    local cur prev words cword",
            "    _init_completion || return",
            "",
            "    # Main commands",
            f"    local commands=\"{' '.join(self.commands.keys())}\"",
            "",
            "    # Special options",
            "    local options=\"--help --samples --list --interactive\"",
            "",
            "    # Handle option completion for any position",
            "    if [[ \"$cur\" == --* ]]; then",
            "        local cmd_options=\"\"",
            "        case \"${words[1]}\" in"
        ]
        
        # Add option completions for each command
        for cmd, subcmds in self.commands.items():
            if cmd in self.command_options:
                script_lines.append(f"            {cmd})")
                all_options = set()
                for subcmd, opts in self.command_options[cmd].items():
                    all_options.update(opts)
                if all_options:
                    script_lines.append(f"                cmd_options=\"{' '.join(sorted(all_options))}\"")
                script_lines.append("                ;;")
        
        script_lines.extend([
            "        esac",
            "        COMPREPLY=($(compgen -W \"$cmd_options\" -- \"$cur\"))",
            "        return 0",
            "    fi",
            "",
            "    case $cword in",
            "        1)",
            "            # Complete main commands and options",
            "            COMPREPLY=($(compgen -W \"$commands $options\" -- \"$cur\"))",
            "            return 0",
            "            ;;",
            "        2)",
            "            # Complete subcommands based on main command",
            "            case $prev in"
        ])
        
        # Add subcommand completions
        for cmd, subcmds in self.commands.items():
            if subcmds:
                script_lines.append(f"                {cmd})")
                script_lines.append(f"                    COMPREPLY=($(compgen -W \"{' '.join(subcmds)}\" -- \"$cur\"))")
                script_lines.append("                    return 0")
                script_lines.append("                    ;;")
        
        script_lines.extend([
            "            esac",
            "            ;;",
            "        3)",
            "            # Complete options for subcommands",
            "            case \"${words[1]}-${words[2]}\" in"
        ])
        
        # Add specific option completions for command-subcommand pairs
        for cmd, subcmd_options in self.command_options.items():
            for subcmd, options in subcmd_options.items():
                if options:
                    script_lines.append(f"                {cmd}-{subcmd})")
                    script_lines.append(f"                    COMPREPLY=($(compgen -W \"{' '.join(options)}\" -- \"$cur\"))")
                    script_lines.append("                    return 0")
                    script_lines.append("                    ;;")
        
        script_lines.extend([
            "            esac",
            "            ;;",
            "        *)",
            "            # Complete files for remaining arguments",
            "            case ${words[1]} in",
            "                download)",
            "                    # Complete .txt files for download command",
            "                    COMPREPLY=($(compgen -f -X '!*.txt' -- \"$cur\"))",
            "                    ;;",
            "                convert)",
            "                    # Complete .pdf files for convert command",
            "                    COMPREPLY=($(compgen -f -X '!*.pdf' -- \"$cur\"))",
            "                    ;;",
            "                translate)",
            "                    # Complete .txt files for translate command",
            "                    COMPREPLY=($(compgen -f -X '!*.txt' -- \"$cur\"))",
            "                    ;;",
            "                *)",
            "                    # Default file completion",
            "                    COMPREPLY=($(compgen -f -- \"$cur\"))",
            "                    ;;",
            "            esac",
            "            ;;",
            "    esac",
            "}",
            "",
            "# Register completion function",
            "complete -F _arxivdl_cli_completion arxivdl_cli.py",
            "complete -F _arxivdl_cli_completion python3 arxivdl_cli.py",
            ""
        ])
        
        return "\n".join(script_lines)
    
    def generate_zsh_completion(self) -> str:
        """Generate zsh completion script."""
        script_lines = [
            "#compdef arxivdl_cli.py",
            "# Zsh completion for arxivdl_cli.py",
            "# Generated by setup_autocompletion.py",
            "",
            "_arxivdl_cli() {",
            "    local context state state_descr line",
            "    typeset -A opt_args",
            "",
            "    _arguments -C \\",
            "        '1: :->command' \\",
            "        '2: :->subcommand' \\",
            "        '*: :->args' && return 0",
            "",
            "    case $state in",
            "        command)",
            "            local commands=(",
        ]
        
        # Add commands with descriptions
        for cmd in self.commands.keys():
            desc = f"'{cmd}:Main command {cmd}'"
            script_lines.append(f"                {desc}")
        
        script_lines.extend([
            "                '--help:Show help message'",
            "                '--samples:Show sample commands'",
            "                '--list:List available commands'",
            "                '--interactive:Interactive sample picker'",
            "            )",
            "            _describe 'commands' commands",
            "            ;;",
            "        subcommand)",
            "            case $words[2] in"
        ])
        
        # Add subcommand completions with options
        for cmd, subcmds in self.commands.items():
            if subcmds:
                script_lines.append(f"                {cmd})")
                script_lines.append("                    local subcommands=(")
                for subcmd in subcmds:
                    # Add options for this subcommand
                    options = self.command_options.get(cmd, {}).get(subcmd, [])
                    if options:
                        options_str = ' '.join(options)
                        script_lines.append(f"                        '{subcmd}:Subcommand {subcmd} (options: {options_str})'")
                    else:
                        script_lines.append(f"                        '{subcmd}:Subcommand {subcmd}'")
                script_lines.append("                    )")
                script_lines.append("                    _describe 'subcommands' subcommands")
                script_lines.append("                    ;;")
        
        script_lines.extend([
            "            esac",
            "            ;;",
            "        args)",
            "            # Handle option completion",
            "            if [[ $words[CURRENT] == --* ]]; then",
            "                local cmd_options=()",
            "                case \"$words[2]-$words[3]\" in"
        ])
        
        # Add specific option completions for command-subcommand pairs
        for cmd, subcmd_options in self.command_options.items():
            for subcmd, options in subcmd_options.items():
                if options:
                    script_lines.append(f"                    {cmd}-{subcmd})")
                    script_lines.append("                        cmd_options=(")
                    for option in options:
                        script_lines.append(f"                            '{option}:Option {option}'")
                    script_lines.append("                        )")
                    script_lines.append("                        ;;")
        
        script_lines.extend([
            "                esac",
            "                _describe 'options' cmd_options",
            "                return 0",
            "            fi",
            "",
            "            # Handle file completion",
            "            case $words[2] in",
            "                download)",
            "                    _files -g '*.txt'",
            "                    ;;",
            "                convert)",
            "                    _files -g '*.pdf'",
            "                    ;;",
            "                translate)",
            "                    _files -g '*.txt'",
            "                    ;;",
            "                *)",
            "                    _files",
            "                    ;;",
            "            esac",
            "            ;;",
            "    esac",
            "}",
            "",
            "_arxivdl_cli \"$@\"",
            ""
        ])
        
        return "\n".join(script_lines)
    
    def create_completion_files(self) -> Dict[str, Path]:
        """Create completion files."""
        bash_script = self.generate_bash_completion()
        zsh_script = self.generate_zsh_completion()
        
        # Create bash completion file
        bash_file = self.script_dir / "arxivdl_cli_completion.bash"
        with open(bash_file, 'w') as f:
            f.write(bash_script)
        
        # Create zsh completion file
        zsh_file = self.script_dir / "_arxivdl_cli"
        with open(zsh_file, 'w') as f:
            f.write(zsh_script)
        
        print(f"✅ Created bash completion: {bash_file}")
        print(f"✅ Created zsh completion: {zsh_file}")
        
        return {
            'bash': bash_file,
            'zsh': zsh_file
        }
    
    def install_bash_completion(self, completion_file: Path) -> bool:
        """Install bash completion system-wide."""
        try:
            # Create completion directory if it doesn't exist
            self.completion_dir.mkdir(parents=True, exist_ok=True)
            
            # Copy completion file
            target_file = self.completion_dir / "arxivdl_cli.py"
            import shutil
            shutil.copy2(completion_file, target_file)
            
            print(f"✅ Installed bash completion to: {target_file}")
            print("   Restart your shell or run: source ~/.bashrc")
            return True
            
        except Exception as e:
            print(f"❌ Error installing bash completion: {e}")
            return False
    
    def install_zsh_completion(self, completion_file: Path) -> bool:
        """Install zsh completion system-wide."""
        try:
            # Create completion directory if it doesn't exist
            self.zsh_completion_dir.mkdir(parents=True, exist_ok=True)
            
            # Copy completion file
            target_file = self.zsh_completion_dir / "_arxivdl_cli"
            import shutil
            shutil.copy2(completion_file, target_file)
            
            # Add to fpath if not already there
            zshrc_file = Path.home() / ".zshrc"
            fpath_line = f"fpath=({self.zsh_completion_dir} $fpath)"
            
            if zshrc_file.exists():
                content = zshrc_file.read_text()
                if str(self.zsh_completion_dir) not in content:
                    with open(zshrc_file, 'a') as f:
                        f.write(f"\n# ArXiv CLI autocompletion\n{fpath_line}\n")
                    print(f"✅ Added completion path to {zshrc_file}")
            else:
                with open(zshrc_file, 'w') as f:
                    f.write(f"# ArXiv CLI autocompletion\n{fpath_line}\n")
                print(f"✅ Created {zshrc_file} with completion path")
            
            print(f"✅ Installed zsh completion to: {target_file}")
            print("   Restart your shell or run: source ~/.zshrc")
            return True
            
        except Exception as e:
            print(f"❌ Error installing zsh completion: {e}")
            return False
    
    def uninstall_completions(self) -> bool:
        """Uninstall completion files."""
        success = True
        
        # Remove bash completion
        bash_target = self.completion_dir / "arxivdl_cli.py"
        if bash_target.exists():
            try:
                bash_target.unlink()
                print(f"✅ Removed bash completion: {bash_target}")
            except Exception as e:
                print(f"❌ Error removing bash completion: {e}")
                success = False
        
        # Remove zsh completion
        zsh_target = self.zsh_completion_dir / "_arxivdl_cli"
        if zsh_target.exists():
            try:
                zsh_target.unlink()
                print(f"✅ Removed zsh completion: {zsh_target}")
            except Exception as e:
                print(f"❌ Error removing zsh completion: {e}")
                success = False
        
        return success
    
    def detect_shell(self) -> str:
        """Detect current shell."""
        shell = os.environ.get('SHELL', '').lower()
        if 'zsh' in shell:
            return 'zsh'
        elif 'bash' in shell:
            return 'bash'
        else:
            return 'unknown'
    
    def generate_manual_instructions(self, completion_files: Dict[str, Path]):
        """Generate manual installation instructions."""
        print("\n" + "="*60)
        print("MANUAL INSTALLATION INSTRUCTIONS")
        print("="*60)
        
        print("\n🔧 BASH COMPLETION:")
        print(f"   1. Copy: {completion_files['bash']}")
        print(f"   2. To: ~/.local/share/bash-completion/completions/arxivdl_cli.py")
        print("   3. Restart shell or run: source ~/.bashrc")
        print("\n   Alternative (current session only):")
        print(f"   source {completion_files['bash']}")
        
        print("\n🔧 ZSH COMPLETION:")
        print(f"   1. Copy: {completion_files['zsh']}")
        print(f"   2. To: ~/.zsh/completions/_arxivdl_cli")
        print("   3. Add to ~/.zshrc:")
        print("      fpath=(~/.zsh/completions $fpath)")
        print("      autoload -U compinit && compinit")
        print("   4. Restart shell or run: source ~/.zshrc")
        
        print("\n🔧 SYSTEM-WIDE INSTALLATION:")
        print("   Bash: sudo cp completion_file /etc/bash_completion.d/")
        print("   Zsh: sudo cp completion_file /usr/share/zsh/site-functions/")
        
        print("\n🔧 TESTING:")
        print("   Type: python3 arxivdl_cli.py [TAB][TAB]")
        print("   Should show: download convert translate organize analyze...")
    
    def run(self, install: bool = False, uninstall: bool = False):
        """Run the autocompletion setup."""
        print("ArXiv CLI Autocompletion Setup")
        print("="*40)
        
        if uninstall:
            print("🗑️  Uninstalling completions...")
            success = self.uninstall_completions()
            if success:
                print("✅ Uninstallation completed successfully")
            else:
                print("❌ Some errors occurred during uninstallation")
            return
        
        # Create completion files
        print("📝 Generating completion scripts...")
        completion_files = self.create_completion_files()
        
        if install:
            print("🔧 Installing completions...")
            shell = self.detect_shell()
            print(f"   Detected shell: {shell}")
            
            if shell == 'bash':
                self.install_bash_completion(completion_files['bash'])
            elif shell == 'zsh':
                self.install_zsh_completion(completion_files['zsh'])
            else:
                print("   Unknown shell, installing both...")
                self.install_bash_completion(completion_files['bash'])
                self.install_zsh_completion(completion_files['zsh'])
        
        # Always show manual instructions
        self.generate_manual_instructions(completion_files)
        
        print("\n✅ Setup completed!")
        print("   Restart your shell to enable autocompletion")

def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description="Setup autocompletion for arxivdl_cli.py",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python3 setup_autocompletion.py                # Generate completion files
    python3 setup_autocompletion.py --install      # Generate and install
    python3 setup_autocompletion.py --uninstall    # Remove completions
        """
    )
    
    parser.add_argument(
        '--install', '-i',
        action='store_true',
        help='Install completion files to user directories'
    )
    
    parser.add_argument(
        '--uninstall', '-u',
        action='store_true',
        help='Remove installed completion files'
    )
    
    args = parser.parse_args()
    
    if args.install and args.uninstall:
        print("Error: Cannot specify both --install and --uninstall")
        sys.exit(1)
    
    # Create and run setup
    setup = AutocompletionSetup()
    setup.run(install=args.install, uninstall=args.uninstall)

if __name__ == "__main__":
    main()