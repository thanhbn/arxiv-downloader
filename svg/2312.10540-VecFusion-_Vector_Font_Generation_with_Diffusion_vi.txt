VecFusion: Tạo phông chữ vector bằng mô hình khuếch tán

Vikas Thamizharasan*1,2Difan Liu*2Shantanu Agarwal1Matthew Fisher2
Micha ¨el Gharbi2Oliver Wang3Alec Jacobson2,4Evangelos Kalogerakis1
Đại học Massachusetts Amherst1Adobe Research2Google Research3Đại học Toronto4

(a) Tạo ký tự thiếu
(b) Tạo ký tự vector với vài mẫu Ký tự vector được tổng hợp Hình ảnh raster đầu vào

Hình 1. Chúng tôi trình bày VecFusion, một mô hình tạo sinh cho phông chữ vector. (a) VecFusion tạo ra các ký tự thiếu trong phông chữ không đầy đủ. Các ký tự màu xanh là các ký tự tồn tại trong phông chữ. Các ký tự màu đỏ là các ký tự thiếu được tạo ra bởi phương pháp của chúng tôi. Ở bên phải, chúng tôi hiển thị các điểm điều khiển được tạo ra dưới dạng vòng tròn trên các ký tự được chọn. (b) VecFusion tạo ra các ký tự vector từ một vài hình ảnh ký tự mẫu (raster). Phương pháp của chúng tôi tạo ra các phông chữ vector chính xác, có thể chỉnh sửa với hình học và điểm điều khiển được học để phù hợp với phong cách phông chữ mục tiêu.

Tóm tắt
Chúng tôi trình bày VecFusion, một kiến trúc mạng nơ-ron mới có thể tạo ra phông chữ vector với cấu trúc tôpô khác nhau và vị trí điểm điều khiển chính xác. Phương pháp của chúng tôi là một mô hình khuếch tán cascaded bao gồm một mô hình khuếch tán raster theo sau bởi một mô hình khuếch tán vector. Mô hình raster tạo ra phông chữ raster hóa độ phân giải thấp với thông tin điểm điều khiển phụ trợ, nắm bắt phong cách và hình dáng tổng thể của phông chữ, trong khi mô hình vector tổng hợp phông chữ vector dựa trên phông chữ raster độ phân giải thấp từ giai đoạn đầu tiên. Để tổng hợp các đường cong dài và phức tạp, mô hình khuếch tán vector của chúng tôi sử dụng kiến trúc transformer và một biểu diễn vector mới cho phép mô hình hóa hình học vector đa dạng và dự đoán chính xác các điểm điều khiển. Các thí nghiệm của chúng tôi cho thấy rằng, trái ngược với các mô hình tạo sinh trước đây cho đồ họa vector, mô hình khuếch tán vector cascaded mới của chúng tôi tạo ra phông chữ vector chất lượng cao hơn, với cấu trúc phức tạp và phong cách đa dạng.

1. Giới thiệu
Phông chữ vector được sử dụng rộng rãi trong thiết kế đồ họa, nghệ thuật, xuất bản và đồ họa chuyển động. Trái ngược với phông chữ raster hóa, phông chữ vector có thể được render ở bất kỳ độ phân giải nào mà không bị giảm chất lượng, và có thể được chỉnh sửa thông qua thao tác điểm điều khiển trực quan. Tuy nhiên, việc tạo ra phông chữ vector chất lượng cao vẫn là một nhiệm vụ thách thức và tốn nhiều công sức, ngay cả đối với các nhà thiết kế chuyên gia. Các phương pháp gần đây [6, 31, 51] sử dụng VAE hoặc mô hình tự hồi quy để tự động tổng hợp phông chữ vector, nhưng chúng thường gặp khó khăn trong việc nắm bắt một loạt cấu trúc tôpô và biến thể ký tự đa dạng, do tính mơ hồ vốn có của các đường cong vector. Kết quả là, chúng thường tạo ra các tạo tác và vị trí điểm điều khiển không chính xác, làm ảnh hưởng đến chất lượng tổng thể và khả năng chỉnh sửa của phông chữ được tổng hợp.

Trong công trình này, chúng tôi tận dụng những tiến bộ gần đây trong các mô hình tạo sinh raster, để thiết kế một mô hình tạo sinh cho phông chữ vector. Một mô hình tạo sinh như vậy có một số ứng dụng thực tế, chẳng hạn như hoàn thiện ký tự, chuyển đổi phong cách với ít mẫu, và nội suy phong cách phông chữ. Tuy nhiên, việc huấn luyện các mô hình tạo sinh miền vector không đơn giản: cấu trúc dữ liệu không đều của đồ họa vector ngăn cản việc áp dụng một cách ngây thơ các kiến trúc dựa trên CNN thường được sử dụng. Hơn nữa, có một tính mơ hồ vốn có trong biểu diễn vector: vô số cấu hình điểm điều khiển có thể tạo ra cùng một ký tự, nhưng không phải tất cả các cấu hình đều tương đương. Đặc biệt, các nhà thiết kế cẩn thận tạo ra các điểm điều khiển để phông chữ có thể được chỉnh sửa một cách trực quan. Phông chữ vector được tạo ra nên tuân theo mục tiêu thiết kế tương tự.

Để giải quyết những thách thức nêu trên, chúng tôi đề xuất một mô hình khuếch tán hai giai đoạn mới, được gọi là VecFusion, để tạo ra phông chữ vector chất lượng cao. Pipeline của chúng tôi là một cascade của một mô hình khuếch tán raster theo sau bởi một mô hình khuếch tán vector. Mô hình khuếch tán raster dần dần biến đổi một bản đồ nhiễu 2D Gaussian thành một hình ảnh raster mục tiêu của ký tự ở độ phân giải thấp, dựa trên định danh ký tự mục tiêu và phong cách phông chữ mục tiêu. Nó cũng tạo ra các trường raster phụ trợ để điều khiển việc đặt các điểm điều khiển vector trong giai đoạn tiếp theo. Giai đoạn thứ hai là một mô hình khuếch tán vector dựa trên các đầu ra raster từ giai đoạn đầu tiên. Nó được huấn luyện để "khử nhiễu" một biểu diễn ký tự vector nhiễu thành các đường cong có cấu trúc đại diện cho ký tự.

Đóng góp. Bài báo này đưa ra một số đóng góp. Đầu tiên, chúng tôi trình bày một mô hình khuếch tán cascaded hai giai đoạn mới để tạo ra phông chữ vector chất lượng cao. Quá trình cascading này cho phép chúng tôi hiệu quả "upsample" các đầu ra raster độ phân giải thấp thành một biểu diễn vector. Chúng tôi giới thiệu một biểu diễn hỗn hợp rời rạc-liên tục mới cho các điểm điều khiển, cho phép mô hình khuếch tán vector tự động dự đoán số lượng điểm điều khiển và đường dẫn để sử dụng cho một ký tự, cũng như vị trí của chúng. Chúng tôi cho thấy rằng các mô hình khuếch tán có thể hiệu quả "khử nhiễu" trong không gian biểu diễn mới này. Hơn nữa, để nắm bắt các phụ thuộc tầm xa và phù hợp với bản chất không đều của biểu diễn vector, chúng tôi giới thiệu một mô hình khuếch tán vector dựa trên transformer. Cuối cùng, chúng tôi cho thấy rằng VecFusion tổng hợp phông chữ với độ trung thực cao hơn nhiều so với các phương pháp tiên tiến được đánh giá trên các tập dữ liệu với phong cách phông chữ đa dạng.

2. Công trình liên quan
Đồ họa vector tạo sinh. Công việc đáng kể đã được đầu tư vào mô hình hóa tạo sinh của đồ họa vector, sử dụng VAE [22, 31], các mô hình sequence-to-sequence như RNN [14] hoặc transformer [40]. Các phương pháp gần đây sử dụng các mô hình tạo sinh phân cấp [6], trong khi những phương pháp khác bỏ qua nhu cầu giám sát vector trực tiếp [39], sử dụng một rasterizer khả vi [25].

Tạo phông chữ. Do tính phổ biến và vai trò trung tâm trong thiết kế, phông chữ đã nhận được sự chú ý đặc biệt và các phương pháp tổng hợp chuyên dụng. Nhiều phương pháp học cách tạo ra phông chữ raster từ một tập lớn các ký tự tham chiếu [12, 19] hoặc một vài hình ảnh mẫu [1, 7, 13, 23, 37, 45]. Những phương pháp này tạo ra phông chữ raster hấp dẫn về mặt thị giác với nhiều phong cách khác nhau, nhưng không thể tạo ra đầu ra vector, do đó chúng bị giới hạn bởi độ phân giải và các tạo tác pixel hóa. Trong nhiệm vụ tạo phông chữ vector, các phương pháp ban đầu sử dụng các mô hình template có thể biến hình [44], hoặc học đa tạp để cho phép nội suy/ngoại suy các phông chữ hiện có [5], trong khi các phương pháp gần đây sử dụng các mô hình tạo sinh sâu [26, 50]. Thế hệ đầu tiên của giải pháp học sâu đôi khi tạo ra các ký tự với méo mó mạnh và tạo tác thị giác. Các phương pháp như DeepVecFont-v2 [51] cải thiện chất lượng tổng hợp bằng cách sử dụng kiến trúc transformer. Mặc dù những phương pháp này có thể tạo ra phông chữ vector hấp dẫn về mặt thị giác, việc mô hình hóa hiệu quả một phân phối đa dạng của các ký tự và tôpô vẫn là một thách thức. Ví dụ, DeepVecFont-v2 chỉ hỗ trợ một số lượng hạn chế các ký tự (52 ký tự).

Mô hình khuếch tán. Để giải quyết những thách thức trong thiết kế trường vector, chúng tôi tận dụng các mô hình khuếch tán [15] cho khả năng mô hình hóa các phân phối dữ liệu đa dạng và phức tạp. Không giống như các phương pháp trước đây [9, 48] sử dụng các mô hình khuếch tán vector dựa trên CNN hoặc RNN, phương pháp của chúng tôi sử dụng một mô hình khuếch tán vector dựa trên transformer để xử lý các phụ thuộc tầm xa vốn có trong các ký tự vector phức tạp. Hơn nữa, phương pháp raster-vector hai giai đoạn và biểu diễn vector mới của chúng tôi cho phép dự đoán đường cong Bézier chính xác trên các tập dữ liệu phông chữ được thiết kế bởi nghệ sĩ đầy thách thức.

Khuếch tán cascaded. Các mô hình khuếch tán cascaded [17] đã đạt được chất lượng tổng hợp ấn tượng trên nhiều lĩnh vực khác nhau, bao gồm hình ảnh [2, 42], video [4, 16] và 3D [18, 27]. Theo tinh thần tương tự, chúng tôi giới thiệu một mô hình khuếch tán cascaded để tạo ra phông chữ vector chất lượng cao.

Vector hóa hình ảnh. Các phương pháp vector hóa hình ảnh [3, 33, 46] tạo ra một biểu diễn đồ họa vector từ một hình ảnh raster. Dành riêng cho vector hóa bản vẽ đường, nhiều phương pháp dựa trên học máy [21, 35, 38] đã được đề xuất. Mặc dù những phương pháp này có thể tạo ra đồ họa vector chất lượng cao, chúng thường tạo ra các điểm điều khiển dư thừa hoặc không chính xác và không thể tạo ra kết quả có độ trung thực cao trên các hình ảnh raster độ phân giải thấp. Mô hình khuếch tán của chúng tôi có thể tạo ra hình học vector chính xác từ các hình ảnh raster độ phân giải thấp, cũng cung cấp một góc nhìn mới cho vector hóa hình ảnh.

3. Phương pháp
Tổng quan. Mục tiêu của VecFusion là tự động tạo ra các biểu diễn đồ họa vector của các ký tự. Đầu vào cho mô hình của chúng tôi là định danh Unicode cho một ký tự mục tiêu, còn được gọi là code point, và một phong cách phông chữ mục tiêu. Phong cách phông chữ mục tiêu có thể được chỉ định dưới dạng một vài hình ảnh raster đại diện của các ký tự khác trong phong cách đó hoặc đơn giản bằng tên phong cách phông chữ. Hình 2 cho thấy một ví dụ về biểu diễn vector được tạo ra cho ký tự tương ứng với chữ cái "sha" đầu vào của bảng chữ cái Devanagari và phong cách phông chữ mục tiêu "Mukta". Phương pháp của chúng tôi được huấn luyện một lần trên một tập dữ liệu lớn các ký tự từ nhiều phong cách phông chữ khác nhau. Sau khi được huấn luyện, nó có thể tạo ra các ký tự không được quan sát trong quá trình huấn luyện. Mô hình của chúng tôi có một số ứng dụng: tạo ra các ký tự thiếu trong phông chữ không đầy đủ, tổng hợp phông chữ mới bằng cách chuyển đổi phong cách của một vài hình ảnh ký tự mẫu, hoặc nội suy phong cách phông chữ.

Biểu diễn vector đầu ra. Biểu diễn vector được tạo ra cho một ký tự ở dạng các chuỗi có thứ tự của các điểm điều khiển trong các đường dẫn đường cong Bézier bậc ba thường được sử dụng trong đồ họa vector. Các điểm điều khiển có thể được lặp lại trong các chuỗi được tạo ra để thao tác tính liên tục của đường dẫn vector. Phương pháp của chúng tôi học cách tạo ra một số lượng phù hợp các đường dẫn vector, điểm điều khiển và lặp lại điểm được điều chỉnh cho từng ký tự và phong cách phông chữ. Ngoài ra, nó học thứ tự thích hợp của các điểm điều khiển cho mỗi đường dẫn, bao gồm nơi đặt điểm điều khiển đầu tiên và cuối cùng, vì các mẫu đặt của chúng thường phản ánh sở thích của nghệ sĩ.

Pipeline. Phương pháp của chúng tôi bao gồm một cascade hai giai đoạn. Trong giai đoạn đầu tiên (mô hình khuếch tán raster, hay viết tắt là "Raster-DM", Hình 2), dựa trên code point ký tự mục tiêu và phong cách phông chữ, phương pháp của chúng tôi bắt đầu một quá trình khuếch tán ngược để tạo ra một hình ảnh raster. Hình ảnh raster được tạo ra nắm bắt hình dáng và phong cách của ký tự mục tiêu ở độ phân giải thấp. Ngoài ra, chúng tôi tạo ra một tập hợp phụ trợ các trường điểm điều khiển mã hóa thông tin về vị trí điểm điều khiển, tính đa dạng và thứ tự. Trong giai đoạn thứ hai (mô hình khuếch tán vector hay "Vector-DM", Hình 2), phương pháp của chúng tôi tiếp tục bằng cách tổng hợp định dạng vector nắm bắt vị trí tinh vi của các điểm điều khiển được hướng dẫn bởi ký tự raster và các trường điểm điều khiển được tạo ra trong giai đoạn đầu tiên. Chúng tôi quan sát thấy rằng phương pháp hai giai đoạn này dẫn đến việc tạo ra phông chữ có độ trung thực cao hơn so với việc sử dụng khuếch tán trong không gian vector trực tiếp hoặc không có bất kỳ hướng dẫn nào từ các trường điểm điều khiển của chúng tôi. Trong các phần tiếp theo, chúng tôi thảo luận về các giai đoạn khuếch tán raster và vector của chúng tôi chi tiết hơn.

3.1. Giai đoạn khuếch tán raster
Với định danh ký tự mục tiêu và phong cách phông chữ, giai đoạn khuếch tán raster tạo ra một hình ảnh raster x0 mã hóa thông tin về ký tự mục tiêu trong không gian pixel (Hình 2, "Raster-DM"). Điều này được thực hiện thông qua một mô hình khuếch tán dần dần biến đổi một hình ảnh xT được lấy mẫu từ một phân phối nhiễu Gaussian đơn vị hướng tới hình ảnh raster mục tiêu x0 trong một loạt T bước khử nhiễu. Tại mỗi bước t = 1...T, một mạng nơ-ron được huấn luyện thực hiện việc chuyển đổi xt → xt−1 bằng cách dự đoán nội dung nhiễu cần được loại bỏ khỏi hình ảnh xt. Mạng khử nhiễu này được điều kiện hóa trên định danh ký tự đầu vào và phong cách phông chữ. Trong các đoạn tiếp theo, chúng tôi giải thích việc mã hóa codepoint ký tự đầu vào và phong cách phông chữ, hình ảnh raster mục tiêu, mạng khử nhiễu, và cuối cùng là các quá trình huấn luyện và suy luận của giai đoạn này.

Embedding định danh ký tự. Lấy cảm hứng từ các phương pháp tương tự trong NLP để biểu diễn từ [47], chúng tôi tạo ra một biểu diễn vector one-hot cho tất cả các codepoint ký tự duy nhất có sẵn trong tập dữ liệu của chúng tôi. Với codepoint của một ký tự mục tiêu, biểu diễn vector one-hot của nó được ánh xạ tới một embedding liên tục g thông qua một bảng tra cứu đã học. Bảng tra cứu lưu trữ các embedding cho tất cả các codepoint có sẵn trong tập dữ liệu của chúng tôi và truy xuất chúng bằng cách sử dụng vector one-hot làm chỉ số.

Điều kiện hóa phong cách phông chữ. Để mã hóa phong cách phông chữ, chúng tôi đã thử nghiệm với hai phương pháp tùy thuộc vào ứng dụng. Để tạo ra các ký tự thiếu trong phông chữ không đầy đủ, chúng tôi tạo ra một biểu diễn vector one-hot cho tất cả các phong cách phông chữ có sẵn trong tập dữ liệu của chúng tôi. Với một phong cách phông chữ mục tiêu, vector one-hot của nó được ánh xạ tới một embedding liên tục f thông qua một bảng tra cứu đã học như trên. Để tạo ra các ký tự dựa trên một vài hình ảnh mẫu, chúng tôi nối các hình ảnh đầu vào theo kênh và truyền chúng qua một convnet để có được một feature map phong cách phông chữ f (xem phần bổ sung để biết thêm chi tiết.)

Hình ảnh raster mục tiêu. Mục tiêu x0 được tạo ra trong giai đoạn khuếch tán raster là một hình ảnh N×N được tạo thành từ các kênh sau:

(a) kênh đầu tiên bao gồm một hình ảnh đại diện cho một hình ảnh raster hóa thang độ xám của ký tự mục tiêu (Hình 3, trên).
(b) các kênh còn lại lưu trữ các trường điểm điều khiển (Hình 3, dưới), có mục tiêu mã hóa thông tin về vị trí điểm điều khiển, tính đa dạng và thứ tự.

Trong quá trình huấn luyện, trường điểm điều khiển này được tạo ra bằng cách render mỗi điểm điều khiển dưới dạng một blob Gaussian tập trung tại tọa độ 2D (x,y) của điểm điều khiển. Các tọa độ được chuẩn hóa trong [0,1]2. Chúng tôi cũng điều chỉnh màu sắc của blob dựa trên (a) chỉ số của điểm điều khiển trong chuỗi điểm điều khiển của đường dẫn vector của nó (ví dụ, điểm điều khiển thứ nhất, thứ hai, thứ ba, v.v.), và (b) tính đa dạng của nó. Một hàm tra cứu được sử dụng để dịch các chỉ số thứ tự và tính đa dạng của điểm điều khiển thành cường độ màu sắc. Trong implementation của chúng tôi, chúng tôi sử dụng 3 kênh cho trường điểm điều khiển này, có thể được hình dung thực tế như một hình ảnh RGB (Hình 3, dưới). Các kênh này được nối với hình ảnh raster của ký tự, tạo thành một hình ảnh 4 kênh.

Khử nhiễu raster. Bộ khử nhiễu được hình thành như một kiến trúc UNet [11]. Mạng lấy hình ảnh 4 kênh xt làm đầu vào và được điều kiện hóa trên embedding của bước thời gian t. Theo [41], chúng tôi thêm embedding codepoint ký tự g vào embedding bước thời gian và truyền nó tới mỗi khối residual trong UNet. Đối với điều kiện hóa phong cách phông chữ, chúng tôi thêm nó vào embedding bước thời gian nếu nó là một embedding đơn. Nếu phong cách phông chữ được mã hóa như một feature map không gian, theo [41], chúng tôi làm phẳng feature map và tiêm nó vào UNet thông qua cross-attention.

Mạng khử nhiễu dự đoán thành phần nhiễu theo kênh của hình ảnh đầu vào, đây cũng là một hình ảnh 4 kênh (xem phần bổ sung để biết thêm chi tiết.).

Loss huấn luyện Mạng được huấn luyện để xấp xỉ một bộ khử nhiễu tối ưu dưới điều kiện là các hình ảnh x1, x2, ...xT được tạo ra bằng cách dần dần thêm nhiễu Gaussian vào hình ảnh của bước trước đó [15]: q(xt|xt−1) = N (xt; √(1−βt)xt−1, βtI), trong đó βt đại diện cho phương sai của nhiễu Gaussian được thêm vào mỗi bước. Hình ảnh xT hội tụ về một phân phối Gaussian đơn vị khi T → ∞, hoặc thực tế là một số lượng lớn các bước [15]. Theo [15], chúng tôi huấn luyện mạng khử nhiễu với mục tiêu huấn luyện ||ε(xt, t, f, g) − ε||2 tức là loss lỗi bình phương trung bình giữa nhiễu huấn luyện ε tại mỗi bước và nhiễu dự đoán ε(xt, t, f, g) từ mạng. Loss này được sử dụng để huấn luyện bộ khử nhiễu và các bảng tra cứu.

Suy luận. Tại thời điểm kiểm tra, với nhiễu Gaussian đơn vị được lấy mẫu xT, một embedding ký tự mục tiêu g và điều kiện hóa phong cách phông chữ f, mạng được áp dụng liên tiếp trong T bước để tạo ra hình ảnh raster mục tiêu.

Chi tiết implementation. Trong tất cả các thí nghiệm của chúng tôi, chúng tôi sử dụng các siêu tham số sau. Theo [36], chúng tôi đặt số bước khuếch tán T thành 1000 và sử dụng lịch trình nhiễu cosine trong quá trình khuếch tán tiến. Huấn luyện mất 5 ngày trên 8 GPU A100. Chúng tôi sử dụng optimizer AdamW [32] với tốc độ học 3.24·10−5. Các feature embedding cho định danh ký tự được đặt là 896 chiều. Các điểm điều khiển được render dưới dạng blob Gaussian với bán kính 2 pixel. Độ phân giải hình ảnh raster được đặt thành 64×64. Độ phân giải thấp hơn gây ra sự chồng chéo tăng giữa các blob được render, làm cho trường điểm điều khiển trở nên mơ hồ hơn. Tăng độ phân giải làm tăng chi phí tính toán cho bộ khử nhiễu raster. Độ phân giải trên đại diện cho một sự đánh đổi tốt, như chúng tôi đã tìm thấy trong thực tế trong các thí nghiệm của mình. Như đã đề cập ở trên, chúng tôi sử dụng 3 kênh để mã hóa thứ tự điểm điều khiển và tính đa dạng dưới dạng màu sắc. Chúng tôi quan sát thực tế rằng 3 kênh là đủ để hướng dẫn giai đoạn khuếch tán vector. Tùy thuộc vào tập dữ liệu, có thể sử dụng ít kênh hơn thay thế, ví dụ, trong trường hợp các ký tự có ít điểm điều khiển, hoặc không có tính đa dạng. Nói chung, những siêu tham số này có thể được điều chỉnh cho các nhiệm vụ đồ họa vector khác nhau - điểm chính của chúng tôi là các hình ảnh raster và trường hữu ích như hướng dẫn để tạo ra phông chữ vector có độ trung thực cao, như được thể hiện trong nghiên cứu loại bỏ của chúng tôi.

3.2. Giai đoạn khuếch tán vector
Với hình ảnh raster được tạo ra trong giai đoạn trước, giai đoạn khuếch tán vector tạo ra một tensor y0 đại diện cho ký tự mục tiêu ở định dạng đồ họa vector (Hình 2 "Vector-DM"). Quá trình khuếch tán ngược dần dần biến đổi một tensor nhiễu yT được lấy mẫu từ một phân phối nhiễu Gaussian đơn vị hướng tới một tensor y0 trong một loạt các bước khử nhiễu. Trong miền này, nhiễu đại diện cho nhiễu trên vị trí không gian và thành viên đường dẫn của các điểm điều khiển, thay vì cường độ của các giá trị pixel như trong miền raster. Trong các đoạn tiếp theo, chúng tôi giải thích biểu diễn tensor, bộ khử nhiễu, huấn luyện và suy luận của giai đoạn này.

Tensor mục tiêu. Tensor mục tiêu y0 là một tensor M×D (Hình 4), trong đó M đại diện cho một giới hạn trên của tổng số điểm điều khiển mà một ký tự có thể có. Mỗi mục trong tensor chứa một biểu diễn D chiều của một điểm điều khiển. Cụ thể, mỗi mục lưu trữ thông tin sau:

(a) chỉ số của đường dẫn vector mà điểm điều khiển thuộc về tức là, thành viên đường dẫn của nó. Trong quá trình huấn luyện, mỗi đường dẫn vector được gán một chỉ số duy nhất. Vì các đường dẫn vector có thể được sắp xếp lại một cách tùy ý mà không thay đổi ký tự kết quả, để giảm tính biến đổi không cần thiết trong quá trình học, chúng tôi sắp xếp các đường dẫn vector theo thứ tự từ điển bằng cách sử dụng tọa độ của điểm điều khiển gần nhất với góc trên bên trái của hình ảnh raster ký tự làm khóa sắp xếp. Theo [8], chỉ số đường dẫn được sắp xếp kết quả được chuyển đổi thành bit nhị phân. Đối với mỗi mục điểm điều khiển, chúng tôi lưu trữ các bit nhị phân của đường dẫn vector của nó. Một mục null (tức là, tất cả bit một) được dành riêng cho các mục không tạo ra điểm điều khiển - theo cách này, chúng tôi mô hình hóa phông chữ vector với số lượng điểm điều khiển và đường dẫn khác nhau.

(b) chỉ số của ô lưới chứa điểm điều khiển. Chúng tôi định nghĩa một lưới thô P×P trên hình ảnh, với P2 tâm ô lưới tương ứng. Chúng tôi gán mỗi điểm điều khiển cho ô lưới có tâm gần nhất. Trong trường hợp điểm điều khiển nằm trên ranh giới của hai ô, chúng tôi sử dụng phép toán làm tròn gán nó vào ô thứ hai. Tương tự như thành viên đường dẫn, chỉ số ô lưới được chuyển đổi thành bit nhị phân. Đối với mỗi mục điểm điều khiển, chúng tôi lưu trữ các bit nhị phân của ô lưới được gán của nó.

(c) tọa độ liên tục của điểm điều khiển được biểu thị tương đối so với tâm của ô lưới mà nó thuộc về. Đây là hai giá trị liên tục nắm bắt vị trí của mỗi điểm điều khiển. Chúng tôi thấy rằng việc nắm bắt vị trí điểm điều khiển tương đối so với tâm ô đạt được hiệu suất tốt nhất. Vì trường điểm điều khiển raster được tạo ra (xấp xỉ) làm nổi bật các vùng lưu trữ điểm điều khiển, việc ánh xạ trường điểm điều khiển thành các chỉ số ô rời rạc cộng với các phần dư liên tục nhỏ, hoặc độ dịch chuyển, là một nhiệm vụ dễ dàng hơn và giảm tính biến đổi tọa độ liên tục cần được nắm bắt bởi mô hình.

Khử nhiễu. Bộ khử nhiễu cho giai đoạn này được hình thành như một transformer chỉ encoder [10], lấy tensor yt làm đầu vào và được điều kiện hóa trên embedding của bước thời gian t, và hình ảnh raster được tạo ra x0 từ mô hình khuếch tán raster. Chúng tôi sử dụng một ConvNet để mã hóa hình ảnh raster x0 thành các đặc trưng nhiều chiều, được đưa vào transformer thông qua cross-attention tương tự như [41]. Transformer dự đoán nội dung nhiễu dưới dạng một tensor M×D tại mỗi bước.

Loss huấn luyện. Chúng tôi huấn luyện mạng khử nhiễu theo loss lỗi bình phương trung bình giữa nhiễu huấn luyện và nhiễu dự đoán tại các bước thời gian được lấy mẫu: ||ε(yt, x0, t) − ε||2.

Suy luận. Tại thời điểm kiểm tra, với một tensor được lấy mẫu yT từ nhiễu Gaussian đơn vị và một hình ảnh raster được tạo ra x0 của giai đoạn trước, mạng khử nhiễu được áp dụng trong một loạt T bước để tạo ra tensor mục tiêu y0. Theo phương pháp Analog Bits [8], các bit nhị phân rời rạc trong biểu diễn tensor mục tiêu được mô hình hóa như các số thực. Chúng chỉ đơn giản được ngưỡng hóa để có được các bit nhị phân cuối cùng tại thời điểm suy luận. Với thành viên đường dẫn được dự đoán, chúng tôi tạo ra một tập hợp các đường dẫn vector theo số chỉ số đường dẫn điều khiển lớn nhất được tạo ra. Mỗi mục không null trong tensor được tạo ra tạo ra một điểm điều khiển. Các điểm điều khiển được sắp xếp ngầm dựa trên chỉ số mục của chúng. Vị trí của điểm điều khiển được định nghĩa là tọa độ tâm của ô được gán trong tensor được tạo ra cộng với độ dịch chuyển tương đối được dự đoán. Với thông tin được tạo ra này, chúng tôi trực tiếp tái tạo các đường dẫn vector mà không cần bất kỳ tinh chỉnh hoặc xử lý hậu kỳ nào nữa.

Chi tiết implementation. Trong implementation của chúng tôi, chúng tôi đặt giới hạn trên cho số lượng điểm điều khiển thành M = 256, đủ cho các tập dữ liệu mà chúng tôi thử nghiệm. Chúng tôi sử dụng 3 bit để biểu diễn thành viên đường dẫn, có thể hỗ trợ tới 7 đường dẫn vector riêng biệt. Điều này cũng đủ cho các tập dữ liệu trong các thí nghiệm của chúng tôi. Chúng tôi đặt P thành 16, dẫn đến 256 ô lưới có thể được biểu diễn bằng 8 bit nhị phân. Cùng với độ dịch chuyển tương đối hai chiều, chiều cuối cùng của tensor mục tiêu D là 13 trong các thí nghiệm của chúng tôi. Tương tự như mô hình khuếch tán raster của chúng tôi, chúng tôi đặt số bước khuếch tán T thành 1000, sử dụng lịch trình nhiễu cosine, và optimizer AdamW [32] với tốc độ học 3.24·10−5. Huấn luyện được thực hiện riêng biệt từ giai đoạn khuếch tán raster và mất 5 ngày trên 8 GPU A100. Trong quá trình kiểm tra, chúng tôi sử dụng bộ lấy mẫu DDPM [15] với 1000 bước. Tạo ra một ký tự bằng cách thực thi cả hai giai đoạn mất khoảng 10 giây trên một GPU A100.

4. Kết quả
Trong phần này, chúng tôi trình bày các thí nghiệm trong ba kịch bản ứng dụng khác nhau cho phương pháp của chúng tôi. Trong kịch bản đầu tiên, chúng tôi giải quyết vấn đề tạo ký tự thiếu cho một phông chữ (Phần 4.1). Nhiều người dùng thường gặp tình huống khó chịu khi họ chọn một phông chữ họ thích, chỉ để phát hiện ra rằng nó thiếu một số ký tự hoặc ký hiệu mà họ muốn sử dụng. Vấn đề này đặc biệt phổ biến khi nói đến các ký tự không phải Latin và ký hiệu toán học. Như một ứng dụng thứ hai, chúng tôi áp dụng phương pháp của mình cho chuyển đổi phong cách phông chữ với ít mẫu (Phần 4.2), trong đó phông chữ mong muốn được chỉ định dưới dạng một vài ký tự raster mẫu, và mục tiêu là tạo ra các ký tự vector trong cùng phông chữ. Cuối cùng, chúng tôi thảo luận về nội suy phong cách phông chữ (Phần 4.3) tức là, tạo ra các ký tự có phong cách nằm giữa hai phông chữ đã cho.

4.1. Tạo ký tự Unicode thiếu
Các tập dữ liệu công khai hoặc benchmark hiện có để đánh giá tạo ký tự bị giới hạn trong một bảng chữ cái cụ thể (ví dụ, Latin). Dưới đây chúng tôi thảo luận về một tập dữ liệu mới để đánh giá tạo ký tự trên các ngôn ngữ khác nhau, ký hiệu toán học và các dấu hiệu khác phổ biến trong tiêu chuẩn Unicode. Sau đó chúng tôi thảo luận về so sánh, nghiên cứu loại bỏ, số liệu để đánh giá và kết quả.

Tập dữ liệu. Chúng tôi thu thập một tập dữ liệu mới gồm 1424 phông chữ từ Google Fonts. Tập dữ liệu chứa 324K ký tự, bao gồm 577 ký tự Unicode riêng biệt trong nhiều ngôn ngữ khác nhau (ví dụ, Hy Lạp, Cyrillic, Devanagari), ký hiệu toán học và các dấu hiệu khác (ví dụ mũi tên, dấu ngoặc, tiền tệ). Chúng tôi phân chia ngẫu nhiên tập dữ liệu thành 314K-5K-5K ký tự cho huấn luyện, validation và kiểm tra tương ứng.

So sánh. Chúng tôi so sánh với "ChiroDiff" [9], áp dụng các mô hình khuếch tán để tạo ra các ký tự Kanji dưới dạng polyline. Phương pháp của họ sử dụng một set-transformer [24] để có được một embedding tiềm ẩn từ một tập điểm 2D làm điều kiện đầu vào. Chúng tôi thay thế điều kiện đầu vào của họ cho mô hình khuếch tán của họ bằng các embedding của ký tự và phông chữ sử dụng bảng tra cứu, như được thực hiện trong mô hình khuếch tán raster của chúng tôi. Chúng tôi đã huấn luyện và điều chỉnh phương pháp của họ, bao gồm các embedding, để dự đoán các điểm điều khiển đường cong Bézier sử dụng tập dữ liệu của chúng tôi, như trong phương pháp của chúng tôi.

Loại bỏ. Ngoài ra, chúng tôi đánh giá các biến thể thay thế sau của phương pháp chúng tôi: (a) Chỉ vector: trong nghiên cứu loại bỏ này, chúng tôi loại bỏ mô hình khuếch tán raster và chỉ sử dụng mô hình khuếch tán vector - trong trường hợp này, các embedding phông chữ và ký tự được sử dụng làm điều kiện đầu vào cho mô hình khuếch tán vector. (b) Không có trường điểm điều khiển: chúng tôi loại bỏ trường điểm điều khiển RGB khỏi hình ảnh raster mục tiêu của mô hình khuếch tán raster của chúng tôi - trong trường hợp này, chúng tôi điều kiện hóa mô hình khuếch tán vector chỉ trên hình ảnh raster một kênh của ký tự. (c) Chỉ dự đoán tọa độ liên tục: trong mô hình khuếch tán vector, thay vì dự đoán các chỉ số ô lưới rời rạc cộng với độ dịch chuyển tương đối so với tâm ô, chúng tôi trực tiếp dự đoán tọa độ tuyệt đối x và y cho mỗi điểm điều khiển.

Số liệu đánh giá. Chúng tôi so sánh các ký tự được tạo ra với những ký tự được thiết kế bởi nghệ sĩ trong phần tách kiểm tra. Chúng tôi sử dụng các số liệu sau:

(a) L1: chúng tôi so sánh sự khác biệt pixel tuyệt đối trong không gian hình ảnh của các ký tự khi được raster hóa. Chúng tôi sử dụng cùng một rasterizer cho tất cả các phương pháp và biến thể cạnh tranh. Lỗi tái tạo này cũng được đề xuất trong [50] để đánh giá ký tự.

(b) CD: chúng tôi đo khoảng cách Chamfer hai chiều giữa các điểm điều khiển được chỉ định bởi nghệ sĩ và những điểm được tạo ra.

(c) #cp diff: chúng tôi đo sự khác biệt giữa số lượng điểm điều khiển do nghệ sĩ tạo ra và số được dự đoán, lấy trung bình trên tất cả các đường dẫn.

(d) #vp diff: chúng tôi đo sự khác biệt giữa số lượng đường dẫn vector được chỉ định bởi nghệ sĩ và số được dự đoán.

Đối với tất cả các thước đo trên, chúng tôi báo cáo giá trị trung bình trên phần tách kiểm tra của chúng tôi. Chúng tôi đề xuất ba số liệu cuối cùng để so sánh các ký tự về đặc điểm điểm điều khiển và đường dẫn, có liên quan hơn trong thiết kế phông chữ vector.

Kết quả định lượng. Bảng 1 cho thấy kết quả định lượng cho ChiroDiff và các biến thể thay thế của phương pháp chúng tôi trên tập kiểm tra đầy đủ. Phiên bản đầy đủ của phương pháp chúng tôi vượt trội hơn ChiroDiff và các biến thể rút gọn của chúng tôi trên tất cả các số liệu đánh giá. Chúng tôi lưu ý rằng một ký tự trong một biến thể họ ví dụ, chữ nghiêng có thể có một biến thể khác trong cùng phông chữ, ví dụ, in đậm. Mặc dù hai biến thể họ khác nhau của cùng một ký tự thường có vị trí và phân phối điểm điều khiển khác nhau rất nhiều, chúng tôi tạo ra một tập con thách thức hơn nữa của tập kiểm tra nơi chúng tôi loại bỏ tất cả các ký tự kiểm tra có biến thể họ khác trong cùng phông chữ trong tập huấn luyện. Kết quả trên tập con này được báo cáo trong Bảng 2. Chirodiff và các biến thể khác vẫn có lỗi cao hơn nhiều so với của chúng tôi. Điều này cho thấy rằng phương pháp hai giai đoạn của chúng tôi, và biểu diễn hỗn hợp rời rạc-liên tục của các đường dẫn vector cùng với các trường điểm điều khiển đều quan trọng để đạt được hiệu suất cao.

Kết quả định tính. Hình 6 cho thấy so sánh định tính cho tạo ký tự thiếu. So với phương pháp của chúng tôi, chúng tôi quan sát thấy rằng ChiroDiff tạo ra các điểm điều khiển và cấu trúc đường cong không chính xác, dẫn đến méo mó đáng kể và tạo tác trong các ký tự được tổng hợp. Chúng tôi cũng quan sát thấy kết quả giảm sút trong tất cả các biến thể thay thế của phương pháp chúng tôi về điểm điều khiển bị đặt sai hoặc bị bỏ qua. Kết quả bổ sung cũng có trong phần bổ sung. Hình 1,5 cho thấy kết quả bổ sung của tạo ký tự thiếu cho phương pháp của chúng tôi trên tập dữ liệu Google Font cho nhiều phông chữ và ký tự mục tiêu khác nhau. Hình 7 minh họa nhiều mẫu được tạo ra bởi pipeline khuếch tán của chúng tôi với các hạt giống ngẫu nhiên. Các mẫu tuân thủ cùng phong cách phông chữ, trong khi có sự biến đổi tinh tế trong tỷ lệ ký tự và phân phối điểm điều khiển. Từ góc độ thực tế, một nhà thiết kế có thể khám phá nhiều mẫu như vậy, và chọn biến thể được ưa thích nhất.

Trong phần bổ sung, thay vì sử dụng mô hình khuếch tán vector, chúng tôi sử dụng các phương pháp vector hóa có sẵn trên hình ảnh ký tự raster được tạo ra bởi giai đoạn khuếch tán raster. Như được thể hiện trong so sánh, phương pháp này thường không thể tạo ra tôpô và cấu trúc đường cong gắn kết.

4.2. Chuyển đổi phong cách phông chữ với ít mẫu
Đối với ứng dụng này, chúng tôi so sánh với DeepVecFont-v2 [51] và DualVector [30], cả hai đều đã chứng minh chuyển đổi phong cách phông chữ với ít mẫu trước đây. Để thực hiện so sánh, chúng tôi sử dụng tập dữ liệu được đề xuất trong bài báo DeepVecFont-v2. Tập dữ liệu bao gồm 52 ký tự Latin viết thường và viết hoa trong nhiều phong cách phông chữ khác nhau - có tổng cộng 8.035 phông chữ huấn luyện và 1.425 phông chữ kiểm tra. Mỗi trường hợp kiểm tra chứa 4 ký tự tham chiếu từ một phông chữ mới (không được quan sát trong quá trình huấn luyện). Các ký tự tham chiếu có sẵn ở cả định dạng vector và raster. Các phương pháp được cho là chuyển đổi phong cách phông chữ mới này sang các ký tự kiểm tra. Chúng tôi lưu ý rằng DeepVecFont-v2 yêu cầu biểu diễn vector của các ký tự tham chiếu làm điều kiện đầu vào bổ sung, trong khi DualVector và phương pháp của chúng tôi chỉ sử dụng các hình ảnh tham chiếu raster.

Kết quả định lượng. Bảng 3 cho thấy so sánh số dựa trên cùng các số liệu đánh giá như trong ứng dụng tạo ký tự thiếu. Phương pháp của chúng tôi vượt trội hơn DeepVecFont-v2 và DualVector trên tất cả các số liệu.

Kết quả định tính. Hình 8 minh họa kết quả chuyển đổi phong cách phông chữ. Chúng tôi quan sát thấy rằng cả DeepVecFont-v2 đều có xu hướng thành công trong việc nắm bắt phong cách phông chữ của các ký tự tham chiếu, tuy nhiên vẫn thường tạo ra méo mó tinh tế trong các đường dẫn vector. Phương pháp của chúng tôi tạo ra kết quả phù hợp với phong cách của các ký tự tham chiếu với ít tạo tác hơn, ngay cả trong các phong cách thách thức. Kết quả bổ sung có trong Hình 1 và trong phần bổ sung.

4.3. Nội suy phong cách phông chữ
Cuối cùng, chúng tôi thử nghiệm với việc nội suy hai phong cách phông chữ đã cho. Để thực hiện nội suy, đầu tiên chúng tôi có được các embedding phông chữ từ bảng tra cứu đã huấn luyện của chúng tôi, sau đó thực hiện nội suy tuyến tính của các embedding này. Mô hình khuếch tán của chúng tôi sau đó được điều kiện hóa trên vector embedding được nội suy cho phong cách phông chữ. Chúng tôi minh họa kết quả định tính trong Hình 9. Kết quả của chúng tôi nội suy mượt mà các thuộc tính nghệ thuật của phông chữ nguồn và mục tiêu, chẳng hạn như độ rộng nét biến đổi và độ cong cục bộ, trong khi bảo tồn các thuộc tính cấu trúc và tôpô của các ký tự ví dụ như genus của chúng.

5. Kết luận
Chúng tôi đã trình bày một mô hình tạo sinh của phông chữ vector. Chúng tôi cho thấy rằng một cascade của một mô hình khuếch tán raster và vector có thể vượt qua những thách thức của dự đoán đường cong tham số mạng nơ-ron, và tạo ra phông chữ vector có thể chỉnh sửa với hình học chính xác và vị trí điểm điều khiển.

Hạn chế. Chúng tôi yêu cầu các đường dẫn vector làm giám sát và không thể tận dụng lợi thế của các hình ảnh raster làm giám sát bổ sung có thể có sẵn. Một hạn chế khác được hiển thị trong Hình 10. Cinzel là một phông chữ viết hoa. Đối với ký tự thiếu ₫ (dong), một ký tự viết thường, phương pháp của chúng tôi "ảo tưởng" một ký tự viết hoa. Trong khi ký tự được tạo ra bảo tồn phong cách của phông chữ và cấu trúc của ký tự (nét vẽ), nó không bảo tồn ý nghĩa tượng trưng của ký tự.

Công việc tương lai. Các mô hình tạo sinh của hình ảnh trong miền raster đã được sử dụng thành công để học các prior phức tạp về thế giới thị giác có thể được sử dụng trong nhiều nhiệm vụ khác nhau như inpainting và các nhiệm vụ 3D. Chúng tôi tin rằng một mô hình tạo sinh cho đồ họa vector nói chung có thể có một số ứng dụng downstream, chẳng hạn như tạo ra và hoàn thiện tự động của logo, biểu tượng, bản vẽ đường và hình minh họa [20, 28, 29], hoặc được mở rộng để tạo ra các đường cong và bề mặt tham số 3D [43].

Lời cảm ơn. Dự án của chúng tôi được tài trợ bởi Adobe Research.
