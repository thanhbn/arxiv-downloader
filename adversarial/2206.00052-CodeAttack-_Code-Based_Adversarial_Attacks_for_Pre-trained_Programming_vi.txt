# 2206.00052.pdf
# Đã chuyển đổi từ PDF sang TXT
# Đường dẫn nguồn: /home/admin88/arxiv-downloader/adversarial/2206.00052.pdf
# Kích thước tệp: 1279911 bytes

===============================================
NỘI DUNG TỆP PDF
===============================================


--- TRANG 1 ---
CodeAttack: Tấn công đối kháng dựa trên mã cho các mô hình ngôn ngữ lập trình được tiền huấn luyện
Akshita Jha và Chandan K. Reddy
Khoa Khoa học Máy tính, Virginia Tech, Arlington VA - 22203.
akshitajha@vt.edu, reddy@cs.vt.edu
Tóm tắt
Các mô hình ngôn ngữ lập trình (PL) được tiền huấn luyện (như CodeT5, CodeBERT, GraphCodeBERT, v.v.) có tiềm năng tự động hóa các tác vụ kỹ thuật phần mềm liên quan đến hiểu mã và tạo mã. Tuy nhiên, các mô hình này hoạt động trong kênh tự nhiên của mã, tức là chúng chủ yếu quan tâm đến khả năng hiểu mã của con người. Chúng không bền vững trước những thay đổi trong đầu vào và do đó, có khả năng dễ bị tấn công đối kháng trong kênh tự nhiên. Chúng tôi đề xuất CodeAttack, một mô hình tấn công hộp đen đơn giản nhưng hiệu quả sử dụng cấu trúc mã để tạo ra các mẫu mã đối kháng hiệu quả, hiệu suất và khó phát hiện, đồng thời chứng minh các lỗ hổng của các mô hình PL tiên tiến trong việc tấn công đối kháng đặc thù cho mã. Chúng tôi đánh giá khả năng chuyển giao của CodeAttack trên nhiều tác vụ mã-mã (dịch và sửa chữa) và mã-NL (tóm tắt) qua các ngôn ngữ lập trình khác nhau. CodeAttack vượt trội so với các mô hình tấn công NLP đối kháng tiên tiến để đạt được sự sụt giảm hiệu suất tổng thể tốt nhất trong khi hiệu quả hơn, khó phát hiện hơn, nhất quán hơn và trôi chảy hơn. Mã nguồn có thể tìm thấy tại https://github.com/reddy-lab-code-research/CodeAttack.

Giới thiệu
Gần đây đã có sự gia tăng mạnh trong việc phát triển các mô hình ngôn ngữ lập trình (PL) đa năng (Ahmad et al. 2021; Feng et al. 2020; Guo et al. 2020; Tipirneni, Zhu, và Reddy 2022; Wang et al. 2021). Chúng có thể nắm bắt mối quan hệ giữa ngôn ngữ tự nhiên và mã nguồn, và có tiềm năng tự động hóa các tác vụ phát triển kỹ thuật phần mềm liên quan đến hiểu mã (phát hiện bản sao, phát hiện lỗi) và tạo mã (dịch mã-mã, tinh chỉnh mã-mã, tóm tắt mã-NL). Tuy nhiên, việc tiền huấn luyện dựa trên dữ liệu của các mô hình trên với lượng lớn dữ liệu mã hạn chế chúng chủ yếu hoạt động trong 'kênh tự nhiên' của mã (Chakraborty et al. 2022; Hindle et al. 2016; Zhang et al. 2022). 'Kênh tự nhiên' này tập trung vào việc truyền đạt thông tin cho con người thông qua các chú thích mã, tên biến có ý nghĩa và tên hàm (Casalnuovo et al. 2020). Trong tình huống như vậy, tính bền vững và lỗ hổng của các mô hình được tiền huấn luyện cần được điều tra cẩn thận. Trong công trình này, chúng tôi tận dụng cấu trúc mã để tạo ra các mẫu đối kháng trong kênh tự nhiên của mã và chứng minh lỗ hổng của các mô hình ngôn ngữ lập trình tiên tiến trong việc tấn công đối kháng.

Bản quyền © 2023, Hiệp hội Thúc đẩy Trí tuệ Nhân tạo (www.aaai.org). Tất cả quyền được bảo lưu.

Hình 1: CodeAttack thực hiện một thay đổi nhỏ đối với đoạn mã đầu vào (màu đỏ) khiến cho việc tóm tắt mã thu được từ các mô hình ngôn ngữ lập trình được tiền huấn luyện SOTA thay đổi đáng kể. Từ khóa được tô sáng màu xanh lam và chú thích màu xanh lá cây.

Các tấn công đối kháng được đặc trưng bởi những thay đổi khó phát hiện trong đầu vào dẫn đến dự đoán sai từ mô hình học máy. Đối với các mô hình PL được tiền huấn luyện hoạt động trong kênh tự nhiên, những tấn công như vậy quan trọng vì hai lý do chính: (i) Phơi bày lỗ hổng hệ thống và đánh giá tính bền vững của mô hình: Một thay đổi nhỏ trong ngôn ngữ lập trình đầu vào (tương tự như lỗi chính tả trong tình huống NL) có thể khiến mô hình tóm tắt mã tạo ra bản tóm tắt mã ngôn ngữ tự nhiên vô nghĩa (Hình 1), và (ii) Khả năng diễn giải mô hình: Các mẫu đối kháng có thể được sử dụng để kiểm tra các token mà các mô hình PL được tiền huấn luyện chú ý đến.

Một cuộc tấn công đối kháng thành công trong kênh tự nhiên cho mã nên có các thuộc tính sau: (i) Nhiễu loạn tối thiểu: Tương tự như lỗi chính tả hoặc thay thế từ đồng nghĩa trong NL làm mislead các mô hình neural với những thay đổi khó phát hiện, (ii) Tính nhất quán của mã: Mã bị nhiễu loạn nhất quán với đầu vào gốc và tuân theo cùng phong cách mã hóa như mã gốc, và (iii) Tính trôi chảy của mã: Không làm thay đổi khả năng hiểu mã ở cấp độ người dùng của mã gốc. Các mô hình tấn công đối kháng ngôn ngữ tự nhiên hiện tại không đáp ứng được cả ba mặt trận. Do đó, chúng tôi đề xuất CodeAttack – một mô hình tấn công hộp đen đơn giản nhưng hiệu quả để tạo ra các mẫu đối kháng trong kênh tự nhiên cho bất kỳ đoạn mã đầu vào nào, bất kể ngôn ngữ lập trình.

CodeAttack hoạt động trong tình huống thực tế, nơi kẻ tấn công không có quyền truy cập vào các tham số mô hình mà chỉ có quyền truy cập vào các truy vấn thử nghiệm và dự đoán của mô hình. CodeAttack sử dụng mô hình CodeBERT được tiền huấn luyện và che dấu (Feng et al. 2020) làm bộ tạo mã đối kháng để tạo ra các ví dụ đối kháng khó phát hiện và hiệu quả bằng cách tận dụng cấu trúc mã. Các đóng góp chính của chúng tôi như sau:

• Theo hiểu biết tốt nhất của chúng tôi, công trình của chúng tôi là công trình đầu tiên phát hiện các lỗ hổng của các mô hình ngôn ngữ lập trình được tiền huấn luyện trong việc tấn công đối kháng trong kênh tự nhiên của mã. Chúng tôi đề xuất một phương pháp tấn công hộp đen thực tế đơn giản nhưng hiệu quả, CodeAttack, tạo ra các mẫu đối kháng cho một đoạn mã bất kể ngôn ngữ lập trình đầu vào.

• Chúng tôi thiết kế một phương pháp tấn công hộp đen đa năng cho các mô hình PL chuỗi-đến-chuỗi có thể chuyển giao qua các tác vụ downstream khác nhau như dịch mã, sửa chữa và tóm tắt. Bản chất không phụ thuộc ngôn ngữ đầu vào của phương pháp chúng tôi cũng làm cho nó có thể mở rộng cho các tác vụ chuỗi-đến-chuỗi trong các lĩnh vực khác.

• Chúng tôi chứng minh hiệu quả của CodeAttack so với các mô hình đối kháng NLP hiện có thông qua đánh giá thực nghiệm rộng rãi. CodeAttack vượt trội so với các baseline ngôn ngữ tự nhiên khi xem xét cả chất lượng tấn công và hiệu quả của nó.

--- TRANG 2 ---
CodeAttack hoạt động trong tình huống thực tế, nơi kẻ tấn công không có quyền truy cập vào các tham số mô hình mà chỉ có quyền truy cập vào các truy vấn thử nghiệm và dự đoán của mô hình. CodeAttack sử dụng mô hình CodeBERT được tiền huấn luyện và che dấu (Feng et al. 2020) làm bộ tạo mã đối kháng để tạo ra các ví dụ đối kháng khó phát hiện và hiệu quả bằng cách tận dụng cấu trúc mã. Các đóng góp chính của chúng tôi như sau:

• Theo hiểu biết tốt nhất của chúng tôi, công trình của chúng tôi là công trình đầu tiên phát hiện các lỗ hổng của các mô hình ngôn ngữ lập trình được tiền huấn luyện trong việc tấn công đối kháng trong kênh tự nhiên của mã. Chúng tôi đề xuất một phương pháp tấn công hộp đen thực tế đơn giản nhưng hiệu quả, CodeAttack, tạo ra các mẫu đối kháng cho một đoạn mã bất kể ngôn ngữ lập trình đầu vào.

• Chúng tôi thiết kế một phương pháp tấn công hộp đen đa năng cho các mô hình PL chuỗi-đến-chuỗi có thể chuyển giao qua các tác vụ downstream khác nhau như dịch mã, sửa chữa và tóm tắt. Bản chất không phụ thuộc ngôn ngữ đầu vào của phương pháp chúng tôi cũng làm cho nó có thể mở rộng cho các tác vụ chuỗi-đến-chuỗi trong các lĩnh vực khác.

• Chúng tôi chứng minh hiệu quả của CodeAttack so với các mô hình đối kháng NLP hiện có thông qua đánh giá thực nghiệm rộng rãi. CodeAttack vượt trội so với các baseline ngôn ngữ tự nhiên khi xem xét cả chất lượng tấn công và hiệu quả của nó.

Bối cảnh và Công trình liên quan
Kênh đôi của Mã nguồn. Casalnuovo et al. (2020) đề xuất góc nhìn kênh đôi của mã: (i) chính thức, và (ii) tự nhiên. Kênh chính thức chính xác và được sử dụng để thực thi mã bởi các trình biên dịch và trình thông dịch. Mặt khác, kênh ngôn ngữ tự nhiên dành cho sự hiểu biết của con người và có nhiễu. Nó dựa vào các chú thích mã, tên biến, tên hàm, v.v., để dễ dàng hiểu biết của con người. Các mô hình PL tiên tiến hoạt động chủ yếu trong kênh tự nhiên của mã (Zhang et al. 2022) và do đó, chúng tôi tạo ra các mẫu đối kháng bằng cách sử dụng kênh tự nhiên này.

Tấn công đối kháng trong NLP. BERT-Attack (Li et al. 2020) và BAE (Garg và Ramakrishnan 2020) sử dụng BERT để tấn công các từ dễ bị tổn thương. TextFooler (Jin et al. 2020) và PWWS (Ren et al. 2019) sử dụng từ đồng nghĩa và gắn thẻ từ loại (POS) để thay thế các token quan trọng. Deepwordbug (Gao et al. 2018) và TextBugger (Li et al. 2019) sử dụng chiến lược chèn, xóa và thay thế ký tự cho các cuộc tấn công trong khi Hsieh et al. (2019) và Yang et al. (2020) sử dụng chiến lược tìm kiếm tham lam và thay thế. Alzantot et al. (2018) sử dụng thuật toán di truyền và Ebrahimi et al. (2018), Papernot et al. (2016), và Pruthi, Dhingra, và Lipton (2019) sử dụng gradient mô hình để tìm các từ thay thế. Không có phương pháp nào trong số này được thiết kế đặc biệt cho các ngôn ngữ lập trình, có cấu trúc hơn ngôn ngữ tự nhiên.

Tấn công đối kháng cho PL. Zhang et al. (2020) tạo ra các ví dụ đối kháng bằng cách đổi tên các định danh sử dụng lấy mẫu Metropolis-Hastings (Metropolis et al. 1953). Yang et al. (2022) cải thiện điều đó bằng cách sử dụng thuật toán tham lam và di truyền. Yefet, Alon, và Yahav (2020) sử dụng khám phá dựa trên gradient; trong khi Applis, Panichella, và van Deursen (2021) và (Henkel et al. 2022) đề xuất các biến đổi metamorphic cho các cuộc tấn công. Các mô hình trên tập trung vào các tác vụ phân loại như phát hiện lỗi và phát hiện bản sao. Mặc dù một số công trình tập trung vào các ví dụ đối kháng cho tóm tắt mã (Henkel et al. 2022; Zhou et al. 2022), chúng không làm như vậy trong kênh tự nhiên. Chúng cũng không kiểm tra khả năng chuyển giao sang các tác vụ, mô hình PL và ngôn ngữ lập trình khác nhau. Mô hình của chúng tôi, CodeAttack, giả định quyền truy cập hộp đen vào các mô hình PL tiên tiến để tạo ra các cuộc tấn công đối kháng cho các tác vụ tạo mã như dịch mã, sửa mã và tóm tắt mã sử dụng thuật toán tham lam đặc thù cho mã bị ràng buộc để tìm các từ thay thế có ý nghĩa cho các token dễ bị tổn thương, bất kể ngôn ngữ lập trình đầu vào.

CodeAttack
Chúng tôi mô tả các khả năng, kiến thức và mục tiêu của mô hình được đề xuất, và cung cấp chi tiết về cách nó phát hiện lỗ hổng trong các mô hình PL được tiền huấn luyện tiên tiến.

Mô hình Mối đe dọa
Khả năng của Kẻ tấn công. Kẻ tấn công có khả năng nhiễu loạn các truy vấn thử nghiệm được đưa làm đầu vào cho mô hình PL được tiền huấn luyện để tạo ra các mẫu đối kháng. Chúng tôi tuân theo tài liệu hiện có để tạo ra các ví dụ đối kháng ngôn ngữ tự nhiên và cho phép hai loại nhiễu loạn cho chuỗi mã đầu vào trong kênh tự nhiên: (i) nhiễu loạn cấp độ ký tự, và (ii) nhiễu loạn cấp độ token. Kẻ tấn công được phép nhiễu loạn chỉ một số lượng nhất định token/ký tự và phải đảm bảo độ tương tự cao giữa mã gốc và mã bị nhiễu loạn. Một cách chính thức, đối với chuỗi mã đầu vào X ∈ X, trong đó X là không gian đầu vào, một ví dụ mã đối kháng hợp lệ Xadv thỏa mãn các yêu cầu:

X ≠ Xadv (1)
Xadv ∈ X + δ; s.t. ||δ|| < ε (2)
Sim(Xadv,X) ≥ θ (3)

trong đó ε là nhiễu loạn tối đa được phép; Sim() là hàm tương tự; và θ là ngưỡng tương tự.

Kiến thức của Kẻ tấn công. Chúng tôi giả định quyền truy cập hộp đen tiêu chuẩn để đánh giá thực tế các lỗ hổng và tính bền vững của các mô hình PL được tiền huấn luyện hiện có. Kẻ tấn công không có quyền truy cập vào các tham số mô hình, kiến trúc mô hình, gradient mô hình, dữ liệu huấn luyện hoặc hàm mất mát. Nó chỉ có thể truy vấn mô hình PL được tiền huấn luyện với các chuỗi đầu vào và nhận các xác suất đầu ra tương ứng của chúng. Điều này thực tế hơn tình huống hộp trắng nơi kẻ tấn công giả định quyền truy cập vào tất cả những điều trên.

Mục tiêu của Kẻ tấn công. Với chuỗi mã đầu vào làm truy vấn, mục tiêu của kẻ tấn công là làm suy giảm chất lượng của chuỗi đầu ra được tạo ra thông qua việc sửa đổi truy vấn một cách khó phát hiện trong kênh tự nhiên của mã. Chuỗi đầu ra được tạo ra có thể là một đoạn mã (dịch mã, sửa mã) hoặc văn bản ngôn ngữ tự nhiên (tóm tắt mã). Một cách chính thức, với mô hình PL được tiền huấn luyện F : X → Y, trong đó X là không gian đầu vào, và Y là không gian đầu ra, mục tiêu của

--- TRANG 3 ---
kẻ tấn công là tạo ra một mẫu đối kháng Xadv cho chuỗi đầu vào X sao cho

F(Xadv) ≠ F(X) (4)
Q(F(X)) - Q(F(Xadv)) ≥ β (5)

trong đó Q() đo chất lượng của đầu ra được tạo ra và β là mức sụt giảm chất lượng được chỉ định. Điều này là bổ sung cho các ràng buộc được áp dụng trước đó trên Xadv. Chúng tôi hình thức hóa vấn đề cuối cùng của việc tạo ra các mẫu đối kháng như sau:

δ_atk = argmax[Q(F(X)) - Q(F(Xadv))] (6)

Trong hàm mục tiêu trên, Xadv là một kẻ tấn công bị nhiễu loạn tối thiểu tuân theo các ràng buộc về nhiễu loạn (Phương trình 1-5). CodeAttack tìm kiếm nhiễu loạn δ_atk để tối đa hóa sự khác biệt trong chất lượng Q() của chuỗi đầu ra được tạo ra từ đoạn mã đầu vào gốc X và chuỗi từ đoạn mã bị nhiễu loạn Xadv.

Phương pháp Tấn công
Có hai bước chính: (i) Tìm các token dễ bị tổn thương nhất, và (ii) Thay thế các token dễ bị tổn thương này (tuân theo các ràng buộc đặc thù cho mã), để tạo ra các mẫu đối kháng trong kênh tự nhiên của mã.

Tìm Token Dễ bị tổn thương CodeBERT chú ý nhiều hơn đến từ khóa và định danh khi đưa ra dự đoán (Zhang et al. 2022). Chúng tôi tận dụng thông tin này và đưa ra giả thuyết rằng các token đầu vào nhất định đóng góp nhiều hơn cho dự đoán cuối cùng so với các token khác. 'Tấn công' những token có ảnh hưởng cao hoặc dễ bị tổn thương cao này tăng xác suất thay đổi dự đoán của mô hình đáng kể so với việc tấn công các token không dễ bị tổn thương. Trong thiết lập hộp đen, gradient mô hình không có sẵn và kẻ tấn công chỉ có quyền truy cập vào logit đầu ra của mô hình PL được tiền huấn luyện. Chúng tôi định nghĩa 'token dễ bị tổn thương' là các token có ảnh hưởng cao đến logit đầu ra của mô hình. Gọi F là mô hình PL encoder-decoder được tiền huấn luyện. Chuỗi đầu vào cho trước được biểu thị bởi X = [x1, ..., xi, ..., xm], trong đó {xi}^m_1 là các token đầu vào. Đầu ra là một chuỗi các vector: O = F(X) = [o1, ..., on]; yt = argmax(ot); trong đó {ot}^n_1 là logit đầu ra cho token đầu ra đúng yt cho thời điểm t. Không mất tính tổng quát, chúng ta cũng có thể giả định chuỗi đầu ra Y = F(X) = [yi, ..., yl]. Y có thể là chuỗi mã hoặc token ngôn ngữ tự nhiên.

Để tìm các token đầu vào dễ bị tổn thương, chúng tôi thay thế token xi bằng [MASK] sao cho X\xi = [x1, ..., xi-1, [MASK], xi+1, ..., xm] và nhận logit đầu ra của nó. Các vector đầu ra bây giờ là O\xi = F(X\xi) = [o'1, ..., o'q] trong đó {o't}^q_1 là logit đầu ra mới cho dự đoán đúng Y. Điểm ảnh hưởng cho token xi như sau:

I_xi = Σ^n_t=1 ot - Σ^q_t=1 o't (7)

Chúng tôi xếp hạng tất cả các token theo điểm ảnh hưởng I_xi của chúng theo thứ tự giảm dần để tìm ra các token dễ bị tổn thương nhất V. Chúng tôi chọn k token hàng đầu để giới hạn số lượng nhiễu loạn và tấn công chúng lặp đi lặp lại bằng cách thay thế chúng hoặc bằng cách chèn/xóa một ký tự xung quanh chúng.

Thay thế Token Dễ bị tổn thương Chúng tôi áp dụng tìm kiếm tham lam sử dụng mô hình ngôn ngữ lập trình được che dấu, tuân theo các ràng buộc đặc thù cho mã, để tìm các từ thay thế S cho các token dễ bị tổn thương V sao cho chúng bị nhiễu loạn tối thiểu và có xác suất tối đa dự đoán sai.

Phương pháp Tìm kiếm. Trong chuỗi đầu vào cho trước, chúng tôi che dấu token dễ bị tổn thương vi và sử dụng mô hình PL được che dấu để dự đoán token được ngữ cảnh hóa có ý nghĩa thay thế. Chúng tôi sử dụng k dự đoán hàng đầu cho mỗi token dễ bị tổn thương được che dấu làm không gian tìm kiếm ban đầu. Gọi M biểu thị mô hình PL được che dấu. Với chuỗi đầu vào X = [x1, ..., vi, ..., xm], trong đó vi là token dễ bị tổn thương, M sử dụng thuật toán WordPiece (Wu et al. 2016) để token hóa chia các từ không phổ biến thành các từ phụ dẫn đến H = [h1, h2, ..., hq]. Chúng tôi căn chỉnh và che dấu tất cả các từ phụ tương ứng cho vi, và kết hợp các dự đoán để có k từ thay thế hàng đầu S' = M(H) cho token dễ bị tổn thương vi. Không gian tìm kiếm ban đầu S' này bao gồm l từ thay thế có thể cho token dễ bị tổn thương vi. Sau đó chúng tôi lọc ra các token thay thế để đảm bảo nhiễu loạn tối thiểu, tính nhất quán của mã và tính trôi chảy của mã của các mẫu đối kháng được tạo ra, tuân theo các ràng buộc đặc thù cho mã.

Ràng buộc Đặc thù cho Mã. Vì các token được tạo ra từ mô hình PL được che dấu có thể không phải là các token mã riêng lẻ có ý nghĩa, chúng tôi tiếp tục sử dụng tokenizer CodeNet (Puri et al. 2021) để chia token thành các token mã tương ứng. Các token mã được token hóa thành bốn lớp token mã chính (Bảng 1). Nếu si là từ thay thế cho token dễ bị tổn thương vi được token hóa bởi M, và Op() biểu thị các toán tử có trong bất kỳ token nào sử dụng tokenizer CodeNet, chúng tôi cho phép các token thay thế có thêm hoặc thiếu một toán tử (tương tự như lỗi chính tả trong kênh tự nhiên của mã).

|Op(vi)| - 1 ≤ |Op(si)| ≤ |Op(vi)| + 1 (8)

Gọi C() biểu thị lớp token mã (định danh, từ khóa và đối số) của token. Chúng tôi duy trì sự căn chỉnh giữa vi và từ thay thế tiềm năng si như sau.

C(vi) = C(si) và |C(vi)| = |C(si)| (9)

Các ràng buộc mã trên duy trì tính trôi chảy của mã và tính nhất quán của mã của Xadv và giảm đáng kể không gian tìm kiếm để tìm các ví dụ đối kháng.

Thay thế. Chúng tôi cho phép hai loại thay thế token dễ bị tổn thương để tạo ra các ví dụ đối kháng: (i) Thay thế cấp độ toán tử (ký tự) – chỉ một toán tử được chèn/thay thế/xóa; và (ii) Thay thế cấp độ token. Chúng tôi sử dụng không gian tìm kiếm thu hẹp S và thay thế lặp đi lặp lại, cho đến khi mục tiêu của kẻ tấn công được đáp ứng. Chúng tôi chỉ cho phép thay thế tối đa p% token/ký tự dễ bị tổn thương để giới hạn số lượng

[THIS IS TABLE: Bảng 1 shows token classes and their descriptions:
Token Class | Description
Keywords | Từ dành riêng
Identifiers | Biến, Tên Lớp, Tên Phương thức  
Operators | Dấu ngoặc (fg,(),[]), Ký hiệu (+,*,/,-,%,;,.)
Arguments | Số nguyên, Số thực, Chuỗi, Ký tự]

--- TRANG 4 ---
Thuật toán 1: CodeAttack: Tạo ví dụ đối kháng cho Mã
Đầu vào: CodeX; Mô hình nạn nhân F; Nhiễu loạn tối đa ε; Độ tương tự θ; Sụt giảm hiệu suất β
Đầu ra: Ví dụ đối kháng Xadv
Khởi tạo: Xadv ← X
//Tìm token dễ bị tổn thương 'V'
for xi in M(X) do
    Tính toán Ixi theo Phương trình (7)
end
V ← Rank(xi) dựa trên Ixi
//Tìm từ thay thế 'S'
for vi in V do
    S ← Filter(vi) tuân theo Phương trình (8), (9)
    for sj in S do
        //Tấn công mô hình nạn nhân
        Xadv = [x1, ..., xi-1, sj, ..., xm]
        if Q(F(X)) - Q(F(Xadv)) ≥ β and
           Sim(X, Xadv) ≥ θ and ||Xadv - X|| ≤ ε then
            return Xadv //Thành công
        end
    end
    //Một nhiễu loạn
    Xadv ← [x1, ..., xi-1, sj, ..., xm]
end
return ∅

nhiễu loạn. Chúng tôi cũng duy trì độ tương tự cosine giữa văn bản đầu vào X và văn bản bị nhiễu loạn đối kháng Xadv trên một ngưỡng nhất định (Phương trình 3). Thuật toán hoàn chỉnh được đưa ra trong Thuật toán 1. CodeAttack duy trì nhiễu loạn tối thiểu, tính trôi chảy của mã và tính nhất quán của mã giữa đoạn mã đầu vào và đoạn mã đối kháng.

Thí nghiệm
Chúng tôi nghiên cứu các câu hỏi nghiên cứu sau:
• RQ1: Các cuộc tấn công được tạo ra bằng CodeAttack hiệu quả và có thể chuyển giao như thế nào đối với các tác vụ downstream và ngôn ngữ lập trình khác nhau?
• RQ2: Chất lượng của các mẫu đối kháng được tạo ra bằng CodeAttack như thế nào?
• RQ3: CodeAttack có hiệu quả khi chúng ta giới hạn số lượng nhiễu loạn được phép không?
• RQ4: Tác động của các thành phần khác nhau đến hiệu suất của CodeAttack là gì?

Các Tác vụ Downstream và Bộ dữ liệu Chúng tôi đánh giá khả năng chuyển giao của CodeAttack qua các tác vụ downstream chuỗi đến chuỗi khác nhau và trong các ngôn ngữ lập trình khác nhau: (i) Dịch Mã¹ liên quan đến việc dịch giữa C# và Java và ngược lại, (ii) Sửa Mã tự động sửa lỗi trong các hàm Java. Chúng tôi sử dụng bộ dữ liệu 'small' (Tufano et al. 2019), (iii) Tóm tắt Mã liên quan đến việc tạo ra bản tóm tắt ngôn ngữ tự nhiên cho mã cho trước.

¹https://github.com/eclipse/jgit/, http://lucene.apache.org/, 
http://poi.apache.org/, https://github.com/antlr/

Chúng tôi sử dụng Python, Java và PHP từ bộ dữ liệu CodeSearchNet (Husain et al. 2019). (Xem Phụ lục A để biết chi tiết).

Mô hình Nạn nhân Chúng tôi chọn một phương pháp đại diện từ các loại khác nhau cho thí nghiệm của chúng tôi: (i) CodeT5: Mô hình PL transformer encoder-decoder được tiền huấn luyện (Wang et al. 2021), (ii) CodeBERT: Mô hình PL được tiền huấn luyện song phương thức (Feng et al. 2020), (iii) GraphCodeBERT: Mô hình PL đồ thị được tiền huấn luyện (Guo et al. 2020), (iv) RoBERTa: Mô hình NL được tiền huấn luyện (Guo et al. 2020). (Xem Phụ lục A để biết chi tiết).

Mô hình Baseline Vì CodeAttack hoạt động trong kênh tự nhiên của mã, chúng tôi so sánh với hai baseline đối kháng NLP tiên tiến để so sánh công bằng: (i) TextFooler: Sử dụng từ đồng nghĩa, kiểm tra từ loại và độ tương tự ngữ nghĩa để tạo ra văn bản đối kháng (Jin et al. 2020), (ii) BERT-Attack: Sử dụng mô hình ngôn ngữ được che dấu BERT được tiền huấn luyện để tạo ra văn bản đối kháng (Li et al. 2020).

Chỉ số Đánh giá Chúng tôi đánh giá hiệu quả và chất lượng của mã đối kháng được tạo ra.

Hiệu quả Tấn công. Chúng tôi định nghĩa chỉ số sau.
• drop: Chúng tôi đo sự sụt giảm trong hiệu suất downstream trước và sau cuộc tấn công sử dụng CodeBLEU (Ren et al. 2020) và BLEU (Papineni et al. 2002). Chúng tôi định nghĩa drop = Qbefore - Qafter = Q(F(X), Y) - Q(F(Xadv), Y) trong đó Q = {CodeBLEU, BLEU}; Y là đầu ra thực tế; F là mô hình PL nạn nhân được tiền huấn luyện, Xadv là chuỗi mã đối kháng được tạo ra sau khi nhiễu loạn mã nguồn đầu vào gốc X. CodeBLEU đo chất lượng của đoạn mã được tạo ra cho dịch mã và sửa mã, và BLEU đo chất lượng của bản tóm tắt mã ngôn ngữ tự nhiên được tạo ra khi so sánh với thực tế.

• Success %: Tính toán % các cuộc tấn công thành công được đo bằng drop. Giá trị càng cao, cuộc tấn công đối kháng càng hiệu quả.

Chất lượng Tấn công. Chỉ số sau đo chất lượng của mã đối kháng được tạo ra qua ba chiều: (i) hiệu quả, (ii) khó phát hiện và (iii) tính nhất quán của mã.

• # Queries: Trong thiết lập hộp đen, kẻ tấn công có thể truy vấn mô hình nạn nhân để kiểm tra các thay đổi trong logit đầu ra. Số lượng truy vấn trung bình thấp hơn cần thiết cho mỗi mẫu, kẻ tấn công càng hiệu quả.

• # Perturbation: Số lượng token thay đổi trung bình để tạo ra mã đối kháng. Giá trị càng thấp, cuộc tấn công càng khó phát hiện.

• CodeBLEU_q: Đo tính nhất quán của mã đối kháng sử dụng CodeBLEU_q = CodeBLEU(X, Xadv); trong đó Xadv là chuỗi mã đối kháng được tạo ra sau khi nhiễu loạn mã nguồn đầu vào gốc X. CodeBLEU_q càng cao, mã đối kháng càng nhất quán với mã nguồn gốc.

Chi tiết Triển khai Mô hình được triển khai trong PyTorch. Chúng tôi sử dụng mô hình CodeBERT (MLM) được che dấu và tiền huấn luyện có sẵn công khai làm bộ tạo mã đối kháng. Chúng tôi chọn 50 dự đoán hàng đầu cho mỗi token dễ bị tổn thương làm không gian tìm kiếm ban đầu và cho phép tấn công

--- TRANG 5 ---
[THIS IS TABLE: Bảng 2 showing results on translation (C#-Java), repair (Java-Java), and summarization (PHP) tasks with various metrics for different victim models and attack methods]

tối đa 40% token mã. Ngưỡng độ tương tự cosine giữa mã gốc và mã được tạo ra đối kháng được đặt là 0.5. Làm mô hình nạn nhân, chúng tôi sử dụng các checkpoint được tinh chỉnh có sẵn công khai cho CodeT5 và tinh chỉnh CodeBERT, GraphCodeBERT và RoBERTa trên các tác vụ downstream liên quan. Chúng tôi sử dụng kích thước batch là 256. Tất cả thí nghiệm được thực hiện trên GPU RTX 8000 48GiB. Mã nguồn cho CodeAttack có thể tìm thấy tại https://github.com/reddy-lab-code-research/CodeAttack.

RQ1: Hiệu quả của CodeAttack
Chúng tôi kiểm tra hiệu quả và khả năng chuyển giao của các mẫu đối kháng được tạo ra trên ba tác vụ chuỗi-đến-chuỗi khác nhau (Dịch Mã, Sửa Mã và Tóm tắt Mã). Chúng tôi tạo ra mã đối kháng cho bốn ngôn ngữ lập trình khác nhau (C#, Java, Python và PHP), và tấn công bốn mô hình PL được tiền huấn luyện khác nhau (CodeT5, GraphCodeBERT, CodeBERT và Roberta). Kết quả cho tác vụ dịch C#-Java và tác vụ tóm tắt mã PHP được hiển thị trong Bảng 2. (Xem Phụ lục A cho dịch Java-C# và tác vụ tóm tắt mã Python và Java).

CodeAttack có success% cao nhất so với các baseline đối kháng NLP khác. CodeAttack cũng vượt trội so với các baseline đối kháng, BERT-Attack và TextFooler, trong 6 trên 9 trường hợp – drop trung bình sử dụng CodeAttack khoảng 20% cho tác vụ dịch mã và 10% cho tác vụ sửa mã, tương ứng. Đối với tóm tắt mã, CodeAttack giảm BLEU gần 50% cho tất cả mô hình nạn nhân. Vì BERT-Attack thay thế token một cách bừa bãi, drop của nó cao hơn trong một số trường hợp nhưng chất lượng tấn công của nó thấp nhất.

RQ2: Chất lượng Tấn công Sử dụng CodeAttack
Phân tích Định lượng. So với các mô hình đối kháng NLP khác, CodeAttack hiệu quả nhất vì nó yêu cầu số lượng truy vấn thấp nhất cho một cuộc tấn công thành công (Bảng 2). CodeAttack cũng ít có thể phát hiện nhất vì số lượng nhiễu loạn trung bình cần thiết là 1-3 token trong 8 trên 9 trường hợp. Tính nhất quán của mã của các mẫu đối kháng, được đo bằng CodeBLEU_q, được tạo ra bằng CodeAttack có thể so sánh với TextFooler có tỷ lệ thành công rất thấp. CodeAttack có hiệu suất tổng thể tốt nhất.

Phân tích Định tính. Hình 2 trình bày các ví dụ định tính về các đoạn mã đối kháng được tạo ra từ các mô hình tấn công khác nhau. Mặc dù TextFooler có điểm CodeBLEU_q hơi tốt hơn so với CodeAttack (như thấy từ Bảng 2), nó thay thế từ khóa bằng các từ ngôn ngữ tự nhiên liên quan chặt chẽ (public→audiences; override→revoked, void→cancelling).

--- TRANG 6 ---
Hình 2: Ví dụ định tính về mã đối kháng trên tác vụ Dịch Mã C#-Java. (Xem Phụ lục A để biết thêm ví dụ).

Hình 3: Tính đúng cú pháp của mã đối kháng trên C#, Java và Python chứng minh chất lượng tấn công.

BERT-Attack có CodeBLEU_q thấp nhất và thay thế token bằng những từ có vẻ ngẫu nhiên. Cả TextFooler và BERT-Attack đều không được thiết kế cho ngôn ngữ lập trình. CodeAttack tạo ra các mẫu mã đối kháng có ý nghĩa hơn bằng cách thay thế các token dễ bị tổn thương bằng các biến và toán tử khó phát hiện và nhất quán.

Tính đúng cú pháp. Tính đúng cú pháp của mã đối kháng được tạo ra là tiêu chí hữu ích để đánh giá chất lượng tấn công mặc dù CodeAttack và các mô hình PL khác chủ yếu hoạt động trong kênh tự nhiên của mã, tức là chúng quan tâm đến việc hiểu mã cho con người chứ không phải với việc thực thi hoặc biên dịch mã. Các bộ dữ liệu được mô tả trước đó bao gồm các đoạn mã và không thể biên dịch được. Do đó, chúng tôi tạo ra mã đối kháng cho C#, Java và Python sử dụng TextFooler, BERT-Attack và CodeAttack và yêu cầu 3 người chú thích con người, quen thuộc với các ngôn ngữ này để xác minh cú pháp thủ công. Chúng tôi lấy mẫu ngẫu nhiên 60 mã đối kháng được tạo ra cho cả ba ngôn ngữ lập trình để đánh giá mỗi phương pháp trên. CodeAttack có tính đúng cú pháp trung bình cao nhất cho C# (70%), Java (60%) và Python (76.19%) theo sau là BERT-Attack và TextFooler (Hình 3), tiếp tục làm nổi bật nhu cầu về một cuộc tấn công đối kháng đặc thù cho mã.

RQ3: Giới hạn Nhiễu loạn Sử dụng CodeAttack
Chúng tôi hạn chế số lượng nhiễu loạn khi tấn công mô hình PL được tiền huấn luyện đến một giới hạn nghiêm ngặt, và nghiên cứu hiệu quả của CodeAttack. Từ Hình 4a, chúng tôi quan sát thấy rằng khi % nhiễu loạn tăng, CodeBLEU_after cho CodeAttack giảm nhưng vẫn không đổi cho TextFooler và chỉ giảm nhẹ cho BERT-Attack. Chúng tôi cũng quan sát thấy rằng mặc dù CodeBLEU_q cho CodeAttack là tốt thứ hai (Hình 4b), nó có tỷ lệ thành công tấn công cao nhất (Hình 4d) và yêu cầu số lượng truy vấn thấp nhất cho một cuộc tấn công thành công (Hình 4c). Điều này cho thấy hiệu quả của CodeAttack và nhu cầu về các cuộc tấn công đối kháng đặc thù cho mã.

RQ4: Nghiên cứu Ablation
Tầm quan trọng của Token Dễ bị tổn thương. Chúng tôi tạo ra một biến thể, CodeAttack_RAND, lấy mẫu ngẫu nhiên token từ mã đầu vào để thay thế. Chúng tôi định nghĩa một biến thể khác, CodeAttack_VUL, tìm token dễ bị tổn thương dựa trên thông tin logit và tấn công chúng, mặc dù không có bất kỳ ràng buộc nào. Như có thể thấy từ Hình 5a, tấn công token ngẫu nhiên không hiệu quả bằng tấn công token dễ bị tổn thương. Sử dụng CodeAttack_VUL mang lại drop lớn hơn và yêu cầu ít truy vấn hơn khi so sánh với CodeAttack_RAND, qua tất cả ba mô hình với CodeBLEU_q tương tự (Hình 5b) và success % (Hình 5d).

Tầm quan trọng của Ràng buộc Đặc thù cho Mã. Chúng tôi tìm token dễ bị tổn thương và áp dụng hai loại ràng buộc: (i) Ràng buộc cấp độ toán tử (CodeAttack_OP), và (ii) Ràng buộc cấp độ token (CodeAttack_TOK). Chỉ áp dụng ràng buộc cấp độ toán tử dẫn đến success% tấn công thấp hơn (Hình 5d) và drop thấp hơn (Hình 5a) nhưng CodeBLEU_q cao hơn nhiều. Điều này là do chúng tôi giới hạn các thay đổi chỉ ở toán tử dẫn đến thay đổi tối thiểu. Khi áp dụng cả ràng buộc cấp độ toán tử và cấp độ token cùng nhau, drop và success% tấn công cải thiện đáng kể. (Xem Phụ lục A để biết ví dụ định tính.)

Tổng thể, mô hình cuối cùng, CodeAttack, bao gồm CodeAttack_VUL, CodeAttack_OP và CodeAttack_TOK, có sự cân bằng tốt nhất qua drop, success % tấn công, CodeBLEU_q và #Queries cho tất cả mô hình PL nạn nhân được tiền huấn luyện.

Đánh giá Con người. Chúng tôi lấy mẫu 50 mẫu mã Java và C# gốc và bị nhiễu loạn và xáo trộn chúng để tạo ra hỗn hợp. Chúng tôi yêu cầu 3 người chú thích con người, quen thuộc với hai ngôn ngữ lập trình, phân loại các mã là gốc hoặc đối kháng bằng cách đánh giá mã nguồn trong kênh tự nhiên của chúng. Trung bình, 72.1% các mã cho trước được phân loại là gốc. Chúng tôi cũng yêu cầu họ đọc các mã đối kháng cho trước và đánh giá khả năng hiểu mã của họ trên thang điểm từ 1 đến 5; trong đó 1 tương ứng với 'Mã hoàn toàn không thể hiểu được'; và 5 tương ứng với 'Mã hoàn toàn có thể hiểu được'. Khả năng hiểu mã trung bình cho các mã đối kháng là 4.14. Ngoài ra, chúng tôi cung cấp cho người chú thích các cặp mã đối kháng và gốc và yêu cầu

--- TRANG 7 ---
(a) CodeBLEU after     (b) CodeBLEU q     (c) Trung bình #Queries     (d) Attack%

Hình 4: Thay đổi % nhiễu loạn để nghiên cứu hiệu quả tấn công trên CodeT5 cho tác vụ dịch mã (C#-Java).

(a) Sụt giảm Hiệu suất     (b) CodeBLEU q     (c) # Queries     (d) Tỷ lệ Thành công Trung bình

Hình 5: Nghiên cứu Ablation cho Dịch Mã (C#-Java): Hiệu suất của các thành phần khác nhau của CodeAttack với token ngẫu nhiên (RAND) và dễ bị tổn thương (VUL) và hai ràng buộc đặc thù cho mã: (i) Cấp độ toán tử (OP), và (ii) Cấp độ token (TOK).

họ đánh giá tính nhất quán của mã giữa hai mã sử dụng thang điểm từ 0 đến 1; trong đó 0 tương ứng với 'Hoàn toàn không nhất quán với mã gốc', và 1 tương ứng với 'Cực kỳ nhất quán với mã gốc'. Trung bình, tính nhất quán của mã là 0.71.

Thảo luận
Con người 'tóm tắt' mã bằng cách đọc các lệnh gọi hàm, tập trung vào thông tin biểu thị ý định của mã (như tên biến) và lướt qua thông tin cấu trúc (như vòng lặp while và for) (Rodeghero et al. 2014). Các mô hình PL được tiền huấn luyện hoạt động theo cách tương tự và không gán trọng số chú ý cao cho ngữ pháp hoặc cấu trúc mã (Zhang et al. 2022). Chúng coi mã phần mềm như ngôn ngữ tự nhiên (Hindle et al. 2016) và không tập trung vào việc biên dịch hoặc thực thi mã nguồn đầu vào trước khi xử lý chúng để tạo ra đầu ra (Zhang et al. 2022). Thông qua thử nghiệm rộng rãi, chúng tôi chứng minh rằng hạn chế này của các mô hình PL tiên tiến có thể được khai thác để tạo ra các ví dụ đối kháng trong kênh tự nhiên của mã và thay đổi đáng kể hiệu suất của chúng.

Chúng tôi quan sát thấy rằng dễ tấn công tác vụ dịch mã hơn so với tác vụ sửa mã hoặc tóm tắt mã. Vì sửa mã nhằm sửa lỗi trong đoạn mã cho trước, nó khó tấn công hơn nhưng không phải là không thể. Đối với tóm tắt mã, điểm BLEU giảm gần 50%. Đối với cả ba tác vụ, CodeT5 tương đối bền vững hơn trong khi GraphCodeBERT dễ bị tấn công nhất sử dụng CodeAttack. CodeT5 đã được tiền huấn luyện trên tác vụ 'Dự đoán Định danh Được Che dấu' hoặc deobsfuction (Lachaux et al. 2021) nơi thay đổi tên định danh không có tác động đến ngữ nghĩa mã. Điều này giúp mô hình tránh các cuộc tấn công liên quan đến thay đổi tên định danh. GraphCodeBERT sử dụng đồ thị luồng dữ liệu trong tiền huấn luyện của chúng dựa vào việc dự đoán mối quan hệ giữa các định danh. Vì CodeAttack sửa đổi các định danh và nhiễu loạn mối quan hệ giữa chúng, nó chứng minh cực kỳ hiệu quả trên GraphCodeBERT. Điều này dẫn đến sự sụt giảm đáng kể hơn trên GraphCodeBERT so với các mô hình khác cho tác vụ dịch mã. Các ví dụ đối kháng từ CodeAttack, mặc dù hiệu quả, có thể được tránh nếu các mô hình PL được tiền huấn luyện biên dịch/thực thi mã trước khi xử lý nó. Điều này làm nổi bật nhu cầu tích hợp cấu trúc mã rõ ràng trong giai đoạn tiền huấn luyện để học các biểu diễn chương trình bền vững hơn.

Kết luận
Chúng tôi giới thiệu CodeAttack, mô hình tấn công đối kháng hộp đen để phát hiện lỗ hổng của các mô hình ngôn ngữ lập trình tiên tiến. Nó tìm các token dễ bị tổn thương nhất trong đoạn mã cho trước và sử dụng cơ chế tìm kiếm tham lam để xác định các từ thay thế được ngữ cảnh hóa tuân theo các ràng buộc đặc thù cho mã. Mô hình của chúng tôi tạo ra các ví dụ đối kháng trong kênh tự nhiên của mã. Chúng tôi thực hiện đánh giá thực nghiệm và con người rộng rãi để chứng minh khả năng chuyển giao của CodeAttack trên nhiều tác vụ mã-mã và mã-NL qua các ngôn ngữ lập trình khác nhau. CodeAttack vượt trội so với các mô hình đối kháng NLP tiên tiến hiện có, về hiệu quả tấn công, chất lượng tấn công và tính đúng cú pháp. Các mẫu đối kháng được tạo ra bằng CodeAttack hiệu quả, hiệu suất, khó phát hiện, trôi chảy và nhất quán về mã. CodeAttack làm nổi bật nhu cầu về các cuộc tấn công đối kháng đặc thù cho mã cho các mô hình PL được tiền huấn luyện trong kênh tự nhiên.

--- TRANG 8 ---
Tài liệu tham khảo
Ahmad, W.; Chakraborty, S.; Ray, B.; và Chang, K.-W. 2021. Tiền huấn luyện thống nhất cho hiểu và tạo chương trình. Trong Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, 2655–2668.

Alzantot, M.; Sharma, Y.; Elgohary, A.; Ho, B.-J.; Srivastava, M.; và Chang, K.-W. 2018. Tạo ví dụ đối kháng ngôn ngữ tự nhiên. Trong Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, 2890–2896.

Applis, L.; Panichella, A.; và van Deursen, A. 2021. Đánh giá tính bền vững của công cụ phân tích chương trình dựa trên ML sử dụng biến đổi chương trình metamorphic. Trong 2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE), 1377–1381. IEEE.

Casalnuovo, C.; Barr, E. T.; Dash, S. K.; Devanbu, P.; và Morgan, E. 2020. Lý thuyết về ràng buộc kênh đôi. Trong 2020 IEEE/ACM 42nd International Conference on Software Engineering: New Ideas and Emerging Results (ICSE-NIER), 25–28. IEEE.

Chakraborty, S.; Ahmed, T.; Ding, Y.; Devanbu, P. T.; và Ray, B. 2022. NatGen: tiền huấn luyện tạo sinh bằng cách "tự nhiên hóa" mã nguồn. Trong Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 18–30.

Ebrahimi, J.; Rao, A.; Lowd, D.; và Dou, D. 2018. HotFlip: Ví dụ đối kháng hộp trắng cho phân loại văn bản. Trong Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), 31–36.

Feng, Z.; Guo, D.; Tang, D.; Duan, N.; Feng, X.; Gong, M.; Shou, L.; Qin, B.; Liu, T.; Jiang, D.; et al. 2020. CodeBERT: Mô hình được tiền huấn luyện cho lập trình và ngôn ngữ tự nhiên. Trong Findings of the Association for Computational Linguistics: EMNLP 2020, 1536–1547.

Gao, J.; Lanchantin, J.; Soffa, M. L.; và Qi, Y. 2018. Tạo sinh hộp đen của chuỗi văn bản đối kháng để tránh bộ phân loại học sâu. Trong 2018 IEEE Security and Privacy Workshops (SPW), 50–56. IEEE.

Garg, S.; và Ramakrishnan, G. 2020. BAE: Ví dụ đối kháng dựa trên BERT cho phân loại văn bản. Trong Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP), 6174–6181.

Guo, D.; Ren, S.; Lu, S.; Feng, Z.; Tang, D.; Shujie, L.; Zhou, L.; Duan, N.; Svyatkovskiy, A.; Fu, S.; et al. 2020. GraphCodeBERT: Tiền huấn luyện biểu diễn mã với luồng dữ liệu. Trong International Conference on Learning Representations.

Henkel, J.; Ramakrishnan, G.; Wang, Z.; Albarghouthi, A.; Jha, S.; và Reps, T. 2022. Tính bền vững ngữ nghĩa của mô hình mã nguồn. Trong 2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER), 526–537.

Hindle, A.; Barr, E. T.; Gabel, M.; Su, Z.; và Devanbu, P. 2016. Về tính tự nhiên của phần mềm. Communications of the ACM, 59(5): 122–131.

Hsieh, Y.-L.; Cheng, M.; Juan, D.-C.; Wei, W.; Hsu, W.-L.; và Hsieh, C.-J. 2019. Về tính bền vững của mô hình tự chú ý. Trong Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, 1520–1529.

Husain, H.; Wu, H.-H.; Gazit, T.; Allamanis, M.; và Brockschmidt, M. 2019. Thử thách codesearchnet: Đánh giá trạng thái tìm kiếm mã ngữ nghĩa. arXiv preprint arXiv:1909.09436.

Jin, D.; Jin, Z.; Zhou, J. T.; và Szolovits, P. 2020. BERT có thực sự bền vững không? Một baseline mạnh cho tấn công ngôn ngữ tự nhiên trên phân loại văn bản và entailment. Trong Proceedings of the AAAI conference on artificial intelligence, volume 34, 8018–8025.

Lachaux, M.-A.; Roziere, B.; Szafraniec, M.; và Lample, G. 2021. DOBF: Mục tiêu tiền huấn luyện deobfuscation cho ngôn ngữ lập trình. Advances in Neural Information Processing Systems, 34.

Lai, G.; Xie, Q.; Liu, H.; Yang, Y.; và Hovy, E. 2017. RACE: Bộ dữ liệu hiểu đọc quy mô lớn từ kỳ thi. Trong Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, 785–794.

Li, J.; Ji, S.; Du, T.; Li, B.; và Wang, T. 2019. TextBugger: Tạo văn bản đối kháng chống lại ứng dụng thế giới thực. Trong 26th Annual Network and Distributed System Security Symposium.

Li, L.; Ma, R.; Guo, Q.; Xue, X.; và Qiu, X. 2020. BERT-ATTACK: Tấn công đối kháng chống lại BERT sử dụng BERT. Trong Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP), 6193–6202.

Liu, Y.; Ott, M.; Goyal, N.; Du, J.; Joshi, M.; Chen, D.; Levy, O.; Lewis, M.; Zettlemoyer, L.; và Stoyanov, V. 2019. Roberta: Phương pháp tiền huấn luyện bert được tối ưu hóa mạnh mẽ. arXiv preprint arXiv:1907.11692.

Lu, S.; Guo, D.; Ren, S.; Huang, J.; Svyatkovskiy, A.; Blanco, A.; Clement, C. B.; Drain, D.; Jiang, D.; Tang, D.; Li, G.; Zhou, L.; Shou, L.; Zhou, L.; Tufano, M.; Gong, M.; Zhou, M.; Duan, N.; Sundaresan, N.; Deng, S. K.; Fu, S.; và Liu, S. 2021. CodeXGLUE: Bộ dữ liệu benchmark học máy cho hiểu và tạo mã. CoRR, abs/2102.04664.

Metropolis, N.; Rosenbluth, A. W.; Rosenbluth, M. N.; Teller, A. H.; và Teller, E. 1953. Tính toán phương trình trạng thái bằng máy tính nhanh. The journal of chemical physics, 21(6): 1087–1092.

Papernot, N.; Faghri, F.; Carlini, N.; Goodfellow, I.; Feinman, R.; Kurakin, A.; Xie, C.; Sharma, Y.; Brown, T.; Roy, A.; et al. 2016. Báo cáo kỹ thuật về thư viện ví dụ đối kháng cleverhans v2.1.0. arXiv preprint arXiv:1610.00768.

Papineni, K.; Roukos, S.; Ward, T.; và Zhu, W.-J. 2002. Bleu: Phương pháp đánh giá tự động dịch máy. Trong Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics, 311–318. Philadelphia, Pennsylvania, USA: Association for Computational Linguistics.

--- TRANG 9 ---
Pruthi, D.; Dhingra, B.; và Lipton, Z. C. 2019. Chống lại lỗi chính tả đối kháng với nhận dạng từ bền vững. Trong Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, 5582–5591.

Puri, R.; Kung, D. S.; Janssen, G.; Zhang, W.; Domeniconi, G.; Zolotov, V.; Dolby, J.; Chen, J.; Choudhury, M.; Decker, L.; et al. 2021. Project codenet: Bộ dữ liệu AI cho mã quy mô lớn để học đa dạng tác vụ lập trình. arXiv preprint arXiv:2105.12655, 1035.

Rajpurkar, P.; Zhang, J.; Lopyrev, K.; và Liang, P. 2016. SQuAD: 100,000+ câu hỏi cho hiểu máy về văn bản. Trong Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, 2383–2392. Austin, Texas: Association for Computational Linguistics.

Ren, S.; Deng, Y.; He, K.; và Che, W. 2019. Tạo ví dụ đối kháng ngôn ngữ tự nhiên thông qua tầm quan trọng từ có trọng số xác suất. Trong Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, 1085–1097. Florence, Italy: Association for Computational Linguistics.

Ren, S.; Guo, D.; Lu, S.; Zhou, L.; Liu, S.; Tang, D.; Sundaresan, N.; Zhou, M.; Blanco, A.; và Ma, S. 2020. Codebleu: Phương pháp đánh giá tự động tổng hợp mã. arXiv preprint arXiv:2009.10297.

Rodeghero, P.; McMillan, C.; McBurney, P. W.; Bosch, N.; và D'Mello, S. 2014. Cải thiện tóm tắt mã nguồn tự động thông qua nghiên cứu theo dõi mắt của lập trình viên. Trong Proceedings of the 36th international conference on Software engineering, 390–401.

Tipirneni, S.; Zhu, M.; và Reddy, C. K. 2022. StructCoder: Transformer nhận biết cấu trúc cho tạo mã. arXiv preprint arXiv:2206.05239.

Tufano, M.; Watson, C.; Bavota, G.; Penta, M. D.; White, M.; và Poshyvanyk, D. 2019. Nghiên cứu thực nghiệm về học các bản vá sửa lỗi trong tự nhiên thông qua dịch máy neural. ACM Transactions on Software Engineering and Methodology (TOSEM), 28(4): 1–29.

Wang, A.; Singh, A.; Michael, J.; Hill, F.; Levy, O.; và Bowman, S. 2018. GLUE: Nền tảng benchmark và phân tích đa tác vụ cho hiểu ngôn ngữ tự nhiên. Trong Proceedings of the 2018 EMNLP Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for NLP, 353–355.

Wang, Y.; Wang, W.; Joty, S.; và Hoi, S. C. 2021. CodeT5: Mô hình encoder-decoder được tiền huấn luyện thống nhất nhận biết định danh cho hiểu và tạo mã. Trong Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, 8696–8708.

Wu, Y.; Schuster, M.; Chen, Z.; Le, Q. V.; Norouzi, M.; Macherey, W.; Krikun, M.; Cao, Y.; Gao, Q.; Macherey, K.; et al. 2016. Hệ thống dịch máy neural của Google: Bắc cầu khoảng cách giữa dịch của con người và máy. arXiv preprint arXiv:1609.08144.

Yang, P.; Chen, J.; Hsieh, C.-J.; Wang, J.-L.; và Jordan, M. I. 2020. Tấn công tham lam và tấn công Gumbel: Tạo ví dụ đối kháng cho dữ liệu rời rạc. J. Mach. Learn. Res., 21(43): 1–36.

Yang, Z.; Shi, J.; He, J.; và Lo, D. 2022. Tấn công tự nhiên cho mô hình được tiền huấn luyện của mã. Trong Proceedings of the 44th International Conference on Software Engineering, ICSE '22, 1482–1493. New York, NY, USA: Association for Computing Machinery. ISBN 9781450392211.

Yefet, N.; Alon, U.; và Yahav, E. 2020. Ví dụ đối kháng cho mô hình mã. Proceedings of the ACM on Programming Languages, 4(OOPSLA): 1–30.

Zhang, H.; Li, Z.; Li, G.; Ma, L.; Liu, Y.; và Jin, Z. 2020. Tạo ví dụ đối kháng để giữ tính bền vững của mô hình xử lý mã nguồn. Trong Proceedings of the AAAI Conference on Artificial Intelligence, volume 34, 1169–1176.

Zhang, Z.; Zhang, H.; Shen, B.; và Gu, X. 2022. Mã diet có lợi cho sức khỏe: Đơn giản hóa chương trình cho mô hình được tiền huấn luyện của mã. Trong Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 1073–1084.

Zhou, Y.; Zhang, X.; Shen, J.; Han, T.; Chen, T.; và Gall, H. 2022. Tính bền vững đối kháng của tạo chú thích mã sâu. ACM Transactions on Software Engineering and Methodology (TOSEM), 31(4): 1–30.

--- TRANG 10 ---
A Phụ lục
Các Tác vụ Downstream và Bộ dữ liệu
Chúng tôi đánh giá khả năng chuyển giao của CodeAttack qua các tác vụ downstream chuỗi đến chuỗi khác nhau và bộ dữ liệu trong các ngôn ngữ lập trình khác nhau.

• Dịch Mã liên quan đến việc dịch một ngôn ngữ lập trình sang ngôn ngữ khác. Bộ dữ liệu dịch mã có sẵn công khai² bao gồm các hàm song song giữa Java và C#. Có tổng cộng 11,800 hàm được ghép nối, trong đó 1000 được sử dụng để kiểm tra. Độ dài chuỗi trung bình cho các hàm Java là 38.51 token, và độ dài trung bình cho các hàm C# là 46.16.

• Sửa Mã tinh chỉnh mã bằng cách tự động sửa lỗi. Bộ dữ liệu sửa mã có sẵn công khai (Tufano et al. 2019) bao gồm các hàm Java có lỗi làm nguồn và các hàm được sửa tương ứng làm đích. Chúng tôi sử dụng bộ dữ liệu nhỏ với 46,680 mẫu huấn luyện, 5,835 mẫu xác thực và 5,835 mẫu kiểm tra (≤ 50 token trong mỗi hàm).

• Tóm tắt Mã liên quan đến việc tạo bản tóm tắt ngôn ngữ tự nhiên cho mã cho trước. Chúng tôi sử dụng bộ dữ liệu CodeSearchNet (Husain et al. 2019) bao gồm mã và các bản tóm tắt tương ứng trong ngôn ngữ tự nhiên. Chúng tôi hiển thị kết quả của mô hình trên Python (252K/14K/15K), Java (165K/5K/11K), và PHP (241K/13K/15K). Các số trong ngoặc biểu thị các mẫu trong tập huấn luyện/phát triển/kiểm tra, tương ứng.

Mô hình Nạn nhân
Chúng tôi chọn một phương pháp đại diện từ các loại khác nhau làm mô hình nạn nhân để đánh giá cuộc tấn công.

• CodeT5 (Wang et al. 2021): Mô hình PL transformer encoder-decoder được tiền huấn luyện thống nhất tận dụng ngữ nghĩa mã bằng cách sử dụng mục tiêu tiền huấn luyện nhận biết định danh. Đây là tiên tiến nhất trên nhiều tác vụ phụ trong benchmark CodeXGlue (Lu et al. 2021).

• CodeBERT (Feng et al. 2020): Mô hình ngôn ngữ lập trình được tiền huấn luyện song phương thức thực hiện các tác vụ mã-mã và mã-NL.

• GraphCodeBert (Guo et al. 2020): Mô hình ngôn ngữ lập trình đồ thị được tiền huấn luyện tận dụng cấu trúc mã thông qua đồ thị luồng dữ liệu.

• RoBERTa (Liu et al. 2019): Mô hình ngôn ngữ tự nhiên được tiền huấn luyện với kết quả tiên tiến trên các bộ dữ liệu GLUE (Wang et al. 2018), RACE (Lai et al. 2017), và SQuAD (Rajpurkar et al. 2016).

Chúng tôi sử dụng các checkpoint được tinh chỉnh có sẵn công khai cho CodeT5 và tinh chỉnh CodeBERT, GraphCodeBERT, và RoBERTa trên các tác vụ downstream liên quan.

Mô hình Baseline Vì CodeAttack hoạt động trong kênh tự nhiên của mã, chúng tôi so sánh với hai baseline đối kháng NLP tiên tiến để so sánh công bằng:

²http://lucene.apache.org/, http://poi.apache.org/, https://github.com/eclipse/jgit/, https://github.com/antlr/

• TextFooler (Jin et al. 2020): Sử dụng kết hợp từ đồng nghĩa, kiểm tra từ loại (POS), và độ tương tự ngữ nghĩa để tạo văn bản đối kháng.

• BERT-Attack (Li et al. 2020): Sử dụng mô hình ngôn ngữ được che dấu BERT được tiền huấn luyện để tạo ví dụ đối kháng thỏa mãn ngưỡng độ tương tự nhất định.

Kết quả
Hiệu suất Downstream và Chất lượng Tấn công Chúng tôi đo CodeBLEU và CodeBLEUΔ để đánh giá hiệu suất downstream cho các tác vụ mã-mã (sửa mã và dịch mã). Các ngôn ngữ lập trình được sử dụng là C#-Java và Java-C# cho các tác vụ dịch; và Java cho các tác vụ sửa mã (Bảng 3 và Bảng 4). Chúng tôi hiển thị kết quả cho tác vụ mã-NL cho tóm tắt mã trong BLEU và BLEUΔ. Chúng tôi hiển thị kết quả cho ba ngôn ngữ lập trình: Python, Java, và PHP (Bảng 3 và Bảng 5). Chúng tôi đo chất lượng của các cuộc tấn công sử dụng chỉ số được định nghĩa trong . Kết quả tuân theo mô hình tương tự như thấy trong Phần .

Nghiên cứu Ablation: Phân tích Định tính Bảng 6 hiển thị các ví dụ đối kháng được tạo ra sử dụng các biến thể được mô tả trong Phần .

--- TRANG 11 ---
[Bảng 3 với kết quả chi tiết cho các tác vụ dịch mã, sửa mã và tóm tắt mã]

--- TRANG 12 ---
[Bảng 4 với ví dụ định tính về mã bị nhiễu loạn sử dụng TextFooler, BERT-Attack và CodeAttack trên tác vụ Dịch Mã]

[Bảng 5 với ví dụ định tính về mã đối kháng và bản tóm tắt được tạo ra sử dụng TextFooler, BERT-Attack và CodeAttack trên tác vụ Tóm tắt Mã]

--- TRANG 13 ---
[Bảng 6 với ví dụ định tính cho nghiên cứu ablation trên CodeAttack: Tấn công token dễ bị tổn thương (VUL); với ràng buộc cấp độ toán tử (VUL+OP), và với ràng buộc cấp độ token (VUL+OP+TOK) trên tác vụ dịch mã]
