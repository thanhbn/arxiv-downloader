# Giải quyết xung đột hợp nhất chương trình thông qua Neural Transformers

Alexey Svyatkovskiy
Microsoft
Redmond, WA, USA

Sarah Fakhoury
Washington State University
Pullman, WA, USA

Negar Ghorbani
UC Irvine
Irvine, CA, USA

Todd Mytkowicz
Microsoft Research
Redmond, WA, USA

Elizabeth Dinella
University of Pennsylvania
Philadelphia, PA, USA

Christian Bird
Microsoft Research
Redmond, WA, USA

Jinu Jang
Microsoft
Redmond, WA, USA

Neel Sundaresan
Microsoft
Redmond, WA, USA

Shuvendu K. Lahiri
Microsoft Research
Redmond, WA, USA

## TÓM TẮT
Phát triển phần mềm cộng tác là một phần không thể thiếu của chu kỳ phát triển phần mềm hiện đại, rất cần thiết cho sự thành công của các dự án phần mềm quy mô lớn. Khi nhiều nhà phát triển thực hiện các thay đổi đồng thời xung quanh cùng một dòng mã, có thể xảy ra xung đột hợp nhất. Những xung đột như vậy làm trì hoãn các pull request và pipeline tích hợp liên tục trong nhiều giờ đến vài ngày, làm tổn hại nghiêm trọng đến năng suất của nhà phát triển. Để giải quyết vấn đề này, chúng tôi giới thiệu MergeBERT, một framework hợp nhất chương trình neural mới dựa trên phân biệt ba chiều ở mức token và mô hình mã hóa transformer. Bằng cách khai thác tính chất hạn chế của các giải pháp xung đột hợp nhất, chúng tôi cải tạo tác vụ tạo ra chuỗi giải quyết thành một tác vụ phân loại trên một tập hợp các mẫu hợp nhất nguyên thủy được trích xuất từ dữ liệu commit hợp nhất thế giới thực. Mô hình của chúng tôi đạt được độ chính xác 63-68% cho việc tổng hợp giải quyết hợp nhất, mang lại cải thiện hiệu suất gần 3× so với các công cụ hợp nhất chương trình bán cấu trúc hiện có và cải thiện 2× so với các công cụ neural. Cuối cùng, chúng tôi chứng minh rằng MergeBERT đủ linh hoạt để làm việc với các tệp mã nguồn trong các ngôn ngữ lập trình Java, JavaScript, TypeScript và C#. Để đo lường việc sử dụng thực tế của MergeBERT, chúng tôi tiến hành một nghiên cứu người dùng để đánh giá các đề xuất của MergeBERT với 25 nhà phát triển từ các dự án OSS lớn trên 122 xung đột thế giới thực mà họ gặp phải. Kết quả cho thấy trong thực tế, các giải pháp MergeBERT sẽ được chấp nhận với tỷ lệ cao hơn so với ước tính bởi các chỉ số tự động cho độ chính xác và chính xác. Ngoài ra, chúng tôi sử dụng phản hồi của người tham gia để xác định các hướng cải thiện MergeBERT trong tương lai.

**TỪ KHÓA**
Tiến hóa phần mềm, hợp nhất chương trình, ml4code

## 1 GIỚI THIỆU
Phát triển phần mềm cộng tác dựa vào các hệ thống kiểm soát phiên bản như git để quản lý và theo dõi các thay đổi trên codebase. Trong hầu hết các dự án, các nhà phát triển chủ yếu làm việc trong một nhánh của kho phần mềm, định kỳ đồng bộ hóa các thay đổi mã của họ với nhánh chính thông qua merge và pull request. Khi nhiều nhà phát triển thực hiện thay đổi đồng thời trên cùng một dòng mã, có thể xảy ra xung đột hợp nhất. Các commit hợp nhất xảy ra thường xuyên, gần 12% tất cả commit có liên quan đến hợp nhất, và lên đến 46% các commit đó dẫn đến xung đột. Giải quyết xung đột hợp nhất là một hoạt động tốn thời gian, phức tạp và dễ gây lỗi. Để giải quyết xung đột, các nhà phát triển phải dừng quy trình làm việc của họ, hiểu các thay đổi xung đột và xác định giải pháp đúng. Cách lý tưởng để giải quyết xung đột không phải lúc nào cũng rõ ràng, và có thể cần tham khảo tài liệu đặc tả dự án hoặc giao tiếp với đồng nghiệp về các thay đổi.

Các hệ thống kiểm soát phiên bản hiện đại như git sử dụng thuật toán diff3 để thực hiện hợp nhất ba chiều không có cấu trúc dựa trên dòng của các tệp đầu vào. Do đó, nó là công cụ de facto cho việc hợp nhất và xác định xung đột hợp nhất trong phát triển phần mềm. Thuật toán này căn chỉnh các diff hai chiều của hai phiên bản mã, A và B, với cơ sở chung, O, thành một chuỗi các "slot" diff. Tại mỗi slot, một thay đổi từ A hoặc B được chọn. Trong các trường hợp mà cả A và B đều chứa thay đổi (so với O) trong cùng một slot (ví dụ, trên cùng một dòng), có xung đột hợp nhất. Các thuật toán hợp nhất tiêu chuẩn không thể tự động xác định cách đúng để hợp nhất những thay đổi xung đột này. Trong những trường hợp này, các nhà phát triển phải can thiệp thủ công để giải quyết đúng mã xung đột và hoàn thành việc hợp nhất.

Trong thập kỷ qua, một số phương pháp đã được đề xuất để cải thiện việc phát hiện và giải quyết tự động các xung đột hợp nhất. Một số phương pháp sử dụng cây cú pháp trừu tượng (AST) hoặc các biểu diễn khác của mã nguồn để cải thiện giải quyết xung đột; những phương pháp khác sử dụng phương pháp dựa trên dữ liệu sử dụng deep learning để dự đoán hợp nhất đúng. Các nhà nghiên cứu cũng đã phát triển các công cụ để giúp các nhà phát triển hình dung và điều hướng quá trình giải quyết xung đột hợp nhất, và xác định các nhu cầu chính của cộng đồng nhà phát triển để hỗ trợ công cụ hiệu quả. Khối lượng nghiên cứu dành riêng cho vấn đề này đại diện cho một lượng thời gian và công sức đáng kể. Bất chấp những tiến bộ này, không có phương pháp nào trong số này được áp dụng rộng rãi trong thực tế, và thuật toán phát hiện dựa trên văn bản của git vẫn là một trong những phương pháp hợp nhất được sử dụng phổ biến nhất.

Trong nỗ lực giải quyết điều này, chúng tôi giới thiệu MergeBERT: một framework hợp nhất chương trình neural dựa trên phân biệt ba chiều ở mức token và một biến thể đầu vào đa chiều của mô hình mã hóa transformer hai chiều (BERT). Chúng tôi hình thành tác vụ tạo ra chuỗi giải quyết xung đột hợp nhất như một tác vụ phân loại trên một tập hợp các mẫu hợp nhất nguyên thủy được trích xuất từ dữ liệu commit hợp nhất thế giới thực. MergeBERT mã hóa tất cả đầu vào mà thuật toán diff3 tiêu chuẩn nhận (hai diff hai chiều của các chương trình đầu vào) cũng như thông tin chuỗi chỉnh sửa, sau đó tổng hợp chúng để học. Chúng tôi huấn luyện và sau đó đánh giá MergeBERT trên 220.000 và 54.000 (tương ứng) xung đột hợp nhất lịch sử thế giới thực và các giải pháp thủ công liên quan từ 100.000 kho GitHub trong JavaScript, TypeScript, Java và C#, và thấy rằng nó hoạt động khá tốt, với độ chính xác và chính xác luôn trên 60% (trên 70% nếu xem xét ba gợi ý hàng đầu). Hơn nữa, chúng tôi so sánh MergeBERT với các phương pháp hợp nhất có cấu trúc và bán cấu trúc hiện đại (nhất thiết phải dành riêng cho ngôn ngữ) và cho thấy MergeBERT có thể cung cấp gợi ý giải quyết cho nhiều xung đột hợp nhất hơn và các gợi ý đúng (tức là, khớp với giải pháp thủ công lịch sử của người dùng) thường xuyên hơn.

Để đánh giá tốt hơn các giải pháp được tạo ra bởi MergeBERT từ góc độ người dùng trong thực tế, chúng tôi cũng tiến hành một nghiên cứu người dùng với 25 nhà phát triển từ các dự án OSS lớn. Chúng tôi yêu cầu người tham gia đánh giá xem các gợi ý giải quyết MergeBERT có thể chấp nhận được trên một tập hợp 122 xung đột thế giới thực của chính họ. Kết quả cho thấy các giải pháp hợp nhất MergeBERT sẽ được chấp nhận trong thực tế mặc dù không phải lúc nào cũng giống hệt với các giải pháp người dùng lịch sử về mặt cú pháp, và chúng tôi xác định các cách tiềm năng để cải thiện MergeBERT và các oracle xung đột hợp nhất được sử dụng để đánh giá các phương pháp hợp nhất chương trình neural.

Chúng tôi đóng góp như sau trong bài báo này:
(1) Chúng tôi giới thiệu MergeBERT, một framework hợp nhất chương trình dựa trên transformer mới tận dụng phân biệt ba chiều ở mức token và hình thành tác vụ tạo ra chuỗi giải quyết như một tác vụ phân loại.
(2) Chúng tôi đánh giá MergeBERT so với các công cụ hợp nhất chương trình có cấu trúc và bán cấu trúc như JSFSTMERGE và JDIME, cũng như các mô hình hợp nhất chương trình neural. Chúng tôi chứng minh rằng MergeBERT vượt trội hơn công nghệ tiên tiến, đạt được độ chính xác cao hơn 2-3× trong giải quyết hợp nhất.
(3) Chúng tôi trình bày một đánh giá thực nghiệm về nhận thức của các giải pháp MergeBERT với 25 nhà phát triển từ các dự án OSS lớn, đóng góp nghiên cứu người dùng đầu tiên trong đó các nhà phát triển sử dụng và đánh giá một công cụ giải quyết xung đột hợp nhất tự động trên các xung đột thế giới thực của chính họ.

Chúng tôi cung cấp một gói dữ liệu trực tuyến chứa tập dữ liệu kiểm tra các xung đột và giải pháp người dùng, cũng như các câu hỏi và phản hồi thu thập từ nghiên cứu người dùng của chúng tôi. Chúng tôi cũng cung cấp một Phụ lục trực tuyến với chi tiết bổ sung và hình ảnh (cũng được tải lên cùng với bài nộp này).

## 2 VÍ DỤ ĐỘNG LỰC
Chúng tôi sử dụng một số thuật ngữ, khái niệm và ý tưởng xuyên suốt bài báo này. Để cung cấp trực giác về cách phương pháp của chúng tôi hoạt động và định nghĩa cụ thể các thuật ngữ và khái niệm, chúng tôi bắt đầu với một ví dụ động lực về một xung đột hợp nhất nhỏ nhưng thực tế.

Hình 1 cung cấp một ví dụ xung đột hợp nhất trong JavaScript cho thấy kết quả của việc hợp nhất hai thay đổi đồng thời vào cùng một tệp JavaScript. Hình 1(a) bên trái cho thấy các dấu diff3 tiêu chuẩn "<<<<<<< A.js", "||||||| O.js", "=======" và ">>>>>>> B.js", phân định các vùng xung đột được giới thiệu bởi các chương trình A, cơ sở O và B tương ứng. Ở đây, O đại diện cho tổ tiên chung thấp nhất của các chương trình A và B trong lịch sử kiểm soát phiên bản. Chúng tôi ký hiệu văn bản chương trình của các vùng xung đột diff3 là 𝐴, 𝐵, 𝑂. Văn bản chương trình bên ngoài các vùng xung đột - tiền tố và hậu tố - là chung cho tất cả ba phiên bản chương trình. Thông thường các tệp xung đột có cùng tên trong các nhánh khác nhau, nhưng để tránh nhầm lẫn, chúng tôi đặt tên tệp gốc trong ví dụ của chúng tôi là O.js, và hai phiên bản được chỉnh sửa đồng thời của tệp này là A.js và B.js. A.js thay đổi "var x" thành "let x" và 10 thành 11, trong khi B.js thay đổi 10 thành 11 và cũng thêm một đối số z.

MergeBERT cố gắng tự động giải quyết xung đột hợp nhất trong hai giai đoạn. Đầu tiên, MergeBERT biểu diễn mỗi instance xung đột hợp nhất ở mức dòng tại mức token để bản địa hóa các vùng xung đột. Một cách trực quan, MergeBERT chuyển đổi ba văn bản nguồn có cấu trúc dòng thành ba chuỗi token (bao gồm dấu cách và dấu phân cách dòng), áp dụng thuật toán diff3 tiêu chuẩn cho các chuỗi token này, và sau đó tái tạo tài liệu được hợp nhất ở mức dòng. Hình 1(b) cho thấy kết quả của việc áp dụng hợp nhất ở mức token này trên Hình 1(a). Kết quả của hợp nhất ở mức token, toàn bộ chuỗi "let x = max(y," được hợp nhất sạch sẽ, trở thành một phần của tiền tố chương trình, và ")" được thêm vào trước hậu tố chương trình. Thứ hai, MergeBERT gọi một mô hình neural cơ bản để đề xuất giải pháp thông qua phân loại cho mỗi vùng xung đột ở mức token và thay thế vùng xung đột bằng gợi ý từ mô hình (Hình 1(c)).

Quan sát rằng giải pháp không bao gồm bất kỳ dòng đơn lẻ nào từ 𝐴 hoặc 𝐵 vì cả hai chỉnh sửa đều sửa đổi một dòng chung trong cơ sở. Do đó, các phương pháp neural trước đó như DeepMerge bị hạn chế chỉ chọn toàn bộ dòng từ vùng xung đột sẽ không thể cung cấp giải pháp. Mặt khác, các kỹ thuật hợp nhất có cấu trúc (như JSFSTMERGE) không thể giải quyết xung đột một cách đúng đắn vì xung đột xuất hiện trên một câu lệnh chương trình, dẫn đến tác dụng phụ (ví dụ mã không đúng cú pháp).

Hợp nhất ở mức token có thể xen kẽ các chỉnh sửa trong các dòng (tức là các token mà một chỉnh sửa không xung đột với chỉnh sửa khác được hợp nhất một cách tầm thường). Xem xét chỉnh sửa của A từ từ khóa var thành let. Những chỉnh sửa không xung đột như vậy đủ để chứng minh điều trên. diff3 ở mức token là một thuật toán hợp nhất cú pháp và do đó không thể đảm bảo tính đúng đắn về mặt ngữ nghĩa hoặc thậm chí cú pháp của chương trình được hợp nhất. Tuy nhiên, chúng tôi quan sát thấy trong thực tế, tính đúng đắn cú pháp được bảo toàn hầu hết thời gian (trên 97%).

Tương tự, xem xét xung đột ở mức token cho các đối số của hàm max: một mô hình thích hợp được huấn luyện trên JavaScript sẽ dễ dàng suy ra rằng việc lấy chỉnh sửa từ B (tức là "11, z") nắm bắt được hành vi của chỉnh sửa A. Giải pháp được đề xuất đưa ra một minh họa trực quan về cách MergeBERT biến một giải pháp ở mức dòng phức tạp thành một vấn đề phân loại ở mức token đơn giản hơn.

## 3 NỀN TẢNG: HỢP NHẤT DỰA TRÊN DỮ LIỆU
Dinella và cộng sự đã giới thiệu vấn đề hợp nhất chương trình dựa trên dữ liệu như một vấn đề học máy có giám sát. Một hợp nhất chương trình bao gồm một 4-tuple chương trình (A,B,O,M), trong đó:
(1) Chương trình cơ sở O là tổ tiên chung thấp nhất trong lịch sử phiên bản cho các chương trình A và B,
(2) diff3 tạo ra một xung đột không có cấu trúc ở mức dòng khi áp dụng cho (A,B,O), và
(3) M là chương trình được hợp nhất với giải pháp của nhà phát triển, kết hợp các thay đổi được thực hiện trong A và B.

Một hợp nhất có thể có nhiều xung đột không có cấu trúc, chúng tôi định nghĩa một tuple hợp nhất (𝐴,𝐵,𝑂,𝑀), trong đó 𝐴,𝐵,𝑂 tương ứng với các vùng xung đột trong A,B và O, tương ứng, và 𝑀 biểu thị vùng giải quyết. Cho một tập hợp các tuple hợp nhất (𝐴𝑖,𝐵𝑖,𝑂𝑖,𝑀𝑖), i = 0...N, mục tiêu của một thuật toán hợp nhất dựa trên dữ liệu là học một hàm, merge, để tối đa hóa ∑𝑁𝑖=0merge(𝐴𝑖,𝐵𝑖,𝑂𝑖) = 𝑀𝑖. Xuyên suốt văn bản, chúng tôi sẽ sử dụng ký hiệu (𝑎,𝑏,𝑜,𝑚) để tham chiếu đến các tuple hợp nhất ở mức token.

Dinella và cộng sự cũng cung cấp một thuật toán để trích xuất các vùng giải quyết chính xác cho mỗi tuple hợp nhất và định nghĩa một tập dữ liệu tương ứng với các giải pháp không tầm thường; các giải pháp mà nhà phát triển không bỏ các thay đổi từ một bên của hợp nhất. Hơn nữa, họ cung cấp một kiến trúc dựa trên bộ mã hóa-giải mã chuỗi-đến-chuỗi, trong đó một đơn vị tái phát cổng hai chiều (GRU) được sử dụng để mã hóa các đầu vào hợp nhất bao gồm các phân đoạn (𝐴,𝐵,𝑂) của một tuple hợp nhất, và một cơ chế con trỏ được sử dụng để hạn chế đầu ra chỉ chọn từ các phân đoạn dòng có mặt trong đầu vào. Bài báo của họ gặp phải hai hạn chế. Đầu tiên, do hạn chế chỉ sao chép các dòng từ đầu vào, tập dữ liệu của họ không xem xét các hợp nhất mà giải pháp yêu cầu xen kẽ ở mức token, như xung đột trong Hình 1. Thứ hai, tập dữ liệu của họ bao gồm các xung đột hợp nhất trong một ngôn ngữ duy nhất, cụ thể là JavaScript. Phương pháp của chúng tôi giải quyết cả hai hạn chế này.

## 4 GIẢI QUYẾT XUNG ĐỘT HỢP NHẤT NHƯ MỘT TÁC VỤ PHÂN LOẠI
Trong công trình này, chúng tôi chứng minh cách khai thác tính chất hạn chế của các giải pháp xung đột hợp nhất - so với một sửa chữa chương trình tùy ý - để tận dụng các mô hình phân biệt để tổng hợp chuỗi giải quyết hợp nhất. Chúng tôi đã quan sát thực nghiệm rằng việc áp dụng diff3 ở độ chi tiết token có hai thuộc tính hữu ích so với phần tương ứng ở mức dòng: (i) nó giúp bản địa hóa các xung đột hợp nhất thành các phân đoạn chương trình nhỏ, hiệu quả giảm kích thước của các vùng xung đột, và (ii) hầu hết các giải pháp của các xung đột hợp nhất được tạo ra bởi diff3 token bao gồm hoàn toàn các thay đổi từ 𝑎 hoặc 𝑏 hoặc 𝑜 hoặc một thành phần tuần tự của 𝑎 theo sau bởi 𝑏 hoặc ngược lại. Ở đây, và xuyên suốt bài báo chúng tôi sẽ sử dụng ký hiệu chữ thường để tham chiếu đến các thuộc tính của phân biệt ở mức token (ví dụ 𝑎,𝑏, và 𝑜 là các vùng xung đột được tạo ra bởi diff3 ở độ chi tiết token). Mặt khác, hợp nhất ở mức token có thể tạo ra nhiều xung đột nhỏ. Để cân bằng sự đánh đổi, chúng tôi bắt đầu với các xung đột ở mức dòng như được tạo ra bởi diff3 tiêu chuẩn và thực hiện hợp nhất ở mức token chỉ của các phân đoạn có mặt trong xung đột ở mức dòng. Có một số kết quả tiềm năng cho hợp nhất hai cấp như vậy ở mức dòng:

• Hợp nhất ở mức token không có xung đột: Ví dụ, chỉnh sửa từ 𝐴 về let được hợp nhất vì 𝐵 không chỉnh sửa slot đó như được hiển thị trong Hình 1(b).
• Một xung đột hợp nhất ở mức token được bản địa hóa duy nhất: Ví dụ, chỉnh sửa từ cả 𝐴 và 𝐵 cho các đối số của max tạo ra một xung đột duy nhất như được hiển thị trong Hình 1(b).
• Nhiều xung đột ở mức token: Trường hợp như vậy (không được minh họa ở trên) có thể dẫn đến một số xung đột ở mức token.

diff3 ở mức token áp dụng cho một 4-tuple chương trình (A,B,O,M), thường sẽ dẫn đến một tập hợp các tuple hợp nhất được bản địa hóa ⟨𝑎𝑗,𝑏𝑗,𝑜𝑗,𝑚𝑗⟩. Chúng tôi quan sát thực nghiệm rằng 74% các giải pháp 𝑚𝑗 như vậy bao gồm (𝑖) chính xác các token trong 𝑎𝑗 hoặc (𝑖𝑖) chính xác các token trong 𝑏𝑗. 0,4% khác của các giải pháp là (𝑖𝑖𝑖) chỉ các token trong 𝑜𝑗. Ngoài ra, 23% các giải pháp là kết quả của việc nối (𝑖𝑣) 𝑎𝑗 và 𝑏𝑗 hoặc (𝑣) 𝑏𝑗 và 𝑎𝑗. Cuối cùng, 1,8% bao gồm bốn biến thể khác, thu được bằng cách lấy 𝑖,𝑖𝑖,𝑖𝑣 và 𝑣 ở trên và loại bỏ các token cũng xảy ra trong cơ sở, 𝑜𝑗. Tổng cộng, điều này cung cấp chín mẫu giải quyết hợp nhất nguyên thủy (xem Phụ lục trực tuyến để biết thêm chi tiết về các mẫu hợp nhất nguyên thủy).

Do đó, chúng tôi coi vấn đề xây dựng các giải pháp xung đột hợp nhất 𝑚𝑗 như một tác vụ phân loại để dự đoán giữa các khả năng này. Điều quan trọng cần lưu ý là mặc dù chúng tôi đang dự đoán các chiến lược giải quyết đơn giản ở mức token, chúng có thể dịch thành các giải pháp phức tạp ở mức dòng. Ngoài ra, không phải tất cả xung đột đều được giải quyết bằng cách chia nhỏ xung đột đó thành token và áp dụng các mẫu này - một số giải pháp như những giải pháp giới thiệu token mới hoặc sắp xếp lại token không thể biểu đạt như một lựa chọn ở mức token.

## 5 MERGEBERT: FRAMEWORK HỢP NHẤT CHƯƠNG TRÌNH NEURAL
MergeBERT là một mô hình hợp nhất chương trình văn bản dựa trên mô hình mã hóa transformer hai chiều (BERT). Chúng tôi tham khảo độc giả đến CodeBERT để thảo luận về việc áp dụng transformer cho mã. Một transformer, giống như mạng neural tái phát, ánh xạ một chuỗi văn bản thành một biểu diễn chiều cao, sau đó có thể được giải mã để giải quyết các tác vụ downstream. Mặc dù không được thiết kế ban đầu cho mã, transformer đã tìm thấy nhiều ứng dụng trong kỹ thuật phần mềm.

MergeBERT tiếp cận giải quyết xung đột hợp nhất như một tác vụ phân loại chuỗi cho các vùng xung đột được trích xuất với phân biệt ở mức token và mã xung quanh như ngữ cảnh. Đổi mới kỹ thuật chính trong MergeBERT nằm ở cách nó chia văn bản chương trình thành một biểu diễn đầu vào phù hợp cho việc học với bộ mã hóa transformer và cách nó tổng hợp các mã hóa đầu vào khác nhau để phân loại.

Trong thiết lập học chuỗi tiêu chuẩn có một đầu vào và một chuỗi đầu ra duy nhất. Trong tác vụ giải quyết xung đột hợp nhất, có nhiều chương trình đầu vào xung đột và một giải pháp. Để hỗ trợ việc học trong thiết lập này, chúng tôi xây dựng MergeBERT như một mạng neural mã hóa đa đầu vào, trước tiên mã hóa các chuỗi token của các chương trình xung đột, sau đó tổng hợp chúng thành một trạng thái tóm tắt ẩn duy nhất.

Tổng quan về kiến trúc mô hình MergeBERT được hiển thị trong Hình 2. Cho các chương trình xung đột A,B và O, trước tiên chúng tôi thực hiện tokenization và sau đó lặp lại phân biệt ba chiều ở độ chi tiết token. Nếu một xung đột vẫn tồn tại trong phân biệt ba chiều ở mức token này, chúng tôi thu thập các chuỗi token tương ứng với các vùng xung đột 𝑎,𝑏 và 𝑜, và tính toán các căn chỉnh từng cặp của 𝑎 và 𝑏 với cơ sở 𝑜. Cuối cùng, cho mỗi cặp chuỗi token được căn chỉnh, chúng tôi trích xuất một "chuỗi chỉnh sửa" biểu diễn cách biến chuỗi thứ hai thành chuỗi thứ nhất. Các chuỗi token được căn chỉnh kết quả được đưa vào mạng neural mã hóa đa đầu vào, trong khi các chuỗi chỉnh sửa tương ứng được tiêu thụ như các embedding kiểu. Cuối cùng, các chuỗi token được mã hóa được tóm tắt thành một trạng thái ẩn phục vụ như đầu vào cho lớp phân loại.

Cho một 4-tuple chương trình (A,B,O,M) chứa các tuple hợp nhất ở mức token (𝑎𝑗,𝑏𝑗,𝑜𝑗,𝑚𝑗), j=0...N, MergeBERT mô hình hóa phân phối xác suất có điều kiện sau:

𝑝(𝑚𝑗|𝑎𝑗,𝑏𝑗,𝑜𝑗), (1)

và do đó, cho toàn bộ chương trình:

𝑝(M|A,B,O) = ∏𝑁𝑗=1 𝑝(𝑚𝑗|𝑎𝑗,𝑏𝑗,𝑜𝑗) (2)

Tính độc lập của các xung đột ở mức token là một giả định đơn giản hóa. Tuy nhiên, chúng tôi quan sát thấy trong tập dữ liệu của chúng tôi chỉ 5% xung đột hợp nhất dẫn đến nhiều hơn 1 xung đột ở mức token cho mỗi xung đột ở mức dòng.

### 5.1 Mã hóa Ngữ cảnh
Cho một tuple hợp nhất (𝑎,𝑏,𝑜,𝑚), MergeBERT tính toán hai căn chỉnh từng cặp giữa các chuỗi token của các vùng xung đột 𝑎 (tương ứng 𝑏) với vùng của chương trình gốc 𝑜: 𝑎|𝑜,𝑜|𝑎,𝑏|𝑜 và ��|𝑏. Cho mỗi cặp chuỗi token được căn chỉnh, chúng tôi tính toán một chuỗi chỉnh sửa. Các chuỗi chỉnh sửa này - ∆𝑎𝑜 và ∆𝑏𝑜 - bao gồm các hành động chỉnh sửa sau (các loại chỉnh sửa): = biểu diễn các token tương đương, + biểu diễn chèn, - biểu diễn xóa, ↔ biểu diễn thay thế, và ∅ được sử dụng như một token đệm. Tổng thể, điều này tạo ra bốn chuỗi token và hai chuỗi chỉnh sửa: (𝑎|𝑜,𝑜|𝑎 và ∆𝑎𝑜) và (𝑏|𝑜,𝑜|𝑏 và ∆𝑏𝑜). Hình 3 cung cấp một ví dụ về chuỗi chỉnh sửa. Mỗi chuỗi token bao phủ vùng xung đột tương ứng và có thể, các token mã xung quanh. Chúng tôi sử dụng tokenization không giám sát Byte-Pair Encoding (BPE) để tránh sự bùng nổ trong kích thước từ vựng do tính chất thưa thớt của các định danh mã. Để giúp mô hình học nhận biết các bước chỉnh sửa, chúng tôi giới thiệu một embedding kiểu chỉnh sửa. Chúng tôi kết hợp nó với các embedding token và vị trí tiêu chuẩn được sử dụng trong kiến trúc mô hình BERT thông qua phép cộng.

### 5.2 Tổng hợp Tuple Hợp nhất
Chúng tôi sử dụng mô hình mã hóa transformer E để mã hóa độc lập từng chuỗi trong bốn chuỗi token của các vùng xung đột ở mức token 𝑎|𝑜,𝑜|𝑎,𝑏|𝑜 và 𝑜|𝑏, truyền các chuỗi chỉnh sửa tương ứng ∆𝑎𝑜 và ∆𝑏𝑜 như các embedding kiểu. Cuối cùng, MergeBERT tổng hợp các mã hóa kết quả thành một trạng thái tóm tắt ẩn duy nhất ℎ:

(3) ℎ = ∑𝑥∈(𝑎|𝑜,𝑜|𝑎,𝑏|𝑜,𝑜|𝑏) 𝜃𝑥 · E(𝑥,∆𝑥)

trong đó E(𝑥,∆𝑥) là các tensor được mã hóa cho mỗi chuỗi 𝑥∈(𝑎|𝑜,𝑜|𝑎,𝑏|𝑜,𝑜|𝑏), và 𝜃𝑥 là các trọng số có thể học được. Sau tổng hợp, một lớp phân loại tuyến tính với softmax được áp dụng:

𝑝(𝑚𝑗|𝑎𝑗,𝑏𝑗,𝑜𝑗) = softmax(𝑊·ℎ+𝑏) (4)

Vùng giải quyết ở mức dòng kết quả được thu được bằng cách nối tiền tố, giải pháp ở mức token được dự đoán 𝑚𝑗 và hậu tố. Cuối cùng, trong trường hợp tương ứng một-nhiều giữa xung đột ở mức dòng gốc và các xung đột ở mức token (xem Phụ lục để biết thêm chi tiết và mã giả), MergeBERT sử dụng tìm kiếm chùm tiêu chuẩn để giải mã các dự đoán hứa hẹn nhất.

### 5.3 Chi tiết Triển khai
Chúng tôi sử dụng mô hình CodeBERT được pretrain với 6 lớp mã hóa, 12 đầu attention và kích thước trạng thái ẩn là 768. Từ vựng được xây dựng bằng byte-pair encoding và kích thước từ vựng là 50000. Chúng tôi chuyển các trọng số của bộ mã hóa transformer được pretrain vào mạng neural đa đầu vào MergeBERT, và gắn một lớp tuyến tính được khởi tạo ngẫu nhiên với softmax. Sau đó chúng tôi tinh chỉnh mạng neural kết quả trong thiết lập có giám sát cho tác vụ phân loại chuỗi. Các chuỗi đầu vào cho training tinh chỉnh bao phủ các vùng xung đột và mã xung quanh (tức là, các đoạn của tiền tố và hậu tố của vùng xung đột) lên đến độ dài tối đa 512 token BPE. Xương sống của triển khai chúng tôi là các lớp RobertaModel và RobertaForSequenceClassification của HuggingFace trong PyTorch, được sửa đổi để biến mô hình thành kiến trúc đa đầu vào được hiển thị trong Hình 2. Chúng tôi tinh chỉnh MergeBERT với bộ tối ưu hóa ngẫu nhiên Adam với sửa lỗi weight decay sử dụng tỷ lệ học 5e-5, kích thước batch 512 và 8 lần truyền ngược mỗi allreduce. Training tinh chỉnh được thực hiện trên 4 GPU NVIDIA Tesla V100 với bộ nhớ 16GB trong 6 giờ.

Trong giai đoạn suy luận, dự đoán mô hình cho mỗi xung đột ở mức dòng bao gồm một hoặc nhiều dự đoán ở mức token. Cho các dự đoán ở mức token và nội dung của tệp được hợp nhất, MergeBERT tạo ra mã tương ứng với vùng giải quyết. Nội dung của tệp được hợp nhất bao gồm xung đột đang xét và các vùng xung quanh của nó. Sau đó, MergeBERT kiểm tra cú pháp của mã được tạo ra với parser tree-sitter và chỉ xuất ra nó như giải pháp xung đột hợp nhất ứng viên nếu nó đúng cú pháp.

## 6 CÂU HỎI NGHIÊN CỨU
Chúng tôi đặt ra các câu hỏi nghiên cứu sau để đánh giá tính hiệu quả và tiện ích của MergeBERT.

**RQ 1**: MergeBERT hiệu quả như thế nào trong việc tạo ra các giải pháp xung đột hợp nhất? Chúng tôi đánh giá hiệu suất của MergeBERT trong việc tạo ra giải pháp về mặt độ chính xác và chính xác của việc khớp với giải pháp người dùng thực tế được trích xuất từ các giải pháp hợp nhất thế giới thực. Chúng tôi cũng cung cấp so sánh MergeBERT với các phương pháp baseline (ở cả mức dòng và token) và các phương pháp giải quyết hợp nhất tiên tiến.

**RQ 2**: MergeBERT hoạt động tốt như thế nào trên các ngôn ngữ khác nhau? Một trong những mục tiêu chính của chúng tôi là có thể làm việc trên nhiều ngôn ngữ với nỗ lực tối thiểu. Phương pháp cốt lõi của MergeBERT về cơ bản là bất khả tri ngôn ngữ (mặc dù cần một parser và tokenizer cho mỗi ngôn ngữ bổ sung). Chúng tôi đánh giá hiệu suất của MergeBERT trên bốn ngôn ngữ và cũng so sánh kết quả của việc sử dụng bốn mô hình dành riêng cho ngôn ngữ (mỗi mô hình được huấn luyện chỉ trên một ngôn ngữ) với việc sử dụng một mô hình đa ngôn ngữ được huấn luyện trên dữ liệu từ tất cả bốn ngôn ngữ.

**RQ 3**: Các lựa chọn khác nhau của mã hóa ngữ cảnh tác động như thế nào đến hiệu suất của MergeBERT? Chúng tôi tiến hành một nghiên cứu ablation về embedding kiểu chỉnh sửa để hiểu và đánh giá tác động của mã hóa nhận biết chỉnh sửa mới của chúng tôi lên hiệu suất mô hình.

**RQ 4**: Người dùng nhận thức các giải pháp MergeBERT như thế nào? Chúng tôi tiến hành một nghiên cứu người dùng bao gồm khảo sát các xung đột thế giới thực gần đây mà các nhà phát triển từ các dự án OSS lớn gặp phải. Để hiểu cách các nhà phát triển sẽ sử dụng MergeBERT trong thực tế, chúng tôi cung cấp cho họ một giao diện để khám phá các gợi ý giải quyết xung đột của MergeBERT liên quan đến mã xung đột gốc của họ và yêu cầu họ đánh giá các gợi ý và giải thích tại sao họ giải quyết đúng hoặc không đúng xung đột hợp nhất.

## 7 TẬP DỮ LIỆU
Tập dữ liệu tinh chỉnh được khai thác từ hơn 100.000 kho phần mềm nguồn mở trong nhiều ngôn ngữ lập trình với xung đột hợp nhất. Nó chứa các commit từ lịch sử git với chính xác hai cha, dẫn đến xung đột hợp nhất. Chúng tôi replay git merge trên hai cha để xem liệu nó có tạo ra bất kỳ xung đột nào không. Nếu không, chúng tôi bỏ qua hợp nhất khỏi tập dữ liệu của chúng tôi. Chúng tôi sử dụng phương pháp được giới thiệu bởi Dinella và cộng sự để trích xuất các vùng giải quyết - tuy nhiên, chúng tôi không hạn chế mình chỉ với các xung đột có ít hơn 30 dòng. Cuối cùng, chúng tôi trích xuất các xung đột ở mức token và nhãn phân loại giải quyết xung đột (được giới thiệu trong Mục 4) từ các xung đột và giải pháp ở mức dòng. Bảng 1 cung cấp tóm tắt tập dữ liệu tinh chỉnh.

**Bảng 1**: Số lượng xung đột hợp nhất trong tập dữ liệu.

| Ngôn ngữ lập trình | Tập phát triển | Tập kiểm tra |
|--------------------|----------------|---------------|
| C#                 | 27874          | 6969          |
| JavaScript         | 66573          | 16644         |
| TypeScript         | 22422          | 5606          |
| Java               | 103065         | 25767         |

Tập dữ liệu tinh chỉnh được chia thành tập phát triển và kiểm tra theo tỷ lệ 80/20 ngẫu nhiên ở mức tệp. Tập phát triển được chia thêm thành tập huấn luyện và validation theo tỷ lệ 80/20 ở mức xung đột hợp nhất.

## 8 ĐÁNH GIÁ

### 8.1 Chỉ số Đánh giá
Chúng tôi đánh giá hiệu suất tổng hợp giải pháp của MergeBERT về mặt độ chính xác và chính xác của khớp chuỗi (modulo khoảng trắng hoặc indentation) với giải pháp người dùng được trích xuất từ các giải pháp hợp nhất lịch sử thế giới thực. Phương pháp này khá hạn chế vì một giải pháp được đề xuất có thể khác với giải pháp người dùng thực tế chỉ bởi, chẳng hạn, thứ tự của các câu lệnh, mà về mặt ngữ nghĩa thì tương đương. Do đó, phương pháp đánh giá này đưa ra một giới hạn dưới của hiệu suất.

Chúng tôi đánh giá MergeBERT và so sánh nó với baseline và các phương pháp hiện có bằng hai chỉ số, precision tại top-k và accuracy tại top-k. Vì MergeBERT là một phương pháp neural, nó có thể cung cấp nhiều hơn một gợi ý, mà chúng tôi xếp hạng theo các xác suất dự đoán liên quan. Ngoài ra, vì chúng tôi lọc ra các gợi ý giải pháp không hợp lệ về mặt cú pháp, nó có thể không cung cấp gợi ý nào trong các trường hợp hiếm. Accuracy tại top-1 chỉ ra phần trăm tổng số xung đột mà MergeBERT tạo ra giải pháp đúng như gợi ý hàng đầu của nó. Precision tại top-1 chỉ ra tần suất (như một phần trăm) gợi ý hàng đầu đúng khi MergeBERT cung cấp bất kỳ gợi ý nào. Như một ví dụ cụ thể, nếu một công cụ tạo ra gợi ý giải pháp cho 50 trong số 100 xung đột và 40 gợi ý khớp với giải pháp người dùng lịch sử thực tế, thì precision sẽ là 80% (40/50), nhưng accuracy sẽ là 40% (40/100). Precision tại top-k chỉ ra tần suất giải pháp đúng được tìm thấy trong top-k gợi ý và Accuracy tại top-k tương tự. Khi "top-k" được bỏ qua khỏi tên chỉ số (ví dụ chỉ "Precision") thì k là 1.

### 8.2 Mô hình Baseline

#### 8.2.1 Baseline Mô hình Ngôn ngữ.
Các mô hình ngôn ngữ neural (LM) đã cho thấy hiệu suất tuyệt vời trong tạo ngôn ngữ tự nhiên, và đã được áp dụng thành công vào lĩnh vực mã nguồn. Chúng tôi xem xét mô hình ngôn ngữ transformer tạo sinh được pretrain cho mã (GPT-C) và tham khảo tính tự nhiên của phần mềm để xây dựng phương pháp baseline của chúng tôi cho tác vụ tổng hợp giải pháp hợp nhất. Chúng tôi thiết lập baseline sau: cho một xung đột ở mức dòng không có cấu trúc được tạo ra bởi diff3, chúng tôi lấy tiền tố mã nguồn chung hoạt động như ý định người dùng cho hợp nhất chương trình. Chúng tôi cố gắng tạo ra toàn bộ vùng giải quyết từng token một bằng beam search. Như một thí nghiệm ablation, chúng tôi lặp lại điều này cho các xung đột được tạo ra với thuật toán phân biệt ở mức token (Hình 1 hiển thị chi tiết về tiền tố và các vùng xung đột).

#### 8.2.2 DeepMerge: Mô hình Neural cho Xen kẽ.
Tiếp theo, chúng tôi xem xét DEEPMERGE: một mô hình chuỗi-đến-chuỗi dựa trên GRU hai chiều được tóm tắt trong mục 3. Nó học tạo ra vùng giải quyết bằng cách chọn từ các phân đoạn dòng có mặt trong đầu vào (xen kẽ dòng) với cơ chế con trỏ. Chúng tôi huấn luyện lại mô hình DEEPMERGE trên tập dữ liệu TypeScript của chúng tôi.

#### 8.2.3 JDIME.
Tìm kiếm một baseline mạnh hơn, chúng tôi xem xét JDIME, một công cụ hợp nhất dành riêng cho Java tự động điều chỉnh quá trình hợp nhất bằng cách chuyển đổi giữa các thuật toán hợp nhất có cấu trúc và không có cấu trúc. Hợp nhất có cấu trúc nhận biết cây cú pháp trừu tượng (AST) và tận dụng thông tin cú pháp để cải thiện độ chính xác khớp của các node xung đột. Chúng tôi sử dụng triển khai có sẵn công khai, và chạy JDime ở chế độ bán cấu trúc.

#### 8.2.4 jsFSTMerge.
Trindade Tavares và cộng sự đã triển khai JSFSTMERGE bằng cách thích ứng một ngữ pháp có sẵn cho JavaScript để giải quyết các hạn chế của FSTMERGE và sửa đổi thuật toán của nó. JSFSTMERGE cho phép một số loại node duy trì thứ tự tương đối của chúng (ví dụ, câu lệnh) trong khi những node khác có thể độc lập thứ tự (ví dụ, khai báo hàm) ngay cả khi chia sẻ cùng node cha. Đối với các trường hợp mà JSFSTMERGE tạo ra giải pháp không khớp với giải pháp người dùng, chúng tôi kiểm tra thủ công đầu ra để tương đương ngữ nghĩa (ví dụ, câu lệnh import được sắp xếp lại).

### 8.3 Kết quả

**RQ 1**: MergeBERT hiệu quả như thế nào trong việc tạo ra các giải pháp xung đột hợp nhất?

Để đánh giá MergeBERT, trước tiên chúng tôi so sánh nó với các phương pháp neural khác và với diff3. Để toàn diện, chúng tôi đánh giá ở cả mức token và mức dòng. Sau đó chúng tôi so sánh MergeBERT với các phương pháp hợp nhất có cấu trúc và bán cấu trúc dành riêng cho ngôn ngữ hiện đại.

**Bảng 2**: Kết quả đánh giá cho MergeBERT và các baseline neural khác nhau được tính cho các xung đột hợp nhất trong tập kiểm tra ngôn ngữ lập trình TypeScript. Bảng hiển thị các chỉ số precision và accuracy top-1.

| Phương pháp | Độ chi tiết | Precision | Accuracy |
|-------------|-------------|-----------|----------|
| LM          | Dòng        | 3.6       | 3.1      |
| DeepMerge   | Dòng        | 55.0      | 35.1     |
| diff3       | Token       | 82.4      | 36.1     |
| LM          | Token       | 49.7      | 48.1     |
| DeepMerge   | Token       | 64.5      | 42.7     |
| MergeBERT   | Token       | 69.1      | 68.2     |

Như được thấy trong Bảng 2, hiệu suất của các baseline mô hình ngôn ngữ trong tổng hợp giải pháp hợp nhất tương đối thấp, cho thấy giả thuyết tự nhiên không đủ để nắm bắt ý định của nhà phát triển khi hợp nhất chương trình. Điều này có lẽ không đáng ngạc nhiên cho khái niệm precision không dung thứ ngay cả một sự không khớp token duy nhất.

MergeBERT dựa trên hai thành phần cốt lõi: diff3 ở mức token và một mô hình transformer neural đa đầu vào. Thuật toán phân biệt ở mức token một mình cho precision top-1 cao 82,4%, với accuracy tương đối thấp chỉ 36,1% (tức là, nó không phải lúc nào cũng tạo ra gợi ý giải pháp, nhưng khi nó làm, nó thường đúng). Kết hợp với mô hình transformer neural, accuracy được tăng lên tổng cộng 68,2%. Lưu ý, như một thuật toán xác định, diff3 ở mức token chỉ có thể cung cấp một gợi ý duy nhất.

Precision tổng hợp giải pháp hợp nhất của DeepMerge khá đáng ngưỡng mộ, hiển thị precision top-1 55,0%. Tuy nhiên, nó thất bại trong việc tạo ra dự đoán cho các xung đột hợp nhất không thể biểu diễn như xen kẽ dòng. Loại xung đột hợp nhất này chỉ bao gồm khoảng một phần ba của tập kiểm tra, dẫn đến accuracy chỉ 35,1% thấp hơn đáng kể so với MergeBERT.

Như một thí nghiệm, chúng tôi cũng đánh giá mô hình DeepMerge kết hợp với diff3 ở mức token. Điều này cho phép DeepMerge vượt qua hạn chế chỉ cung cấp giải pháp bao gồm xen kẽ dòng từ vùng xung đột bằng cách xen kẽ token thay thế. Như được thấy trong Bảng 2 (DeepMerge với độ chi tiết Token), accuracy tổng thể cải thiện từ 35,1% lên 42,7%. Tuy nhiên điều này vẫn kém hơn MergeBERT với precision thấp hơn 5% (64,5% so với 69,1%) và accuracy thấp hơn 25% (42,7% so với 68,2%).

Chúng tôi cũng so sánh MergeBERT với các công cụ hợp nhất có cấu trúc và bán cấu trúc tiên tiến. Vì cả JDIME và JSFSTMERGE đều dành riêng cho ngôn ngữ, để so sánh với MergeBERT, chúng tôi sử dụng tập con dành riêng cho ngôn ngữ tương ứng của tập dữ liệu các xung đột của chúng tôi (dẫn đến kết quả hơi khác cho MergeBERT trên Java và JavaScript).

Như có thể thấy từ Bảng 3, JSFSTMERGE chỉ tạo ra giải pháp cho 22,8% xung đột và khi giải pháp được tạo ra bởi JSFSTMERGE, nó chỉ đúng 15,8% thời gian, mang lại accuracy tổng cộng 3,6%. Điều này phù hợp với kết luận của những người tạo ra JSFSTMERGE rằng các phương pháp hợp nhất bán cấu trúc có thể không có lợi cho các ngôn ngữ scripting động. Vì JSFSTMERGE có thể tạo ra mã được định dạng lại, chúng tôi kiểm tra thủ công các trường hợp mà giải pháp được tạo ra nhưng không khớp với giải pháp người dùng (oracle của chúng tôi). Nếu giải pháp được tạo ra tương đương ngữ nghĩa với giải pháp người dùng, chúng tôi phân loại nó là đúng.

**Bảng 3**: So sánh MergeBERT với các công cụ hợp nhất bán cấu trúc JDIME và JSFSTMERGE. Bảng hiển thị phần trăm xung đột mà công cụ tạo ra giải pháp, precision top-1 của các giải pháp được tạo ra, và accuracy top-1 tổng thể của tổng hợp giải pháp hợp nhất. Đánh giá JDIME trên tập dữ liệu Java và JSFSTMERGE trên tập dữ liệu JavaScript.

| Phương pháp | Ngôn ngữ   | % xung đột có giải pháp | Precision | Accuracy |
|-------------|------------|-------------------------|-----------|----------|
| JDIME       | Java       | 82.1                    | 26.3      | 21.6     |
| MergeBERT   | Java       | 98.9                    | 63.9      | 63.2     |
| JSFSTMERGE  | JavaScript | 22.8                    | 15.8      | 3.6      |
| MergeBERT   | JavaScript | 98.1                    | 66.9      | 65.6     |

Để so sánh accuracy của JDIME với MergeBERT, chúng tôi sử dụng tập dữ liệu Test Java được giới thiệu trước đó và hoàn thành các bước đánh giá sau: JDIME không hợp nhất tất cả xung đột và tạo ra giải pháp cho 82,1% xung đột. Điều này phù hợp với nghiên cứu liên quan báo cáo rằng lên đến 21% tệp không thể được hợp nhất. Do đó, đầu tiên, chúng tôi xác định tập hợp các kịch bản xung đột hợp nhất mà diff3 báo cáo xung đột và JDIME tạo ra hợp nhất không xung đột. Khi so sánh đầu ra JDIME với giải pháp xung đột hợp nhất lịch sử thực tế do người dùng thực hiện, chúng tôi không sử dụng khớp cú pháp đơn giản. Kết quả của phương pháp khớp AST, mã được tạo ra bởi JDIME được định dạng lại, và thứ tự gốc của các câu lệnh và cấu trúc khác không phải lúc nào cũng được bảo toàn. Trong nỗ lực xác định chính xác và công bằng các hợp nhất tương đương ngữ nghĩa, chúng tôi sử dụng GumTree, một công cụ phân biệt AST, để xác định và bỏ qua các khác biệt tương đương ngữ nghĩa giữa đầu ra JDIME và giải pháp người dùng, như khai báo method được sắp xếp lại. Khi JDIME tạo ra giải pháp, nó tạo ra khớp tương đương ngữ nghĩa 26,3% thời gian, với accuracy 21,6%.

**RQ 2**: MergeBERT hoạt động tốt như thế nào trên các ngôn ngữ khác nhau?

Một mục tiêu của phương pháp chúng tôi là có thể xử lý nhiều ngôn ngữ với nỗ lực tối thiểu. Để MergeBERT có thể cung cấp gợi ý giải pháp hợp nhất cho các xung đột trong một ngôn ngữ cụ thể, nó cần ba thứ. Đầu tiên, một tokenizer trong ngôn ngữ đó, cho phép chúng tôi chia văn bản nguồn thành token để xử lý. Thứ hai, một parser trong ngôn ngữ đó, cho phép chúng tôi lọc ra các gợi ý giải pháp hợp nhất không đúng cú pháp. Thứ ba, một tập dữ liệu các xung đột hợp nhất và giải pháp người dùng của chúng để huấn luyện MergeBERT. May mắn thay, tokenizer và parser cho gần như bất kỳ ngôn ngữ nào đều dễ dàng có sẵn (ví dụ, chúng tôi sử dụng tree-sitter của GitHub cho điều này) và các kho sử dụng ngôn ngữ cụ thể có thể dễ dàng được xác định (ví dụ trên GitHub) và khai thác để tìm xung đột và giải pháp.

Chúng tôi đã tích hợp tokenizer và parser vào MergeBERT cho JavaScript, TypeScript, Java và C# và thu thập dữ liệu xung đột hợp nhất cho các ngôn ngữ này như đã mô tả trước đó. Lưu ý rằng cả comment và string trong các ngôn ngữ này đều được biểu diễn như token đơn và có thể khá dài. Do đó chúng tôi chia thêm các token này trên khoảng trắng. Bảng 4 hiển thị kết quả đánh giá chi tiết của MergeBERT được chia theo ngôn ngữ. Phần kết quả trên cùng hiển thị hiệu suất khi MergeBERT được huấn luyện trên dữ liệu cho ngôn ngữ cụ thể đó. Phần dưới hiển thị hiệu suất cho mỗi ngôn ngữ khi MergeBERT được huấn luyện trên tập dữ liệu bao gồm dữ liệu cho tất cả ngôn ngữ (chúng tôi gọi đây là mô hình đa ngôn ngữ). Lưu ý rằng đối với các mô hình dành riêng cho ngôn ngữ, hiệu suất khá nhất quán trên tất cả bốn ngôn ngữ với Precision Top-1 từ 63,9% đến 69,1% và Accuracy Top-1 từ 63,2% đến 68,2%. Chúng tôi cũng thấy rằng hơn 97% gợi ý MergeBERT đúng cú pháp trên tất cả ngôn ngữ lập trình.

**Bảng 4**: Kết quả đánh giá chi tiết cho (trên) các mô hình đơn ngôn ngữ JavaScript, TypeScript, Java và C#, và (dưới) mô hình MergeBERT đa ngôn ngữ được huấn luyện trên tất cả bốn ngôn ngữ lập trình. Bảng hiển thị precision và accuracy của tổng hợp giải pháp hợp nhất.

| Ngôn ngữ Test (Train)      | Precision      | Accuracy       |
|                           | Top-1 | Top-3 | Top-1 | Top-3 |
|---------------------------|-------|-------|-------|-------|
| JavaScript (JS)           | 66.9  | 75.4  | 65.6  | 73.9  |
| TypeScript (TS)           | 69.1  | 76.6  | 68.2  | 75.6  |
| Java (Java)               | 63.9  | 76.1  | 63.2  | 75.2  |
| C# (C#)                   | 68.7  | 76.4  | 67.3  | 74.8  |
| JavaScript (JS,TS,C#,Java)| 66.6  | 75.2  | 65.3  | 73.8  |
| TypeScript (JS,TS,C#,Java)| 68.5  | 76.8  | 67.6  | 75.8  |
| Java (JS,TS,C#,Java)      | 63.6  | 76.0  | 62.9  | 75.1  |
| C# (JS,TS,C#,Java)        | 66.3  | 76.2  | 65.1  | 74.8  |

Chúng tôi không có kỳ vọng trước về hiệu suất của mô hình đa ngôn ngữ, vì nó được huấn luyện trên nhiều dữ liệu hơn, có thể dẫn đến cải thiện, nhưng nó không dành riêng cho ngôn ngữ, có thể dẫn đến kết quả kém hơn. Nhìn chung, biến thể đa ngôn ngữ của mô hình tạo ra kết quả chỉ hơi thấp hơn các phiên bản đơn ngôn ngữ. Do đó hiệu suất trên một ngôn ngữ không được cải thiện bằng cách thêm nhiều dữ liệu hơn trong các ngôn ngữ khác. Do đó, từ góc độ thực dụng, nếu ai đó chọn đơn giản hóa việc sử dụng MergeBERT bằng cách huấn luyện chỉ một mô hình thay vì một mô hình cho mỗi ngôn ngữ, thì hiệu suất chỉ bị ảnh hưởng không đáng kể.

**RQ 3**: Các lựa chọn khác nhau của mã hóa ngữ cảnh tác động như thế nào đến hiệu suất của MergeBERT?

Chúng tôi tiến hành một nghiên cứu ablation về embedding kiểu chỉnh sửa để hiểu tác động của việc nhận biết chỉnh sửa trong mã hóa lên hiệu suất mô hình. Như được hiển thị trong Bảng 5, việc sử dụng embedding kiểu chỉnh sửa cải thiện MergeBERT từ 63% lên 68%.

**Bảng 5**: Kết quả đánh giá cho MergeBERT và biến thể mô hình không có embedding kiểu chỉnh sửa cho các xung đột hợp nhất trong tập kiểm tra ngôn ngữ lập trình TypeScript. Bảng hiển thị các chỉ số precision và accuracy top-1.

| Phương pháp                      | Precision | Accuracy |
|----------------------------------|-----------|----------|
| Không có embedding kiểu chỉnh sửa| 65.2      | 63.1     |
| MergeBERT với embedding kiểu     | 69.1      | 68.2     |

## 9 ĐÁNH GIÁ NGƯỜI DÙNG

### 9.1 Thiết kế Nghiên cứu Người dùng

Để hiểu rõ hơn cách MergeBERT hoạt động trong thực tế, chúng tôi hỏi các nhà phát triển về các xung đột mà MergeBERT không thể giải quyết đúng. Vì các gợi ý giải pháp của MergeBERT được đánh giá so với giải pháp người dùng bằng khớp chuỗi từng từ (modulo khoảng trắng), việc yêu cầu người tham gia nghiên cứu xác nhận các giải pháp giống hệt được dự đoán bởi MergeBERT không mang tính thông tin. Do đó, chúng tôi trích xuất các xung đột mà gợi ý MergeBERT không khớp trực tiếp với giải pháp người dùng để xác định các hạn chế của gợi ý là gì, và cách chúng có thể được nhận thức trong thực tế.

Để xây dựng oracle các xung đột hợp nhất và giải pháp, chúng tôi xác định 8 dự án nguồn mở được lưu trữ trên GitHub. Các dự án được chọn đang hoạt động, với nhiều người đóng góp, và chứa một số lượng lớn kịch bản xung đột trong một trong các ngôn ngữ được MergeBERT hỗ trợ. Bảng 6 chứa danh sách các dự án được chọn. Đối với mỗi dự án, chúng tôi thực hiện các bước tương tự được nêu trong Mục 7 để trích xuất các xung đột ứng viên và giải pháp người dùng để sử dụng trong khảo sát.

Hình 4 giải thích phương pháp được sử dụng để xác định các xung đột hợp nhất ứng viên. Chúng tôi xác định tập hợp các xung đột mà MergeBERT không thể hợp nhất đúng (trong top-3 gợi ý). Từ tập hợp xung đột này, chúng tôi xác định các xung đột ứng viên để sử dụng như một phần của nghiên cứu người dùng. Chúng tôi lọc các tệp ứng viên với các tiêu chí sau:

(1) Xung đột nên được giải quyết gần đây tức là, tối đa trong vòng 12 tháng qua. Người tham gia có thể không giữ lại ngữ cảnh cần thiết để đánh giá gợi ý cho các xung đột cũ hơn.
(2) Tệp phải có nhiều nhất 4 xung đột. Người tham gia đánh giá lên đến 3 gợi ý cho mỗi xung đột. Nhiều xung đột hơn có thể quá phức tạp để đánh giá trong khoảng thời gian phỏng vấn.
(3) Xung đột nên không tầm thường. Các xung đột tầm thường, như những xung đột chỉ liên quan đến thay đổi định dạng hoặc đổi tên, được loại trừ thủ công. Việc xác định xem xung đột có tầm thường hay không là thủ công và chủ quan, được thông báo bởi niềm tin của chúng tôi rằng các xung đột thực chất hơn sẽ dẫn đến nhiều insights hơn trong nghiên cứu người dùng.

**Bảng 6**: Tóm tắt các dự án trong nghiên cứu người dùng, tổng số xung đột cho mỗi dự án, số xung đột được đánh giá trong nghiên cứu, và các người tham gia khảo sát.

| Ngôn ngữ | Dự án            | Xung đột | Xung đột khảo sát | Người tham gia |
|----------|------------------|----------|-------------------|----------------|
| Java     | Azure-Cosmosdb   | 341      | 6                 | P1             |
|          | Azure-SDK        | 997      | 14                | P2-4           |
|          | ApplicationInsights | 313   | 10                | P5-6           |
| TS       | MakeCode         | 106      | 12                | P7-8           |
|          | VSCode           | 2256     | 48                | P9-17          |
| C#       | AspNetCore       | 567      | 11                | P18-19         |
|          | EFCore           | 397      | 7                 | P20-21         |
|          | Roslyn           | 1894     | 14                | P22-25         |
| Tổng     | 8 dự án          | 6871     | 122               | 25             |

Đối với mỗi xung đột ứng viên được xác định, chúng tôi sử dụng GitHub API để xác định tác giả cho mỗi nhánh xung đột và tệp được giải quyết. Các tác giả có ít nhất 3 xung đột hợp nhất ứng viên được xác định như những người tham gia khảo sát tiềm năng. Pool cuối cùng của các ứng viên tham gia bao gồm 52 tác giả duy nhất. Chúng tôi tuyển dụng người tham gia qua email, sử dụng thông tin liên lạc trên GitHub. Trong số 52 nhà phát triển được liên lạc, 25 đồng ý tham gia nghiên cứu. Tất cả người tham gia đều là nhà phát triển phần mềm chuyên nghiệp với ít nhất 2-8 năm kinh nghiệm làm việc tại các công ty công nghệ lớn. Chúng tôi yêu cầu người tham gia đánh giá gợi ý giải pháp MergeBERT cho các xung đột hợp nhất của chính họ. Bảng 6 chứa số lượng cuối cùng của người tham gia và xung đột được đánh giá trong nghiên cứu của chúng tôi. 122 xung đột được đánh giá: 32 xung đột C#, 30 Java và 60 Typescript.

#### 9.1.1 Giao diện MergeBERT.
Chúng tôi thiết kế một giao diện trực tuyến nơi người tham gia có thể xem các xung đột của chính họ và khám phá các gợi ý giải pháp của MergeBERT. Người tham gia được yêu cầu đánh giá các xung đột hợp nhất được giải quyết gần đây của chính họ, và các gợi ý giải pháp tương ứng được tạo ra bởi MergeBERT. Giao diện được tùy chỉnh dựa trên người tham gia đăng nhập và hiển thị danh sách các xung đột hợp nhất gần đây mà họ gặp phải. Người tham gia có thể nhấp qua các gợi ý giải pháp khác nhau để đánh giá xem chúng có phải là cách chấp nhận được để giải quyết xung đột hợp nhất hay không. Họ có thể xem giải pháp gốc của mình trên cùng một trang, và nếu cần, người tham gia có thể điều hướng đến commit xung đột trên GitHub bằng một liên kết nếu họ cần ngữ cảnh bổ sung. Họ cũng có thể xem diff giữa tệp xung đột và bất kỳ tùy chọn nào được chọn (gợi ý giải pháp hoặc giải pháp người dùng). Người tham gia sử dụng giao diện này để chọn một hoặc nhiều giải pháp được đề xuất, chỉ ra xem giải pháp được đề xuất có thể chấp nhận được hay không, và giải thích lý do tại sao có hoặc không. Gói dữ liệu trực tuyến và phụ lục của chúng tôi chứa các câu hỏi, hình ảnh của giao diện và phản hồi của người tham gia.

#### 9.1.2 Giao thức.
Nghiên cứu người dùng được tiến hành như các cuộc phỏng vấn 30 phút từ xa qua Microsoft Teams sử dụng giao diện chúng tôi xây dựng. Đầu tiên, người tham gia xem video giải thích MergeBERT và cách điều hướng xung đột và đánh giá gợi ý giải pháp bằng giao diện. Sau đó, người tham gia đánh giá một tập hợp xung đột và gửi phản hồi của họ. Một trong các tác giả có mặt trong cuộc gọi teams để giúp người tham gia điều hướng giao diện và đặt bất kỳ câu hỏi làm rõ nào dựa trên đánh giá của họ về gợi ý giải pháp MergeBERT. Các câu hỏi được phát triển lặp đi lặp lại dựa trên hai cuộc phỏng vấn thí điểm. Mỗi cuộc phỏng vấn được ghi âm để phiên âm và phân tích.

### 9.2 Kết quả Nghiên cứu Người dùng

**RQ 4**: Người dùng nhận thức các giải pháp MergeBERT như thế nào?

Sử dụng giao diện, người tham gia đánh giá các gợi ý giải pháp xung đột được tạo ra bởi MergeBERT và chỉ ra xem bất kỳ gợi ý nào có thể chấp nhận được hay không, và giải thích tại sao có hoặc không. Không có sự khác biệt đáng chú ý trong phản hồi của người tham gia trên các ngôn ngữ hoặc dự án khác nhau nên chúng tôi không chia nhỏ kết quả theo các chiều đó. Đánh giá của người tham gia về các gợi ý hợp nhất thường rơi vào ba loại: 1) gợi ý hợp nhất đúng và sẽ được sử dụng để giải quyết xung đột 2) hợp nhất không đúng nhưng giải pháp đúng sẽ yêu cầu hiểu biết về ngữ cảnh bên ngoài và 3) hợp nhất không đúng và không cần ngữ cảnh bên ngoài.

#### 9.2.1 Gợi ý Hợp nhất Chấp nhận được.
Đáng ngạc nhiên, trong số 122 xung đột được bao gồm trong nghiên cứu, người tham gia chỉ ra rằng ít nhất một trong 3 gợi ý được tạo ra bởi MergeBERT đúng cho 54% (66/122) ví dụ. Theo thiết kế, các gợi ý được trình bày trong nghiên cứu không tương đương cú pháp với giải pháp gốc của người tham gia, tuy nhiên, họ vẫn chỉ ra rằng gợi ý là một hợp nhất đúng. Sử dụng phản hồi của người tham gia, chúng tôi xác định một số lý do tại sao gợi ý hợp nhất có thể chấp nhận được đối với nhà phát triển, ngay cả khi nó không tương đương cú pháp với giải pháp gốc của họ:

**Giải pháp Tương đương Ngữ nghĩa (54 trong số 122 xung đột)**
Các giải pháp tương đương ngữ nghĩa bao gồm các kịch bản mà các câu lệnh được sắp xếp lại, thay đổi tương đương được thực hiện đối với đặt tên hoặc tài liệu, và các câu lệnh import không cần thiết hoặc mã được comment out được bảo toàn hoặc loại bỏ.

Một ví dụ trong nghiên cứu về các thay đổi xung đột đều có thể chấp nhận được, và một được chấp nhận tùy ý bởi tác giả giải quyết là khi các tác giả của các nhánh xung đột đổi tên cùng một biến với một biến thể nhỏ: SPAN_TARGET_ATTRIBUTE_NAME và SPAN_TARGET_APP_ID_ATTRIBUTE_NAME. Trong những trường hợp này, phiên bản nào được chọn bởi thuật toán hợp nhất vẫn có thể chấp nhận được đối với nhà phát triển. MERGEBERT tạo ra gợi ý giữ tên biến SPAN_TARGET_ATTRIBUTE_NAME trong khi giải pháp người dùng ban đầu giữ tên kia. Người tham gia P5 đánh dấu giải pháp này là chấp nhận được và tương đương ngữ nghĩa, giải thích rằng trong kịch bản này họ 'không có sở thích nào tốt hơn'.

**Takeaway 1**: Đánh giá hiệu suất của MergeBERT bằng các phương pháp cú pháp nghiêm ngặt ước tính giới hạn dưới của hiệu suất. Kết quả khảo sát cho thấy gần 45% gợi ý MergeBERT là các hợp nhất chấp nhận được tương đương ngữ nghĩa với giải pháp gốc của người tham gia. Hiệu suất của MergeBERT có thể được cải thiện bằng cách xem xét thông tin ngữ nghĩa, ví dụ, để xác định cách các thay đổi liên quan đến đặt tên hoặc tài liệu nên được hợp nhất.

**Thay đổi Mã Rối trong Oracle (10/122)**
Giải pháp cho 10 xung đột chứa các thay đổi "rối" bổ sung không liên quan đến giải pháp. Ví dụ bao gồm đổi tên một method và thêm một biến trong vùng xung đột sau đó được sử dụng sau bên ngoài vùng xung đột. Trong tất cả 10 trường hợp, MERGEBERT tạo ra gợi ý không bao gồm mã rối bổ sung, nhưng có thể chấp nhận được đối với người tham gia như một giải pháp của xung đột. Người tham gia chỉ ra rằng nếu họ có quyền truy cập vào gợi ý MERGEBERT, họ sẽ chọn giải pháp đúng và sau đó thêm mã bổ sung thủ công.

**Takeaway 2**: Khi commit mã được hợp nhất, các nhà phát triển có thể đưa vào các thay đổi không liên quan đến xung đột mà vô tình được bao gồm trong các oracle giải pháp xung đột. Những thay đổi này có thể tác động tiêu cực đến hiệu suất mô hình được ước tính với các chỉ số tự động.

#### 9.2.2 Hợp nhất Yêu cầu Ngữ cảnh Bên ngoài.
MERGEBERT không tạo ra gợi ý chấp nhận được cho 46% (56/122) ví dụ được hiển thị cho người tham gia khảo sát. Người tham gia được yêu cầu chỉ ra xem họ có giải quyết những ví dụ này bằng ngữ cảnh bên ngoài không thể suy ra từ các vùng tệp xung đột hay không và giải thích ngữ cảnh bên ngoài đó là gì. Kết quả chỉ ra rằng 16% (20/122) xung đột trong mẫu khảo sát yêu cầu thông tin bên ngoài không được tìm thấy trong tệp xung đột nào, để được giải quyết đúng. Một ví dụ về ngữ cảnh bên ngoài là kiến thức về các quy tắc linter được bật ở cấp dự án. Các dự án thường yêu cầu kiểm tra linter trước khi mã có thể được commit vào kho, như một bước hướng tới cải thiện chất lượng và khả năng bảo trì của mã nguồn. Một ví dụ là xung đột hợp nhất từ Roslyn nơi giải pháp đúng là loại bỏ kiểm tra null khỏi mã. Người tham gia P23 giải thích quyết định loại bỏ kiểm tra: "Tham số previousResults không thể null vì kiểm tra nullability C# hiện được bật ở cấp dự án. Kiểm tra null là không cần thiết". Trong kịch bản này, không có kiến thức cụ thể về kiểm tra linter, một phương pháp tự động không thể dự đoán hợp nhất chính xác.

Một ví dụ khác về ngữ cảnh bên ngoài là cập nhật quy tắc ngôn ngữ có tác động lan tỏa lên mã hiện có. Người tham gia P22 từ dự án Roslyn giải thích một xung đột như vậy: "Thay đổi là do cập nhật trong quy tắc 'using' cho ngôn ngữ C#". Cập nhật ngôn ngữ trong C# phiên bản 8.0 đã giới thiệu cú pháp thay thế cho câu lệnh using và nhóm của P22 đã quyết định áp dụng cú pháp này. Do đó P22 đã cập nhật mã này (liên quan đến xung đột) trong quá trình hợp nhất. Các ví dụ khác về ngữ cảnh bên ngoài được xác định thông qua khảo sát bao gồm: loại bỏ các phụ thuộc toàn cục từ các tệp không xung đột trong dự án, rollback các tính năng không nên được bao gồm trong nhánh phát hành, và quyết định cấp dự án để loại bỏ modifier 'final' cho các biến.

**Takeaway 3**: Cái nhìn cục bộ của xung đột đủ để hợp nhất phần lớn xung đột. Khoảng 16% xung đột yêu cầu thông tin bên ngoài để giải quyết đúng. Một hướng để cải thiện MergeBERT là xem xét ngữ cảnh bên ngoài như một nguồn thông tin bổ sung để giải quyết xung đột.

#### 9.2.3 Gợi ý Hợp nhất Không thể Chấp nhận được.
Kết quả khảo sát cho thấy gợi ý MERGEBERT không đúng cho 29% (36/122) xung đột. Người tham gia chỉ ra rằng không có xung đột nào trong 36 xung đột yêu cầu ngữ cảnh bên ngoài để được giải quyết. Chúng tôi phân tích thủ công các xung đột tìm kiếm để xác định các mẫu có thể giải thích các hợp nhất không đúng, ví dụ, cấu trúc ngôn ngữ bị ảnh hưởng và loại xung đột, nhưng không xác định được bất kỳ mẫu nhất quán nào. Tóm lại, các chiến lược đánh giá tự động hiện có ước tính giới hạn dưới của hiệu suất phương pháp: gợi ý MergeBERT đúng cho 54% xung đột được bao gồm trong mẫu của chúng tôi, mặc dù không tương đương cú pháp với giải pháp người dùng. Hơn nữa, gợi ý từ MergeBERT đã giúp hai người tham gia tìm ra lỗi trong giải pháp xung đột hợp nhất gần đây của chính họ! Điều này ngoài những giải pháp mà MergeBERT cung cấp khớp chính xác. Phát hiện này cho thấy rằng các kỹ thuật đánh giá tự động dựa vào so sánh cú pháp nghiêm ngặt giữa giải pháp người dùng và gợi ý hợp nhất có thể đang ước tính giới hạn dưới thấp hơn nhiều của hiệu suất. Điều này làm nổi bật sự khác biệt giữa cách các phương pháp thường được đánh giá tự động, và cách các nhà phát triển có thể đánh giá một phương pháp trong thực tế. Các nhà nghiên cứu nên xem xét tiến hành nghiên cứu người dùng để đánh giá chính xác hơn các phương pháp khi khả thi. Các công cụ như MergeBERT có thể giảm nỗ lực và xu hướng lỗi liên quan đến việc hợp nhất xung đột thủ công. Các nghiên cứu tương lai nên điều tra những lợi ích tiềm năng này.

### 9.3 Công trình Liên quan

Đã có nhiều nỗ lực cải thiện các thuật toán hợp nhất bằng cách hạn chế chúng vào một ngôn ngữ lập trình cụ thể hoặc một loại ứng dụng cụ thể. Thông thường, những nỗ lực như vậy dẫn đến các thuật toán không mở rộng tốt hoặc có độ bao phủ thấp. Các thuật toán hợp nhất cú pháp cải thiện diff3 bằng cách xác minh tính đúng đắn cú pháp của các chương trình được hợp nhất. Một số kỹ thuật hợp nhất chương trình cú pháp đã được đề xuất dựa trên parse tree hoặc AST và đồ thị.

Apel và cộng sự lưu ý rằng hợp nhất có cấu trúc và không có cấu trúc mỗi cái đều có điểm mạnh và điểm yếu. Họ phát triển FSTMERGE, một hợp nhất bán cấu trúc, luân phiên giữa các phương pháp. Tavares và cộng sự triển khai JSFSTMERGE bằng cách thích ứng ngữ pháp có sẵn cho JavaScript để giải quyết các hạn chế của FSTMERGE và cũng sửa đổi chính thuật toán FSTMERGE. Cavalcanti và cộng sự thực hiện đánh giá hồi tưởng quy mô lớn của hợp nhất bán cấu trúc trên hơn 30.000 hợp nhất và thấy rằng nó vẫn có thể gặp phải false negative, các trường hợp thực tế có xung đột ngữ nghĩa nhưng phương pháp hợp nhất tạo ra giải pháp (không đúng). Họ cải thiện FSTMERGE bằng cách thêm "handler" kiểm tra các trường hợp false negative phổ biến (ví dụ đổi tên, thêm tham chiếu đến các phần tử được sửa đổi) loại bỏ hoàn toàn những trường hợp này. Leßenich lưu ý rằng việc sử dụng biểu diễn AST hoạt động tốt cho hợp nhất, nhưng phân biệt là NP-hard do đổi tên và mã được dịch chuyển. Họ đề xuất một phương pháp để cải thiện hiệu suất của thuật toán JDIME với chi phí tối thiểu. Dinella và cộng sự sử dụng phương pháp dựa trên dữ liệu cho vấn đề giải quyết xung đột hợp nhất và giới thiệu DEEPMERGE, một mạng neural sâu sử dụng kiến trúc mạng con trỏ để xây dựng giải pháp từ các dòng trong các phiên bản đầu vào khác nhau của mã.

Cuối cùng, Sousa và cộng sự khám phá việc sử dụng xác minh chương trình để chứng nhận rằng một hợp nhất tuân theo tiêu chí đúng đắn ngữ nghĩa, nhưng không giúp tổng hợp giải pháp. Mặt khác, Pan và cộng sự khám phá việc sử dụng tổng hợp chương trình để học các giải pháp hợp nhất lặp đi lặp lại trong một dự án. Tuy nhiên, phương pháp bị hạn chế vào một dự án C++ duy nhất, và chỉ xử lý các trường hợp hạn chế của câu lệnh import.

#### 9.3.1 Nghiên cứu Thực nghiệm.
Một số nghiên cứu thực nghiệm đã điều tra các xung đột hợp nhất và thách thức mà các nhà phát triển gặp phải trong giải quyết hợp nhất. McKee và cộng sự và Nelson và cộng sự phỏng vấn các nhà phát triển và thực hiện khảo sát theo dõi với 162 nhà phát triển để xây dựng hiểu biết chi tiết về nhận thức của nhà phát triển về xung đột hợp nhất nói chung. Họ thấy, trong số những thứ khác, rằng độ phức tạp của các dòng mã xung đột và tệp nói chung, số lượng LOC trong xung đột, và sự quen thuộc của nhà phát triển với các dòng mã xung đột tác động đến mức độ khó mà các nhà phát triển thấy để giải quyết xung đột. Brindescu và cộng sự điều tra tác động của xung đột hợp nhất và giải pháp của chúng lên chất lượng phần mềm. Họ thấy rằng 20% thay đổi mã dẫn đến xung đột hợp nhất và mã trong những xung đột này có khả năng chứa lỗi gấp đôi so với các thay đổi khác. Hơn nữa, nếu các thay đổi bao gồm thay đổi tương tác ngữ nghĩa, khả năng của khuyết tật là 26 lần so với các thay đổi không xung đột. Costa và cộng sự trình bày TIPMerge, một phương pháp để xác định và đề xuất các nhà phát triển tham gia vào các phiên hợp nhất khi giải quyết xung đột. Họ đánh giá nó trên 2.040 hợp nhất trên 25 dự án nguồn mở và thấy rằng TIPMerge có thể cải thiện độ bao phủ kiến thức chung trung bình 49% trong các kịch bản hợp nhất. Vale và cộng sự thực hiện nghiên cứu thực nghiệm để hiểu điều gì làm cho hợp nhất thách thức đối với các nhà phát triển. Thông qua phân tích tự động quy mô lớn và khảo sát 140 nhà phát triển, họ xác định các yếu tố góp phần vào độ khó giải quyết xung đột hợp nhất (ví dụ, số lượng chunk trong xung đột và số lượng nhà phát triển tham gia vào kịch bản hợp nhất). Seibt và cộng sự khám phá và đánh giá các thuật toán hợp nhất trên một bộ mười kho phần mềm, chú ý đến số lượng giải pháp được tạo ra, kích thước xung đột, chi phí runtime và tính đúng đắn. Thú vị, họ sử dụng các bộ test của mỗi dự án như oracle để đánh giá tính đúng đắn của mã sau hợp nhất.

Không có nghiên cứu hiện có nào đánh giá các công cụ giải quyết hợp nhất tự động với các nhà phát triển phần mềm trên các xung đột thế giới thực của chính họ. Người tham gia trong khảo sát của chúng tôi có chuyên môn để hiểu khi nào gợi ý giải pháp MergeBERT sẽ chấp nhận được trên các xung đột thế giới thực của chính họ, cung cấp giải thích phong phú về khi nào ngữ cảnh bên ngoài được yêu cầu, hoặc khi nào các thay đổi mã rối được thực hiện.

## 10 CÁC MỐI ĐE DỌA ĐỐI VỚI TÍNH HỢP LỆ

Việc lựa chọn các siêu tham số trong mô hình của chúng tôi (Mục 5.3) dựa trên công trình trước đó của những người khác và các chuẩn mực được chấp nhận chung. Có thể việc khám phá không gian siêu tham số có thể mang lại kết quả khác nhau. Mẫu xung đột và dự án được sử dụng trong nghiên cứu có thể gây ra mối đe dọa đối với tính hợp lệ bên ngoài của công trình chúng tôi. Chúng tôi chỉ xem xét các dự án nguồn mở công khai được lưu trữ trên GitHub, do đó, kết quả có thể không tổng quát hóa cho các dự án nguồn đóng hoặc kho được lưu trữ trên các nền tảng khác. Để giảm thiểu mối đe dọa này, chúng tôi chọn một tập hợp đa dạng các dự án khác nhau về kích thước và ngôn ngữ. Tương tự, người tham gia khảo sát đánh giá các xung đột được hợp nhất gần đây của chính họ và tập hợp xung đột được sử dụng trong khảo sát để trả lời RQ4 có thể không phải là mẫu đại diện, vì nó phụ thuộc vào tính sẵn sàng của người tham gia. Chúng tôi lọc ra các xung đột hợp nhất từ nghiên cứu người dùng mà chúng tôi coi là xung đột "tầm thường". Đây là một đánh giá chủ quan, nhưng chúng tôi đã cố gắng chọn các xung đột thực chất với hy vọng rằng chúng sẽ thu hút phản hồi có giá trị và thông tin hơn từ người tham gia. Giao diện khảo sát tái tạo chế độ xem diff3 của VSCode. Người tham gia không quen thuộc với chế độ xem này có thể khó khăn hơn trong việc điều hướng chế độ xem xung đột và trả lời câu hỏi khảo sát, để giảm thiểu mối đe dọa này, chúng tôi tạo video hướng dẫn cho người tham gia xem.

## 11 KẾT LUẬN

Bài báo này giới thiệu MergeBERT, một framework hợp nhất chương trình dựa trên transformer tận dụng phân biệt ở mức token và cải tạo tác vụ tạo ra chuỗi giải quyết thành một tác vụ phân loại trên một tập hợp các mẫu hợp nhất nguyên thủy được trích xuất từ dữ liệu commit hợp nhất thế giới thực. MergeBERT khai thác pretraining trên lượng lớn mã và sau đó tinh chỉnh trên các ngôn ngữ lập trình cụ thể, đạt được 64-69% precision và 63-68% recall của tổng hợp giải pháp hợp nhất. Cuối cùng, MergeBERT linh hoạt và hiệu quả, có khả năng giải quyết nhiều xung đột hơn các công cụ hiện có trong nhiều ngôn ngữ lập trình.

Để đánh giá tốt hơn các giải pháp được tạo ra bởi MergeBERT từ góc độ người dùng, chúng tôi tiến hành nghiên cứu người dùng với 25 nhà phát triển từ các dự án OSS lớn. Chúng tôi yêu cầu người tham gia đánh giá xem các gợi ý giải pháp MergeBERT có thể chấp nhận được trên một tập hợp 122 xung đột thế giới thực của chính họ. Kết quả cho thấy, trong thực tế, các giải pháp MergeBERT có khả năng được chấp nhận với tỷ lệ cao hơn so với ước tính bởi các chỉ số hiệu suất được chọn. Sử dụng phản hồi của người tham gia, chúng tôi xác định các cách tiềm năng để cải thiện MergeBERT bằng cách cải thiện oracle để loại bỏ các thay đổi rối hoặc xem xét ngữ cảnh bên ngoài - thông tin cấp dự án hoặc nhóm không có mặt trong các tệp xung đột.
