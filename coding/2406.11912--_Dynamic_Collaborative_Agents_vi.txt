# 2406.11912.pdf
# Chuyển đổi từ PDF sang TXT
# Đường dẫn nguồn: /home/admin88/arxiv-downloader/coding/2406.11912.pdf
# Kích thước file: 750818 bytes

===============================================
NỘI DUNG FILE PDF
===============================================


--- TRANG 1 ---
: Các Tác nhân Cộng tác Động
cho Phát triển Phần mềm dựa trên
Phương pháp Agile
Minh Huynh Nguyen∗, Thang Chau Phan∗, Phong X. Nguyen∗, Nghi D. Q. Bui∗,†
∗Trung tâm AI FPT Software, Việt Nam
†Đại học Fulbright, Việt Nam
https://github.com/FSoft-AI4Code/AgileCoder
"Không cần thêm sprint nào 
nữa vì tất cả các yêu cầu 
trong backlog đã được 
hoàn thành. Hãy tận hưởng 
trò chơi!" 
Tạo một trò chơi Snake mà người chơi điều khiển một con rắn di chuyển trên lưới để 
tiêu thụ thức ăn, tăng kích thước trong khi tránh va chạm với chính mình và đâm vào tường. 
Triển khai các yếu tố cơ bản như con rắn di chuyển, thức ăn được đặt ngẫu nhiên, và 
logic kết thúc trò chơi. Đảm bảo điều khiển mượt mà cho việc thay đổi hướng và phân biệt 
trực quan giữa con rắn, thức ăn, và khu vực trò chơi. Tùy chọn, giới thiệu các tính năng 
để nâng cao gameplay, như mức độ khó và theo dõi điểm số. 
Đặc tả Phần mềm 
Lập kế hoạch Sprint 1 Quản lý Sản phẩm 
(PM) Nhà phát triển 
(Dev) Nhà phát triển cấp cao 
(SeDev) 
Kiểm thử viên 
LLM như Tác nhân Bạn đang đóng vai trò là Quản lý  
Sản phẩm, bạn quen thuộc với thiết kế 
sản phẩm và chu trình phát triển phần mềm... 
Vai trò Nhóm 
Tiêu chí Chấp nhận Product Backlog 
Sản phẩm 
Cuối cùng Đóng vai
………… Kiểm thử Đánh giá 
Phát triển 
Sprint 
Backlog 
"Tôi đã tạo một danh sách 
các tính năng cho phần mềm này. 
Hãy chia chúng thành các nhiệm vụ 
và đưa vào backlog. Chúng ta sẽ có 
một buổi khởi động sprint và bắt đầu 
làm việc trên sản phẩm này." PM
 PM"Theo phần đánh giá sprint, 
chúng ta phải tiếp tục với 
các nhiệm vụ còn lại trong 
backlog. Hãy tiến hành 
sprint tiếp theo." 
PM"Chúng ta đã hoàn thành 4 
tính năng cho sản phẩm này,  
Tuy nhiên, có một vài nhiệm vụ 
trong backlog cần điều chỉnh. 
Hãy lập kế hoạch lại và tiến hành 
sprint tiếp theo. Lập kế hoạch 
 Kiểm thử Đánh giá 
Lập kế hoạch 
 Kiểm thử Đánh giá Sprint 2 
PMSprint N 
Sprint 
Backlog Sprint 
Backlog 
Scrum Master 
(SM) 
Phát triển Phát triển 
Hình 1: Tổng quan về A GILE CODER
Tóm tắt
Các tác nhân phần mềm đã nổi lên như công cụ đầy hứa hẹn để giải quyết các nhiệm vụ kỹ thuật phần mềm phức tạp. Mặt khác, các công trình hiện tại thường đơn giản hóa quá mức quy trình phát triển phần mềm, mặc dù thực tế các quy trình như vậy thường phức tạp hơn trong thế giới thực. Do đó, chúng tôi đề xuất AGILE CODER, một hệ thống đa tác nhân tích hợp Phương pháp Agile (AM) vào framework. Hệ thống này gán các vai trò AM cụ thể—như Quản lý Sản phẩm, Nhà phát triển, và Kiểm thử viên—cho các tác nhân khác nhau, sau đó họ cộng tác phát triển phần mềm dựa trên đầu vào của người dùng. AGILE CODER nâng cao hiệu quả phát triển bằng cách tổ chức công việc thành các sprint, tập trung vào việc phát triển phần mềm tăng dần qua các sprint. Ngoài ra, chúng tôi giới thiệu Dynamic Code Graph Generator, một module tạo Code Dependency Graph động khi cập nhật được thực hiện trên codebase. Điều này cho phép các tác nhân hiểu rõ hơn về codebase, dẫn đến việc tạo và sửa đổi mã chính xác hơn trong suốt quá trình phát triển phần mềm. AGILE CODER vượt trội so với các benchmark hiện tại, như ChatDev và MetaGPT, thiết lập tiêu chuẩn mới và thể hiện khả năng của hệ thống đa tác nhân trong môi trường kỹ thuật phần mềm tiên tiến.
Bản thảo. Đang được xem xét.arXiv:2406.11912v2  [cs.SE]  14 Jul 2024

--- TRANG 2 ---
ifications trong suốt quá trình phát triển phần mềm. AGILE CODER vượt trội so với các benchmark hiện tại, như ChatDev và MetaGPT, thiết lập tiêu chuẩn mới và thể hiện khả năng của hệ thống đa tác nhân trong môi trường kỹ thuật phần mềm tiên tiến.

1 Giới thiệu
Các tác nhân phần mềm tự động tận dụng Mô hình Ngôn ngữ Lớn (LLMs) mang lại cơ hội đáng kể để nâng cao và tái tạo quy trình phát triển phần mềm [Qian et al., 2023, Hong et al., 2024, Tang et al., 2024, Zhou et al., 2023, Huang et al., 2023]. Các tác nhân này mô phỏng quy trình phát triển phần mềm của con người, bao gồm thiết kế, triển khai, kiểm thử, và bảo trì. MetaGPT [Hong et al., 2024] mã hóa Quy trình Vận hành Tiêu chuẩn (SOPs) vào các nhiệm vụ phát triển phần mềm, trong khi ChatDev [Qian et al., 2023] tạo ra một công ty công nghệ ảo được hỗ trợ bởi chat; cả hai đều tuân theo mô hình waterfall cổ điển. Tuy nhiên, những cách tiếp cận này đơn giản hóa quá mức quy trình làm việc, không phản ánh bản chất động và lặp đi lặp lại của phát triển phần mềm thế giới thực, nơi khoảng 70% các nhóm chuyên nghiệp áp dụng Phương pháp Agile (AM) [Agi, 2024]. Hơn nữa, những phương pháp này phụ thuộc quá mức vào LLMs để ra quyết định và quản lý việc tạo mã, chứng minh không đủ để xử lý sự phức tạp của toàn bộ kho lưu trữ phần mềm, đặc biệt khi xem xét hiểu biết và tạo mã ở cấp độ kho lưu trữ. Để giải quyết những hạn chế này, chúng tôi đề xuất AGILE CODER, một framework phát triển phần mềm đa tác nhân mới dựa trên Phương pháp Agile (AM). AGILE CODER mô phỏng quy trình làm việc AM và thích ứng nó với bối cảnh framework đa tác nhân, cho phép khả năng thích ứng động và nâng cao lặp đi lặp lại. Chúng tôi cũng giới thiệu một module dựa trên phân tích tĩnh gọi là Dynamic Code Graph Generator, tạo ra Code Dependency Graph (CDG) cập nhật bất cứ khi nào mã thay đổi. CPG phục vụ như một nguồn đáng tin cậy để các tác nhân truy xuất bối cảnh liên quan, cho phép tinh chỉnh chính xác phần mềm trong mỗi sprint.

Để đánh giá hiệu quả của AGILE CODER, chúng tôi tiến hành đánh giá toàn diện trên hai benchmark nổi tiếng, HumanEval [Chen et al., 2021] và MBPP [Austin et al., 2021a] và một benchmark phát triển phần mềm, ProjectDev. Kết quả thực nghiệm cho thấy AGILE CODER đạt được điểm số tốt nhất về pass@1 trên hai tập dữ liệu đầu tiên. Ví dụ, sử dụng GPT-3.5 Turbo làm mô hình nền tảng, AGILE CODER đạt 70.53% và 80.92% trong pass@1 trên HumanEval [Chen et al., 2021] và MBPP [Austin et al., 2021a], tương ứng, mang lại cải thiện 7.71% và 6.19% so với MetaGPT [Hong et al., 2024]. Hơn nữa, chúng tôi cũng thu thập tập dữ liệu các yêu cầu phần mềm đòi hỏi hệ thống sản xuất phần mềm phức tạp, có tên ProjectDev. AGILE CODER thể hiện hiệu suất nổi bật trên ProjectDev so với ChatDev [Qian et al., 2023] và MetaGPT[Hong et al., 2024] trong việc tạo ra các chương trình có thể thực thi đáp ứng yêu cầu người dùng.

Tóm lại, các đóng góp chính của chúng tôi được tóm tắt như sau:
(1)Chúng tôi giới thiệu AGILE CODER, một framework phát triển phần mềm đa tác nhân mới lấy cảm hứng từ phương pháp Agile, nhấn mạnh giao tiếp hiệu quả và phát triển tăng dần giữa các tác nhân. Framework này cho phép kế thừa đầu ra qua các sprint, cho phép tinh chỉnh liên tục và tăng khả năng thành công của sản phẩm cuối cùng.

(2)Chúng tôi tích hợp phương pháp phân tích tĩnh vào quy trình làm việc đa tác nhân thông qua Dynamic Code Graph Generator (DCGG), tạo ra động Code Dependency Graph (CDG). Đồ thị này nắm bắt mối quan hệ giữa các thành phần mã khi codebase phát triển, cung cấp nguồn đáng tin cậy để các tác nhân truy xuất bối cảnh liên quan và do đó nâng cao chất lượng phần mềm được sản xuất. Đánh giá của chúng tôi cho thấy sự gia tăng hiệu suất đáng kể trong các benchmark thế giới thực khi sử dụng bối cảnh được truy xuất từ CDG.

(3)Các đánh giá của chúng tôi xác nhận rằng AGILE CODER đạt được hiệu suất tiên tiến (SOTA) mới trên các benchmark đã được thiết lập như HumanEval [Chen et al., 2021] và MBPP [Austin et al., 2021a], cũng như benchmark mới được đề xuất của chúng tôi cho phát triển phần mềm thế giới thực, có tên ProjectDev. Framework này vượt trội so với các mô hình SOTA gần đây như MetaGPT [Hong et al., 2024] và ChatDev [Qian et al., 2023], chứng minh hiệu quả của nó trong các tình huống phát triển phần mềm thực tế.

--- TRANG 3 ---
2 Công trình liên quan
Deep Learning cho Lập trình Tự động Trong những năm gần đây, việc áp dụng deep learning vào lập trình tự động đã thu hút sự quan tâm đáng kể trong cộng đồng nghiên cứu [Balog et al., 2016, Bui and Jiang, 2018, Bui et al., 2021, Feng et al., 2020, Wang et al., 2021, Allamanis et al., 2018, Bui et al., 2023, Guo et al., 2020, 2022]. Cụ thể, Code Large Language Models (CodeLLMs) đã nổi lên như một nhánh chuyên biệt của LLMs, được tinh chỉnh cho các nhiệm vụ lập trình [Wang et al., 2021, 2023, Feng et al., 2020, Allal et al., 2023, Li et al., 2023, Lozhkov et al., 2024, Guo et al., 2024a, Pinnaparaju et al., 2024, Zheng et al., 2024, Roziere et al., 2023, Nijkamp et al., 2022, Luo et al., 2023, Xu et al., 2022, Bui et al., 2022]. Những mô hình này đã trở thành nền tảng trong một ngành cung cấp các giải pháp như Microsoft Copilot, Codium, và TabNine, xuất sắc trong việc giải quyết các vấn đề mã hóa cạnh tranh từ các benchmark như HumanEval [Chen et al., 2021], MBPP [Austin et al., 2021b], và APPs [Hendrycks et al., 2021]. Mặc dù đạt được kết quả tốt với các nhiệm vụ benchmark, những mô hình này thường gặp khó khăn trong việc tạo ra phần mềm thế giới thực đòi hỏi logic phức tạp và tiêu chí chấp nhận chi tiết, điều cần thiết cho các ứng dụng thực tế [Hong et al., 2024, Qian et al., 2023].

Cộng tác Đa Tác nhân dựa trên LLMs cho Phát triển Phần mềm Gần đây, các tác nhân tự động dựa trên LLM đã thu hút sự quan tâm đáng kể từ cả ngành công nghiệp và học thuật [Wang et al., 2024, Guo et al., 2024b, Du et al., 2023]. Trong phát triển phần mềm, việc triển khai các hệ thống tập trung vào tác nhân chuyên biệt trong các nhiệm vụ mã hóa đã dẫn đến những tiến bộ đáng chú ý [Hong et al., 2024, Qian et al., 2023, Chen et al., 2023, Huang et al., 2023, Zhong et al., 2024, Lin et al., 2024, Yang et al., 2024]. Những hệ thống này có các vai trò riêng biệt—Lập trình viên, Người đánh giá, và Kiểm thử viên—mỗi vai trò dành riêng cho một giai đoạn cụ thể của quy trình tạo mã, do đó nâng cao cả chất lượng và hiệu quả. Đi kèm với những hệ thống tập trung vào tác nhân này là các benchmark được thiết kế để đánh giá khả năng xử lý các nhiệm vụ kỹ thuật phần mềm thế giới thực của chúng. Ví dụ, SWE-Bench [Jimenez et al., 2023] thách thức các hệ thống đa tác nhân giải quyết các vấn đề GitHub thực tế. Tương tự, MetaGPT giới thiệu SoftwareDev [Hong et al., 2024], một bộ yêu cầu phần mềm từ các lĩnh vực đa dạng đòi hỏi các tác nhân phát triển các giải pháp phần mềm hoàn chỉnh. Trong trường hợp của chúng tôi, chúng tôi cũng biên soạn một bộ yêu cầu phần mềm đa dạng để benchmark khả năng của AGILE CODER trong việc sản xuất phần mềm thế giới thực hiệu quả.

3 Nền tảng
3.1 Phương pháp Agile cho Phát triển Phần mềm Chuyên nghiệp
Agile, xuất phát từ Tuyên ngôn Agile [agi, 2001], là một phương pháp phát triển phần mềm linh hoạt nhấn mạnh chủ nghĩa thực dụng trong việc cung cấp sản phẩm cuối cùng. Nó thúc đẩy việc cung cấp liên tục, cộng tác với khách hàng, và thích ứng nhanh chóng với các yêu cầu thay đổi. Không giống như các phương pháp tuyến tính truyền thống như mô hình Waterfall [Bassil, 2012], Agile sử dụng phát triển lặp đi lặp lại thông qua các sprint—chu kỳ ngắn cho phép điều chỉnh nhanh chóng và đánh giá lại mục tiêu dự án thường xuyên. Cách tiếp cận lặp đi lặp lại này nâng cao sự phù hợp với nhu cầu khách hàng và thúc đẩy giao tiếp mở và trách nhiệm chung trong nhóm. Khả năng thích ứng của Agile làm cho nó đặc biệt hiệu quả trong việc quản lý các dự án phức tạp nơi các yêu cầu có thể phát triển theo thời gian. Bằng cách tích hợp các nguyên tắc Agile với các tác nhân cộng tác trong phát triển phần mềm, chúng tôi cung cấp một góc nhìn mới về thiết kế hệ thống đa tác nhân.

3.2 Hiểu biết & Tạo Mã ở Cấp độ Kho lưu trữ
Tạo mã ở cấp độ kho lưu trữ là một thách thức đáng kể đối với Large Language Models (LLMs) trong các nhiệm vụ kỹ thuật phần mềm thế giới thực [Shrivastava et al., 2023a,b, Bairi et al., 2023, Zhang et al., 2024, Agrawal et al., 2023, Phan et al., 2024]. Codebase thế giới thực rất phức tạp, với các module liên kết với nhau, và khi kích thước bối cảnh tăng lên, LLMs đối mặt với các hạn chế. Điều này đã dẫn đến nghiên cứu về việc lựa chọn bối cảnh liên quan [Luo et al., 2024, Shrivastava et al., 2023a, Liu et al., 2023] và tối ưu hóa việc sử dụng chúng. Các tác nhân phần mềm, như ChatDev và MetaGPT, nhằm tạo ra phần mềm có thể thực thi đầy đủ chức năng bao gồm các file, class, và module khác nhau, thay vì chỉ là giải pháp cho các nhiệm vụ đơn giản như trong HumanEval [Chen et al., 2021] hoặc MBPP [Austin et al., 2021b]. Điều này đòi hỏi các tác nhân hiểu tất cả bối cảnh hiện tại, bao gồm file, class, function, và thư viện, khi tạo mã hoặc sửa lỗi. Tuy nhiên, nhu cầu hiểu biết và tạo mã toàn diện ở cấp độ kho lưu trữ này thường bị bỏ qua trong nghiên cứu trước đây.

--- TRANG 4 ---
4 A GILE CODER : Một Framework Agentic cho Phát triển Phần mềm
Hình 1 trình bày tổng quan về AGILE CODER, sử dụng nhiều tác nhân trong các vai trò như Quản lý Sản phẩm, Scrum Master, Nhà phát triển, Nhà phát triển cấp cao, và Kiểm thử viên, cộng tác thông qua quy trình làm việc lấy cảm hứng từ Phương pháp Agile. Quá trình phát triển kết hợp Môi trường Thực thi để chạy mã trong quá trình kiểm thử và Dynamic Code Graph Generator (DCGG) (Hình 2) để tạo ra Code Dependency Graph động bất cứ khi nào mã được cập nhật. Môi trường Thực thi cung cấp traceback cho các tác nhân để tinh chỉnh mã, trong khi DCGG cho phép các tác nhân truy xuất bối cảnh liên quan để tạo và sửa mã chính xác. Mô tả chi tiết về các module này được cung cấp trong các Phần sau.

"Hãy thêm user_manager.py  
để quản lý người dùng."
Code Graph Code Files "Từ logs, chúng ta cần các tiện ích để 
user_manager có thể lưu user vào 
cơ sở dữ liệu. Hãy thêm utils.py." 

user_manager.py user.py 
user_manager user 
Graph 
Generator 
Graph 
Generator Update Update  Observe Observe  
"Có vẻ như chúng ta gặp lỗi khi 
thực thi mã". 
Logs: 
Traceback (most recent call last): File 
"/path/to/user_manager.py", line 2, in <module> 
from utils import save_user_to_database 
ModuleNotFoundError: No module named 'utils' 
Log lỗi cho thấy nguyên nhân là 
user_manager.py. Hãy truy xuất bối cảnh 
liên quan cho user_manager từ code graph 
và quyết định cách giải quyết lỗi này. 
Code Files 
utils.py 
Code Graph user_manager user utils Execution 
Environment 
Execute ……………. game.py user.py game.py 
user_manager.py 
Hình 2: Minh họa cách Dynamic Code Graph Generator (DCGG) đóng góp vào AGILE -
CODER trong quá trình tạo ra một ứng dụng Python.

4.1 Vai trò Tác nhân
Vai trò của mỗi tác nhân được định nghĩa như sau:
•Product Manager (PM): Nhận yêu cầu từ người dùng và tạo product backlog, bao gồm các nhiệm vụ phát triển và tiêu chí chấp nhận.
• Scrum Master (SM): Cung cấp phản hồi backlog cho PM để nâng cao khả năng đạt được của sprint.
•Developer (Dev): Tập trung chính vào việc phát triển các nhiệm vụ, bao gồm tạo và tái cấu trúc mã dựa trên phản hồi từ các tác nhân khác.
•Senior Developer (SD): Đánh giá mã được tạo bởi các nhà phát triển, cung cấp phản hồi cho việc tái cấu trúc mã, và đảm bảo kiểm soát chất lượng.
• Tester: Tạo test case và script để xác thực mã được phát triển bởi các nhà phát triển.

4.2 Tổng quan về Quy trình Làm việc
Quy trình làm việc bắt đầu với Product Manager (PM) khởi xướng lập kế hoạch backlog sau khi nhận yêu cầu từ người dùng. PM viết các nhiệm vụ và tiêu chí chấp nhận trong backlog. Scrum Master (SM) đánh giá backlog, thẩm định tính khả thi của nhiệm vụ, và có thể yêu cầu sửa đổi từ PM. Đầu ra là product backlog, nắm bắt tất cả các nhiệm vụ cần thiết cho sản phẩm cuối cùng. Sau khi lập kế hoạch hoàn tất, SM khởi xướng phát triển với một sprint. Mỗi sprint bao gồm các giai đoạn Lập kế hoạch, Phát triển, Kiểm thử, và Đánh giá. Trong Lập kế hoạch, SM chọn các nhiệm vụ từ Product Backlog cho Sprint Backlog. Các giai đoạn còn lại bao gồm các giai đoạn phụ nơi các cặp tác nhân cộng tác trong các nhiệm vụ (chi tiết trong Phần 4.2). Sau tất cả các giai đoạn, SM đánh giá tiến độ để quyết định liệu phần mềm có sẵn sàng để giao hay không. Nếu không, sprint tiếp theo bắt đầu với Lập kế hoạch. Điều này lặp lại cho đến khi SM quyết định phần mềm có thể giao được, lúc đó tín hiệu kết thúc sẽ kết thúc pipeline phát triển.

4.2.1 Giai đoạn Lập kế hoạch
Ở đầu mỗi sprint, Product Manager (PM) soạn thảo một kế hoạch bao gồm các nhiệm vụ được chọn từ product backlog, tiêu chí chấp nhận được định nghĩa, và thông tin từ các đánh giá của các sprint trước đó, nếu có. Scrum Master cung cấp phản hồi để tinh chỉnh kế hoạch này, đảm bảo rằng nó phù hợp với các mục tiêu và ràng buộc hiện tại của dự án. Đầu ra của giai đoạn này là sprint backlog, phác thảo phạm vi các nhiệm vụ cần hoàn thành trong sprint.

4.2.2 Giai đoạn Phát triển
Sau giai đoạn lập kế hoạch, PM chỉ đạo Developer bắt đầu triển khai. Để nâng cao độ rõ ràng cho các tác nhân khác, Developer được yêu cầu chú thích mỗi method/function với docstring. Tuy nhiên, do khả năng mắc lỗi từ ảo giác LLM [Manakul et al., 2023], mã được tạo ra có thể không luôn luôn phù hợp với sprint backlog và tiêu chí chấp nhận. Để giảm thiểu điều này, Senior Developer sử dụng quy trình đánh giá tĩnh lấy cảm hứng từ thực hành peer review. Đánh giá này tập trung vào việc xác định lỗi, lỗi logic, và edge case, sau đó cung cấp phản hồi để sửa chữa. Quy trình đánh giá được cấu trúc thành ba bước tuần tự để quản lý sự phức tạp và cải thiện hiệu quả của phản hồi. Bước đầu tiên bao gồm kiểm tra các lỗi cơ bản như method rỗng và thiếu import statement, tiếp theo là đảm bảo rằng mã nguồn đáp ứng sprint backlog với bước cuối cùng xác nhận rằng mã nguồn đáp ứng tiêu chí chấp nhận và không có lỗi. Bằng cách chia nhỏ code review thành các bước có cấu trúc này, nó trở nên khả thi cho LLMs tiến hành phân tích tĩnh kỹ lưỡng và cung cấp phản hồi có thể thực hiện, do đó nâng cao độ chính xác và độ tin cậy của giai đoạn phát triển. Một nghiên cứu ablation có thể được tìm thấy trong Phụ lục A.2.1.

4.2.3 Giai đoạn Kiểm thử
Mặc dù đánh giá kỹ lưỡng, mã không có lỗi không thể được đảm bảo do ảo giác LLM. Do đó, một tester được sử dụng để viết test suite và triển khai kế hoạch kiểm thử, cung cấp phản hồi thời gian thực cho Developer để tinh chỉnh mã lặp đi lặp lại.

Viết Test Suite Trong một sprint, chúng ta kế thừa mã nguồn từ các sprint trước đó và triển khai các tính năng mới. Trong khi mã hiện tại trải qua đánh giá và kiểm thử kỹ lưỡng, mã mới thiếu sự kiểm tra như vậy, cần thiết phải tạo test case để đảm bảo tính đúng đắn chức năng của nó. Chúng ta sử dụng code graph G được tạo bởi DCGG (Phần 4.3) và danh sách các file đã thay đổi F để tìm các file cần kiểm thử. Quá trình này có thể được mô tả chính thức là Sf(ni)∪ {ni}, ni∈ F, trong đó f trả về các node tổ tiên trong graph G của một input node. Ví dụ, trong Hình 2, nếu file user_manager.py trải qua bất kỳ thay đổi nào, chúng ta nên kiểm tra lại tính đúng đắn chức năng của nó cùng với các file tổ tiên của nó, nhưng không phải user.py. Tester sau đó chịu trách nhiệm viết test suite cho tất cả các file cần thiết.

Viết Kế hoạch Kiểm thử Sau khi viết test case, chúng ta có nhiều testing script phải được thực thi theo thứ tự cụ thể để tránh sự không nhất quán giữa các file mã và chi phí không cần thiết. Ví dụ, trong Hình 2, file user_manager.py phụ thuộc vào file user.py, làm cho việc kiểm thử user_manager.py trước user.py trở nên phi logic. May mắn thay, chúng ta có thể thu được kế hoạch kiểm thử logic bằng cách đảo ngược thứ tự topological giữa các testing script của code graph G. Hơn nữa, chúng ta muốn phần mềm cuối cùng có thể thực thi được, vì vậy Tester được yêu cầu viết các lệnh để đánh giá khả năng thực thi của nó.

Sửa lỗi Một khi kế hoạch kiểm thử được định nghĩa rõ ràng được thiết lập, các file được thực thi lặp đi lặp lại theo kế hoạch cho đến khi các vấn đề như lỗi hoặc test case thất bại phát sinh. Developer giải quyết những vấn đề này dựa trên báo cáo kiểm thử được cung cấp bởi Tester, lặp lại quá trình cho đến khi kế hoạch kiểm thử được hoàn thành.

4.2.4 Giai đoạn Đánh giá
Ở cuối sprint, Tester chạy phần mềm để viết báo cáo kiểm thử. Product Manager sau đó thu thập sprint backlog, mã nguồn, và báo cáo kiểm thử để đánh giá các nhiệm vụ đã hoàn thành, thất bại, và chưa hoàn thành. Thông tin này tích lũy qua các sprint để tạo thành báo cáo tổng thể. Product Manager sau đó so sánh báo cáo tổng thể này với product backlog và tiêu chí chấp nhận để quyết định liệu có kết thúc nhiệm vụ hay lập kế hoạch sprint tiếp theo. Nếu kết thúc, Scrum Master viết tài liệu chi tiết, bao gồm cách chạy và cài đặt các thư viện cần thiết. Nếu lập kế hoạch sprint khác, Product Manager đánh giá product backlog, tiêu chí chấp nhận, và báo cáo tổng thể hiện tại để tạo kế hoạch sprint tiếp theo.

--- TRANG 5 ---
4.3 Dynamic Code Graph Generator cho Context-Aware Code Retrieval
Dynamic Code Graph Generator (DCGG) là một module quan trọng trong hệ thống của chúng tôi tạo và cập nhật động code dependency graph, được ký hiệu là G. Đồ thị này mô hình hóa hiệu quả các mối quan hệ giữa các file mã, tạo điều kiện thuận lợi cho việc truy xuất mã nhận biết bối cảnh hiệu quả. Trong G, mỗi node đại diện cho một file mã, và mỗi cạnh chỉ ra mối quan hệ phụ thuộc, như mối quan hệ giữa user_manager.py và user.py được hiển thị trong Hình 2. Chúng tôi chủ yếu nắm bắt các mối quan hệ import để duy trì sự đơn giản và hiệu quả của đồ thị. Khi codebase phát triển, dù thông qua việc thêm các tính năng mới hay sửa lỗi, G được cập nhật để phản ánh trạng thái hiện tại một cách chính xác. Điều này rất cần thiết để duy trì tính toàn vẹn của codebase và đảm bảo rằng tất cả các thay đổi được ghi lại và tích hợp đúng cách. Ngoài ra, các file được sửa đổi trong một sprint, được xác định là F, được ghi lại và liên kết trong G để theo dõi tất cả các phụ thuộc bị ảnh hưởng. Tóm lại, DCGG phục vụ hai chức năng chính:

1.Hỗ trợ viết test case và kế hoạch kiểm thử Khi mã mới được tạo ra, DDCG đảm bảo rằng chỉ các file bị ảnh hưởng cần kiểm thử. Ngoài ra, một kế hoạch kiểm thử hợp lý luôn được thu được bằng cách sử dụng G.

2.Cung cấp Bối cảnh cho Code Repair: Khi lỗi xảy ra trong quá trình thực thi mã, tác nhân truy ngược để xác định các file liên quan bằng cách sử dụng phân tích traceback. Nó truy xuất bối cảnh cross-file từ code graph để xác định chính xác nguồn gốc của lỗi, đảm bảo việc truy xuất mã hiệu quả.

Các cách tiếp cận hiện tại, như những cách được sử dụng bởi ChatDev [Qian et al., 2023] và MetaGPT [Hong et al., 2024], thường bao gồm việc tải toàn bộ codebase vào LLMs, điều này trở nên không thực tế khi codebase tăng vượt quá giới hạn token của LLMs. DCGG giải quyết hạn chế này bằng cách duy trì dependency graph cho phép tác nhân truy xuất thông tin liên quan một cách có chọn lọc, do đó tối ưu hóa việc sử dụng token của LLM và duy trì tính liên quan và độ chính xác của thông tin được cung cấp cho các nhà phát triển hoặc tác nhân.

Cách tiếp cận thiết kế này không chỉ cải thiện hiệu quả của việc tạo mã và gỡ lỗi mà còn đảm bảo rằng quá trình phát triển được hợp lý hóa và tập trung, tránh việc quá tải dữ liệu không liên quan và nâng cao độ chính xác tổng thể của quy trình phát triển. Hình 2 minh họa cách DCGG cập nhật để đáp ứng với các thay đổi codebase, như việc thêm các class hoặc mối quan hệ mới, do đó duy trì sự phản ánh chính xác và cập nhật của cấu trúc mã.

4.4 Cơ chế Giao tiếp Giữa các Tác nhân
Hệ thống của chúng tôi sử dụng thiết kế hội thoại dual-agent qua tất cả các giai đoạn, đơn giản hóa mô hình tương tác thành chỉ hai vai trò: một instructor và một assistant. Cấu trúc này tránh sự phức tạp liên quan đến topologies đa tác nhân và hợp lý hóa quá trình đồng thuận. Instructor chịu trách nhiệm cung cấp hướng dẫn rõ ràng và hướng dẫn luồng cuộc hội thoại hướng tới việc hoàn thành các nhiệm vụ cụ thể, trong khi assistant sử dụng kỹ năng và kiến thức của họ để thực hiện các nhiệm vụ, với các tương tác tiếp tục cho đến khi đạt được đồng thuận.

Để đảm bảo tính liên tục và mạch lạc trong đối thoại giữa các tin nhắn, chúng tôi sử dụng Message Stream S. Luồng này hoạt động như bộ nhớ làm việc lưu trữ tất cả các tin nhắn được trao đổi, cho phép các tác nhân tạo ra phản hồi kết nối liền mạch với lịch sử cuộc hội thoại. Chính thức, nếu it và at là các tin nhắn được tạo ra bởi instructor và assistant tại bước thời gian t tương ứng, thì St được định nghĩa là St= [(i1, a1),(i2, a2), ...,(it, at)].

Tại bước thời gian tiếp theo t+ 1, instructor đánh giá St để thẩm định sự phù hợp của hành động at với hướng dẫn được cung cấp trước khi đưa ra hướng dẫn thêm it+1. Đồng thời, assistant, khi nhận được hướng dẫn mới it+1, tạo ra phản hồi phù hợp at+1. Nếu at+1 đáp ứng tiêu chí kết thúc hoặc nếu tương tác đạt đến giới hạn trao đổi được định trước, đối thoại kết thúc. Tin nhắn cuối cùng at+1 được lưu trữ để tham khảo trong tương lai, đảm bảo duy trì thông tin phù hợp và mang tính xây dựng.

Giao thức Giao tiếp Phù hợp với thực hành được thiết lập từ nghiên cứu trước đây [Qian et al., 2023], giao diện giao tiếp của chúng tôi sử dụng ngôn ngữ tự nhiên không ràng buộc. Tính linh hoạt này cho phép dễ dàng sửa đổi prompt, như điều chỉnh ràng buộc đầu ra hoặc thay đổi định dạng, mà không có tác động đáng kể trên toàn hệ thống. Hơn nữa, AGILE CODER kết hợp một kỹ thuật được gọi là prompt engineering ở đầu mỗi cuộc hội thoại để tối ưu hóa hiểu biết và thực hiện nhiệm vụ. Thiết lập ban đầu này đảm bảo rằng cả hai tác nhân đều được thông báo đầy đủ về yêu cầu và mục tiêu của nhiệm vụ,

--- TRANG 6 ---
Bảng 1: Kết quả so sánh trên tập dữ liệu HumanEval và MBPP cho các LLMs và tác nhân dựa trên LLM khác nhau, làm nổi bật các cải thiện hiệu suất đạt được thông qua việc áp dụng A GILE CODER.

Danh mục Mô hình Tập dữ liệu Hiệu suất
HumanEval MBPP
LLMs (prompting) CodeGeeX-13B 18.9 26.9
PaLM Coder-540B 43.9 32.3
DeepSeeker-33B-Inst 79.3 70.0
GPT-3.5 Turbo 60.3 52.2
Claude 3 Haiku 75.9 80.4
GPT 4 80.1 80.1
Tác nhân dựa trên LLMs với GPT-3.5 Turbo ChatDev 61.79 74.80
MetaGPT 62.80 74.73
AGILE CODER 70.53 80.92
với Claude 3 Haiku ChatDev 76.83 70.96
AGILE CODER 79.27 84.31
với GPT 4 MetaGPT 85.9 87.7
AGILE CODER 90.85 -

tạo điều kiện thuận lợi cho việc tạo ra các phản hồi liên quan nhằm hoàn thành thành công các nhiệm vụ. Các tác nhân tiến hành tự động mà không cần can thiệp của con người cho đến khi đạt được đồng thuận.

Global Message Pool Để tạo điều kiện cho luồng thông tin mượt mà trong suốt hệ thống, một global message pool trong môi trường chia sẻ lưu trữ các đầu ra từ tất cả các cuộc hội thoại. Môi trường này cũng ghi lại trạng thái của các nhiệm vụ—liệu chúng đã hoàn thành, đang chờ xử lý, hay thất bại—cung cấp bối cảnh phong phú cho các tác nhân để đưa ra quyết định sáng suốt. Tuy nhiên, với khối lượng thông tin tiềm năng, việc tiếp xúc trực tiếp tất cả dữ liệu với các tác nhân có thể dẫn đến quá tải thông tin. Do đó, mỗi cuộc hội thoại chỉ truy cập các phân đoạn liên quan của dữ liệu từ global message pool cần thiết cho việc giải quyết nhiệm vụ. Ví dụ, trong khi Product Manager có thể tập trung vào product backlog và trạng thái nhiệm vụ cho việc lập kế hoạch sprint, Developer có thể cần truy cập chủ yếu vào các phần cụ thể của mã liên quan đến việc sửa lỗi. Chiến lược truy cập có mục tiêu này ngăn chặn quá tải dữ liệu và đảm bảo rằng tất cả các tác nhân hoạt động với thông tin hiện tại và liên quan nhất có sẵn.

5 Thí nghiệm
5.1 Kết quả Thực nghiệm
Tập dữ liệu Để đánh giá, chúng tôi đã chọn hai loại tập dữ liệu. Loại đầu tiên bao gồm các benchmark nổi tiếng để đánh giá khả năng tạo mã trong CodeLLMs: HumanEval [Chen et al., 2021] và MBPP [Austin et al., 2021a]. Nhiều thiết lập thực nghiệm hơn có thể được tìm thấy trong Phụ lục A.1. Những benchmark này chủ yếu có các bài toán cấp độ cạnh tranh không đại diện đầy đủ cho sự phức tạp của phát triển phần mềm thế giới thực.

Để giải quyết khoảng trống này, chúng tôi đã thu thập một bộ sưu tập 14 ví dụ đại diện về các nhiệm vụ phát triển phần mềm phức tạp hơn, được gọi chung là ProjectDev. Những nhiệm vụ này bao gồm các lĩnh vực đa dạng như mini-game, thuật toán xử lý hình ảnh, và trực quan hóa dữ liệu. Mỗi nhiệm vụ đi kèm với prompt chi tiết và yêu cầu hệ thống tạo ra codebase toàn diện bao gồm nhiều file có thể thực thi. Chúng tôi chạy mỗi nhiệm vụ ba lần và báo cáo số trung bình. Quá trình đánh giá chi tiết có thể được tìm thấy trong Phụ lục A.3.

Metrics Đối với HumanEval [Chen et al., 2021] và MBPP [Austin et al., 2021a], chúng tôi áp dụng metric pass@k không thiên vị [Chen et al., 2021], theo cách tiếp cận của các nghiên cứu trước đây [Hong et al., 2024, Qian et al., 2023], để đánh giá độ chính xác chức năng của mã được tạo top-1. Đối với tập dữ liệu ProjectDev, chúng tôi tập trung vào ứng dụng thực tế và đánh giá hiệu suất thông qua thẩm định con người và phân tích thống kê. Đánh giá con người bao gồm việc kiểm tra khả năng thực thi của phần mềm được tạo ra so với yêu cầu dự kiến để xác định tỷ lệ thành công trong việc đáp ứng những yêu cầu đó (ví dụ: nếu một chương trình được tạo ra có thể thực thi và đáp ứng 4 trong 10 yêu cầu, tỷ lệ thực thi của nó là 40%) và tính toán tổng số lỗi (#Errors) khi các chương trình được tạo ra không chạy được. Phân tích thống kê bao gồm các metric như thời gian chạy, sử dụng token, chi phí cho tất cả các phương pháp, và số sprint trung bình (#Sprints) chỉ cho A GILE CODER.

Baseline Chúng tôi sử dụng các CodeLLMs SOTA làm baseline, bao gồm CodeGen [Nijkamp et al., 2022], CodeGeeX [Zheng et al., 2023], PaLM Coder [Chowdhery et al., 2023], DeepSeek-Coder [Guo et al., 2024a], GPT-3.5, GPT-4 [Achiam et al., 2023], và Claude 3 Haiku [Anthropic, 2024]. Với AGILE CODER là một hệ thống đa tác nhân, chúng tôi cũng so sánh nó với các hệ thống đa tác nhân hàng đầu được sử dụng cho các nhiệm vụ phát triển phần mềm, như MetaGPT [Hong et al., 2024] và ChatDev [Qian et al., 2023].

Bảng 2: Kết quả trên ProjectDev
Chỉ số Thống kê ChatDev MetaGPT A GILE CODER
Khả năng thực thi 32.79 7.73 57.79
Thời gian Chạy Toàn bộ (s) 120 48 444
Thời gian Trung bình/Sprint (s) - - 306
#Sprints - - 1.64
Sử dụng Token 7440 3029 36818
Chi phí (USD) 0.12 0.02 0.44
#Errors 6 32 0

Kết quả Bảng 1 cho thấy AGILE CODER vượt trội đáng kể so với các framework đa tác nhân SOTA gần đây và CodeLLMs trên các benchmark HumanEval và MBPP. AGILE CODER đạt được cải thiện trung bình 5.58 và 6.33 trong pass@1 so với ChatDev và MetaGPT trên HumanEval, tương ứng, với các cải thiện tương tự trên MBPP. Kết quả trên ProjectDev (Bảng 2) tiếp tục chứng minh sự vượt trội của AGILE CODER trong các nhiệm vụ phát triển phần mềm. AGILE CODER cho thấy cải thiện đáng kể về khả năng thực thi so với ChatDev và MetaGPT, mà không tạo ra bất kỳ chương trình không thể thực thi nào. Những lợi thế này có thể được quy cho việc AGILE CODER tích hợp giai đoạn lập kế hoạch, test case được tạo ra, và truy xuất mã hiệu quả, mà ChatDev và MetaGPT thiếu. Mặc dù AGILE CODER yêu cầu nhiều token và thời gian chạy hơn do tính phức tạp vốn có của phương pháp Agile Scrum, nó hoàn thành hiệu quả các nhiệm vụ của người dùng trong trung bình 1.64 sprint. Các thí nghiệm của chúng tôi liên tục chứng minh sự vượt trội của A GILE CODER qua các benchmark khác nhau.

Điều quan trọng cần thừa nhận là HumanEval và MBPP có thể không phải là những benchmark phù hợp nhất để đánh giá các hệ thống đa tác nhân phức tạp như vậy, vì chúng chủ yếu chứa các bài toán đơn giản cho lập trình cạnh tranh—một vấn đề cũng được công nhận bởi công trình trước đây [Hong et al., 2024]. Như vậy, các benchmark như ProjectDev phù hợp hơn để đánh giá hiệu suất của những hệ thống này. Chúng tôi nhận thức rằng MetaGPT trình bày một benchmark tương tự có tên SoftwareDev, và ChatDev thủ công tạo ra một benchmark gọi là Software Requirement Description Dataset (SRDD) cho cùng mục đích. Thật không may, không có benchmark nào trong số này được công bố công khai. Ngược lại, tập dữ liệu của chúng tôi sẽ được phát hành công khai để tạo điều kiện cho nghiên cứu mở trong lĩnh vực này.

5.2 Phân tích
Tác động của Số Sprint Chúng tôi tiến hành nghiên cứu ablation để đánh giá tác động của phát triển tăng dần. Phát triển tăng dần bao gồm nhiều sprint, trong khi việc loại bỏ nó nén quá trình thành một sprint duy nhất. Kết quả trong Bảng 3 cho thấy phát triển tăng dần dẫn đến hiệu suất tốt hơn trên HumanEval và MBPP qua hai mô hình, bao gồm GPT-3.5 Turbo và Claude 3 Haiku. Lợi thế này xuất phát từ việc kế thừa đầu ra từ các sprint trước đó để tinh chỉnh thêm và giải quyết các vấn đề hiện tại trong các lần lặp tiếp theo, do đó tăng khả năng thành công của kết quả.

Tác động của Code Review và Writing Testing Suite Kết quả trong Bảng 3 chứng minh tầm quan trọng của code review và viết test case trong AGILE CODER. Loại bỏ một trong những nhiệm vụ này khỏi sprint dẫn đến suy giảm hiệu suất. Đặc biệt, việc thiếu test case được tạo ra ảnh hưởng đáng kể đến hiệu suất, xác nhận vai trò của chúng trong việc phát hiện lỗi tiềm ẩn và cải thiện

--- TRANG 7 ---
Bảng 3: Nghiên cứu ablation về phát triển tăng dần, code review và writing test suite

Mô hình Tập dữ liệu
HumanEval MBPP
GPT-3.5 Turbo AGILE CODER 70.53 80.92
w/o phát triển tăng dần 69.51 (-1.02) 78.45 (-2.47)
w/o writing test suite 62.20 (-8.33) 75.64 (-5.28)
w/o code review 68.90 (-1.63) 75.41 (-5.51)
Claude 3 Haiku AGILE CODER 79.27 84.31
w/o phát triển tăng dần 76.83 (-2.44) 82.20 (-2.11)
w/o writing test suite 73.17 (-6.10) 79.86 (-4.45)
w/o code review 75.00 (-4.27) 80.56 (-3.75)

chất lượng mã thông qua quá trình sửa lỗi. Ngoài ra, code review đóng góp tích cực vào hiệu suất, vì LLMs có thể thực hiện phân tích mã tĩnh và xác định lỗi.

Tác động của Code Dependency Graph Code Dependency Graph, G, đóng vai trò quan trọng trong AGILE CODER, như được chứng minh bởi kết quả trong Bảng 4. Biến thể của AGILE CODER không có graph G dễ bị vượt quá lỗi độ dài bối cảnh, trong khi AGILE CODER không gặp phải vấn đề này. Đáng chú ý, sự hiện diện của G dẫn đến cải thiện đáng kể trong khả năng thực thi, tăng từ 23.28% lên 57.50%. Việc thiếu graph G có thể dẫn đến thứ tự ngẫu nhiên giữa các testing script, gây ra sự không nhất quán trong quá trình sửa lỗi. Hơn nữa, bỏ qua G có nghĩa là tất cả mã nguồn luôn được bao gồm trong các hướng dẫn, có khả năng làm quá tải và thậm chí gây hại cho LLMs do thông tin không liên quan và tăng chi phí.

Bảng 4: Nghiên cứu ablation về tác động của G. #ExceedingCL là tổng số Vượt quá Độ dài Bối cảnh. Trong trường hợp thiếu G, chúng tôi chỉ xem xét các nhiệm vụ không gặp phải vấn đề Vượt quá Độ dài Bối cảnh.

Chỉ số Thống kê A GILE CODER w/oG
Khả năng thực thi 57.50 23.38
Thời gian Chạy (s) 465 456
Sử dụng Token 36818 37672
Chi phí (USD) 0.44 0.48
#Errors 0 10
#ExceedingCL 0 11

6 Thảo luận & Kết luận
Trong bài báo này, chúng tôi giới thiệu AGILE CODER, một framework phát triển phần mềm đa tác nhân mới lấy cảm hứng từ Phương pháp Agile. Thích ứng quy trình làm việc Agile với bối cảnh đa tác nhân, AGILE CODER nâng cao khả năng thích ứng động và phát triển lặp đi lặp lại. Một đổi mới chính là Dynamic Code Graph Generator (DCGG), tạo ra Code Dependency Graph (CDG) để nắm bắt các mối quan hệ mã đang phát triển.

Các đánh giá toàn diện trên các benchmark đã được thiết lập như HumanEval [Chen et al., 2021], MBPP [Austin et al., 2021a], và benchmark mới được đề xuất của chúng tôi, ProjectDev, xác nhận rằng AGILE CODER đạt được hiệu suất tiên tiến mới, vượt trội so với các mô hình SOTA gần đây như MetaGPT [Hong et al., 2024] và ChatDev [Qian et al., 2023]. Thành công của AGILE CODER làm nổi bật tiềm năng của việc tích hợp Phương pháp Agile và các kỹ thuật phân tích tĩnh vào các framework phát triển phần mềm đa tác nhân.

Rút ra từ quy trình làm việc chuyên nghiệp, Sprint Planning của AGILE CODER phản ánh Dynamic Planning cho các tác nhân, làm cho nó thực tế hơn so với cách tiếp cận kế hoạch đơn lẻ điển hình trong hầu hết các hệ thống. Kết luận, AGILE CODER thể hiện sự kết hợp của Phương pháp Agile, hệ thống đa tác nhân, và phân tích tĩnh, đại diện cho một tiến bộ đáng kể trong tự động hóa phát triển phần mềm.

--- TRANG 8 ---
Hạn chế
Mặc dù AGILE CODER đã chứng minh những tiến bộ đáng kể trong phát triển phần mềm đa tác nhân, có một số lĩnh vực cho công việc tương lai và hạn chế cần được giải quyết. Một hướng nghiên cứu tiềm năng trong tương lai là việc kết hợp các thực hành Agile bổ sung vào framework. Ví dụ, tích hợp pair programming hoặc các kỹ thuật tích hợp và triển khai liên tục (CI/CD) có thể nâng cao thêm sự cộng tác và hiệu quả của hệ thống đa tác nhân. Khám phá việc thích ứng các phương pháp Agile khác, như Kanban hoặc Lean, cũng có thể cung cấp những hiểu biết và cải thiện có giá trị cho framework.

Một lĩnh vực khác cho công việc tương lai là mở rộng AGILE CODER sang các lĩnh vực ngoài phát triển phần mềm. Các nguyên tắc của Phương pháp Agile và cách tiếp cận đa tác nhân có thể được áp dụng cho các nhiệm vụ phức tạp, lặp đi lặp lại khác như thiết kế sản phẩm, quản lý dự án, hoặc nghiên cứu khoa học. Điều tra khả năng tổng quát hóa của framework cho những lĩnh vực này có thể dẫn đến các ứng dụng và tiến bộ mới trong nhiều lĩnh vực khác nhau.

Tuy nhiên, AGILE CODER cũng có một số hạn chế cần được thừa nhận. Một hạn chế là sự phụ thuộc vào LLMs cho việc tạo mã và ra quyết định. Trong khi việc tích hợp phân tích tĩnh thông qua DCGG giúp giảm thiểu một số hạn chế của LLMs, vẫn có thể có các trường hợp mà mã được tạo ra không tối ưu hoặc không đáp ứng đầy đủ các yêu cầu. Nghiên cứu thêm về việc cải thiện độ bền vững và độ tin cậy của việc tạo mã dựa trên LLM có thể giúp giải quyết hạn chế này.

Một hạn chế khác là các vấn đề về khả năng mở rộng tiềm năng khi xử lý các dự án phần mềm lớn, phức tạp. Khi codebase tăng trưởng, tài nguyên tính toán cần thiết để duy trì và cập nhật CDG có thể trở nên khó khăn. Công việc tương lai có thể khám phá các tối ưu hóa cho DCGG hoặc các cách tiếp cận thay thế cho việc truy xuất bối cảnh có thể xử lý các dự án quy mô lớn hơn một cách hiệu quả hơn. Cuối cùng, việc triển khai hiện tại của AGILE CODER tập trung chủ yếu vào các khía cạnh kỹ thuật của phát triển phần mềm, như tạo mã và kiểm thử. Tuy nhiên, phát triển Agile thế giới thực cũng bao gồm các yếu tố phi kỹ thuật quan trọng, như động lực nhóm, giao tiếp, và quản lý dự án. Kết hợp những khía cạnh này vào framework đa tác nhân có thể cung cấp mô phỏng toàn diện và thực tế hơn về phát triển phần mềm Agile. Mặc dù có những hạn chế này, AGILE CODER đại diện cho một bước tiến đáng kể trong việc tự động hóa phát triển phần mềm sử dụng hệ thống đa tác nhân và Phương pháp Agile. Bằng cách giải quyết những hạn chế này và khám phá tiềm năng cho công việc tương lai, các nhà nghiên cứu có thể tiếp tục đẩy ranh giới của những gì có thể trong lĩnh vực thú vị này.

Tài liệu tham khảo
Tuyên ngôn cho phát triển phần mềm agile. https://agilemanifesto.org/ , 2001.
Hướng dẫn agile cho các quy trình lập kế hoạch. https://www.pmi.org/learning/library/
agile-guide-planning-agile-approach-6837 , 2024. Truy cập: ngày-truy-cập.
Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman,
Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. Báo cáo kỹ thuật gpt-4.
arXiv preprint arXiv:2303.08774 , 2023.
Lakshya A Agrawal, Aditya Kanade, Navin Goyal, Shuvendu K Lahiri, và Sriram K Rajamani. Hướng dẫn 
các mô hình ngôn ngữ của mã với bối cảnh toàn cục sử dụng monitor. arXiv preprint arXiv:2306.10763 ,
2023.
Loubna Ben Allal, Raymond Li, Denis Kocetkov, Chenghao Mou, Christopher Akiki, Carlos Munoz
Ferrandis, Niklas Muennighoff, Mayank Mishra, Alex Gu, Manan Dey, et al. Santacoder: đừng
với tới các ngôi sao! arXiv preprint arXiv:2301.03988 , 2023.
Miltiadis Allamanis, Earl T Barr, Premkumar Devanbu, và Charles Sutton. Một khảo sát về machine
learning cho big code và tính tự nhiên. ACM Computing Surveys (CSUR) , 51(4):1–37, 2018.
AI Anthropic. Giới thiệu thế hệ tiếp theo của claude, 2024.

--- TRANG 9 ---
Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan,
Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, et al. Tổng hợp chương trình với các mô hình ngôn ngữ lớn.
arXiv preprint arXiv:2108.07732 , 2021a.
Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan,
Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, et al. Tổng hợp chương trình với các mô hình ngôn ngữ lớn.
arXiv preprint arXiv:2108.07732 , 2021b.
Ramakrishna Bairi, Atharv Sonwane, Aditya Kanade, Arun Iyer, Suresh Parthasarathy, Sriram
Rajamani, B Ashok, Shashank Shet, et al. Codeplan: Mã hóa cấp độ kho lưu trữ sử dụng llms và
lập kế hoạch. arXiv preprint arXiv:2309.12499 , 2023.
Matej Balog, Alexander L Gaunt, Marc Brockschmidt, Sebastian Nowozin, và Daniel Tarlow.
Deepcoder: Học viết chương trình. arXiv preprint arXiv:1611.01989 , 2016.
Youssef Bassil. Một mô hình mô phỏng cho chu trình phát triển phần mềm waterfall. CoRR ,
abs/1205.6904, 2012. URL http://arxiv.org/abs/1205.6904 .
Nghi DQ Bui và Lingxiao Jiang. Học tập phân cấp các ánh xạ ngôn ngữ chéo thông qua
biểu diễn vector phân tán cho mã. In Proceedings of the 40th International Conference
on Software Engineering: New Ideas and Emerging Results , trang 33–36, 2018.
Nghi DQ Bui, Yijun Yu, và Lingxiao Jiang. Treecaps: Mạng capsule dựa trên cây cho xử lý
mã nguồn. In Proceedings of the AAAI Conference on Artificial Intelligence , tập 35, trang
30–38, 2021.
Nghi DQ Bui, Yue Wang, và Steven Hoi. Detect-localize-repair: Một framework thống nhất cho
học gỡ lỗi với codet5. arXiv preprint arXiv:2211.14875 , 2022.
Nghi DQ Bui, Hung Le, Yue Wang, Junnan Li, Akhilesh Deepak Gotmare, và Steven CH Hoi. Codetf:
Thư viện transformer một cửa cho code llm tiên tiến. arXiv preprint arXiv:2306.00029 , 2023.
Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared
Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, et al. Đánh giá các mô hình
ngôn ngữ lớn được huấn luyện trên mã. arXiv preprint arXiv:2107.03374 , 2021.
Weize Chen, Yusheng Su, Jingwei Zuo, Cheng Yang, Chenfei Yuan, Chen Qian, Chi-Min Chan, Yujia
Qin, Yaxi Lu, Ruobing Xie, et al. Agentverse: Tạo điều kiện cộng tác đa tác nhân và khám phá
các hành vi nổi lên trong tác nhân. arXiv preprint arXiv:2308.10848 , 2023.
Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam
Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. Palm:
Mở rộng mô hình hóa ngôn ngữ với pathways. Journal of Machine Learning Research , 24(240):
1–113, 2023.
Yilun Du, Shuang Li, Antonio Torralba, Joshua B Tenenbaum, và Igor Mordatch. Cải thiện tính
thực tế và lý luận trong các mô hình ngôn ngữ thông qua tranh luận đa tác nhân. arXiv preprint
arXiv:2305.14325 , 2023.
Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing
Qin, Ting Liu, Daxin Jiang, et al. Codebert: Một mô hình được tiền huấn luyện cho lập trình và
ngôn ngữ tự nhiên. arXiv preprint arXiv:2002.08155 , 2020.
Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Shujie Liu, Long Zhou, Nan Duan,
Alexey Svyatkovskiy, Shengyu Fu, et al. Graphcodebert: Tiền huấn luyện biểu diễn mã với
luồng dữ liệu. arXiv preprint arXiv:2009.08366 , 2020.
Daya Guo, Shuai Lu, Nan Duan, Yanlin Wang, Ming Zhou, và Jian Yin. Unixcoder: Tiền huấn luyện
đa phương thức thống nhất cho biểu diễn mã. arXiv preprint arXiv:2203.03850 , 2022.
Daya Guo, Qihao Zhu, Dejian Yang, Zhenda Xie, Kai Dong, Wentao Zhang, Guanting Chen, Xiao
Bi, Y Wu, YK Li, et al. Deepseek-coder: Khi mô hình ngôn ngữ lớn gặp lập trình–sự nổi lên của
trí tuệ mã. arXiv preprint arXiv:2401.14196 , 2024a.

--- TRANG 10 ---
Taicheng Guo, Xiuying Chen, Yaqi Wang, Ruidi Chang, Shichao Pei, Nitesh V Chawla, Olaf Wiest,
và Xiangliang Zhang. Khảo sát về các tác nhân đa dựa trên mô hình ngôn ngữ lớn: Tiến độ và
thách thức. arXiv preprint arXiv:2402.01680 , 2024b.
Dan Hendrycks, Steven Basart, Saurav Kadavath, Mantas Mazeika, Akul Arora, Ethan Guo, Collin
Burns, Samir Puranik, Horace He, Dawn Song, et al. Đo lường năng lực thách thức mã hóa
với apps (2021). arXiv preprint arXiv:2105.09938 , 2021.
Sirui Hong, Mingchen Zhuge, Jonathan Chen, Xiawu Zheng, Yuheng Cheng, Jinlin Wang, Ceyao
Zhang, Zili Wang, Steven Ka Shing Yau, Zijuan Lin, Liyang Zhou, Chenyu Ran, Lingfeng
Xiao, Chenglin Wu, và Jürgen Schmidhuber. MetaGPT: Meta programming cho framework
cộng tác đa tác nhân. In The Twelfth International Conference on Learning Representations ,
2024. URL https://openreview.net/forum?id=VtmBAGCN7o .
Dong Huang, Qingwen Bu, Jie M Zhang, Michael Luck, và Heming Cui. Agentcoder: Tạo mã
dựa trên đa tác nhân với kiểm thử và tối ưu hóa lặp đi lặp lại. arXiv preprint arXiv:2312.13010 ,
2023.
Carlos E Jimenez, John Yang, Alexander Wettig, Shunyu Yao, Kexin Pei, Ofir Press, và Karthik
Narasimhan. Swe-bench: Các mô hình ngôn ngữ có thể giải quyết các vấn đề github thế giới thực
không? arXiv preprint arXiv:2310.06770 , 2023.
Raymond Li, Loubna Ben Allal, Yangtian Zi, Niklas Muennighoff, Denis Kocetkov, Chenghao Mou,
Marc Marone, Christopher Akiki, Jia Li, Jenny Chim, et al. Starcoder: cầu nguồn ở cùng
bạn! arXiv preprint arXiv:2305.06161 , 2023.
Feng Lin, Dong Jae Kim, et al. Khi tạo mã dựa trên llm gặp quy trình phát triển phần mềm.
arXiv preprint arXiv:2403.15852 , 2024.
Tianyang Liu, Canwen Xu, và Julian McAuley. Repobench: Benchmarking hệ thống tự động hoàn thành
mã cấp độ kho lưu trữ. arXiv preprint arXiv:2306.03091 , 2023.
Anton Lozhkov, Raymond Li, Loubna Ben Allal, Federico Cassano, Joel Lamy-Poirier, Nouamane
Tazi, Ao Tang, Dmytro Pykhtar, Jiawei Liu, Yuxiang Wei, et al. Starcoder 2 và stack v2: Thế hệ
tiếp theo. arXiv preprint arXiv:2402.19173 , 2024.
Qinyu Luo, Yining Ye, Shihao Liang, Zhong Zhang, Yujia Qin, Yaxi Lu, Yesai Wu, Xin Cong, Yankai
Lin, Yingli Zhang, et al. Repoagent: Framework mã nguồn mở được hỗ trợ bởi llm để tạo tài liệu
mã cấp độ kho lưu trữ. arXiv preprint arXiv:2402.16667 , 2024.
Ziyang Luo, Can Xu, Pu Zhao, Qingfeng Sun, Xiubo Geng, Wenxiang Hu, Chongyang Tao, Jing
Ma, Qingwei Lin, và Daxin Jiang. Wizardcoder: Trao quyền cho các mô hình ngôn ngữ lớn mã
với evol-instruct. arXiv preprint arXiv:2306.08568 , 2023.
Potsawee Manakul, Adian Liusie, và Mark Gales. SelfCheckGPT: Phát hiện ảo giác hộp đen không
tài nguyên cho các mô hình ngôn ngữ lớn tạo sinh. In Houda Bouamor, Juan Pino, và
Kalika Bali, biên tập, Proceedings of the 2023 Conference on Empirical Methods in Natural Lan-
guage Processing , trang 9004–9017, Singapore, Tháng 12 2023. Association for Computational
Linguistics. doi: 10.18653/v1/2023.emnlp-main.557. URL https://aclanthology.org/2023.
emnlp-main.557 .
Erik Nijkamp, Bo Pang, Hiroaki Hayashi, Lifu Tu, Huan Wang, Yingbo Zhou, Silvio Savarese, và
Caiming Xiong. Codegen: Một mô hình ngôn ngữ lớn mở cho mã với tổng hợp chương trình
nhiều lượt. arXiv preprint arXiv:2203.13474 , 2022.
Huy N Phan, Hoang N Phan, Tien N Nguyen, và Nghi DQ Bui. Repohyper: Truy xuất bối cảnh
tốt hơn là tất cả những gì bạn cần để hoàn thành mã cấp độ kho lưu trữ. arXiv preprint arXiv:2403.06095 , 2024.
Nikhil Pinnaparaju, Reshinth Adithyan, Duy Phung, Jonathan Tow, James Baicoianu, Ashish Datta,
Maksym Zhuravinskyi, Dakota Mahan, Marco Bellagente, Carlos Riquelme, et al. Báo cáo kỹ thuật
stable code. arXiv preprint arXiv:2404.01226 , 2024.

--- TRANG 11 ---
Chen Qian, Xin Cong, Cheng Yang, Weize Chen, Yusheng Su, Juyuan Xu, Zhiyuan Liu, và Maosong
Sun. Các tác nhân giao tiếp cho phát triển phần mềm. arXiv preprint arXiv:2307.07924 , 2023.
Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi
Adi, Jingyu Liu, Tal Remez, Jérémy Rapin, et al. Code llama: Các mô hình nền tảng mở cho mã.
arXiv preprint arXiv:2308.12950 , 2023.
Disha Shrivastava, Denis Kocetkov, Harm de Vries, Dzmitry Bahdanau, và Torsten Scholak. Repo-
fusion: Huấn luyện các mô hình mã để hiểu kho lưu trữ của bạn. arXiv preprint arXiv:2306.10998 ,
2023a.
Disha Shrivastava, Hugo Larochelle, và Daniel Tarlow. Tạo prompt cấp độ kho lưu trữ cho các mô hình
ngôn ngữ lớn của mã. In International Conference on Machine Learning , trang 31693–31715.
PMLR, 2023b.
Daniel Tang, Zhenghan Chen, Kisub Kim, Yewei Song, Haoye Tian, Saad Ezzini, Yongfeng Huang,
và Jacques Klein Tegawende F Bissyande. Các tác nhân cộng tác cho kỹ thuật phần mềm. arXiv
preprint arXiv:2402.02172 , 2024.
Lei Wang, Chen Ma, Xueyang Feng, Zeyu Zhang, Hao Yang, Jingsen Zhang, Zhiyuan Chen, Jiakai
Tang, Xu Chen, Yankai Lin, et al. Khảo sát về các tác nhân tự động dựa trên mô hình ngôn ngữ lớn.
Frontiers of Computer Science , 18(6):186345, 2024.
Yue Wang, Weishi Wang, Shafiq Joty, và Steven CH Hoi. Codet5: Các mô hình encoder-decoder
được tiền huấn luyện thống nhất nhận biết định danh cho hiểu biết và tạo mã. arXiv preprint
arXiv:2109.00859 , 2021.
Yue Wang, Hung Le, Akhilesh Deepak Gotmare, Nghi DQ Bui, Junnan Li, và Steven CH Hoi.
Codet5+: Các mô hình ngôn ngữ lớn mã mở cho hiểu biết và tạo mã. arXiv preprint
arXiv:2305.07922 , 2023.
Frank F Xu, Uri Alon, Graham Neubig, và Vincent Josua Hellendoorn. Đánh giá hệ thống các mô hình
ngôn ngữ lớn của mã. In Proceedings of the 6th ACM SIGPLAN International Symposium
on Machine Programming , trang 1–10, 2022.
John Yang, Carlos E Jimenez, Alexander Wettig, Kilian Lieret, Shunyu Yao, Karthik Narasimhan,
và Ofir Press. Swe-agent: Giao diện tác nhân-máy tính cho phép kỹ thuật phần mềm tự động.
arXiv preprint arXiv:2405.15793 , 2024.
Kechi Zhang, Jia Li, Ge Li, Xianjie Shi, và Zhi Jin. Codeagent: Nâng cao tạo mã với hệ thống
tác nhân tích hợp công cụ cho thách thức mã hóa cấp độ repo thế giới thực. arXiv preprint
arXiv:2401.07339 , 2024.
Qinkai Zheng, Xiao Xia, Xu Zou, Yuxiao Dong, Shan Wang, Yufei Xue, Zihan Wang, Lei Shen,
Andi Wang, Yang Li, et al. Codegeex: Một mô hình được tiền huấn luyện cho tạo mã với đánh giá
đa ngôn ngữ trên humaneval-x. arXiv preprint arXiv:2303.17568 , 2023.
Tianyu Zheng, Ge Zhang, Tianhao Shen, Xueling Liu, Bill Yuchen Lin, Jie Fu, Wenhu Chen, và
Xiang Yue. Opencodeinterpreter: Tích hợp tạo mã với thực thi và tinh chỉnh. arXiv preprint
arXiv:2402.14658 , 2024.
Li Zhong, Zilong Wang, và Jingbo Shang. Ldb: Một trình gỡ lỗi mô hình ngôn ngữ lớn thông qua
xác minh thực thi runtime từng bước. arXiv preprint arXiv:2402.16906 , 2024.
Andy Zhou, Kai Yan, Michal Shlapentokh-Rothman, Haohan Wang, và Yu-Xiong Wang. Tìm kiếm
cây tác nhân ngôn ngữ thống nhất lý luận hành động và lập kế hoạch trong các mô hình ngôn ngữ.
arXiv preprint arXiv:2310.04406 , 2023.

--- TRANG 12 ---
A Phụ lục
A.1 Thiết lập Thực nghiệm
Trong đánh giá của chúng tôi, chúng tôi sử dụng GPT-3.5-Turbo-0613 và claude-3-haiku@20240307, và chúng tôi đặt
nhiệt độ ở 0.2, và top_p ở 1, phù hợp với công trình trước đây [Qian et al., 2023].
HumanEval [Chen et al., 2021] bao gồm 164 bài toán lập trình được viết tay, MBPP [Austin
et al., 2021a] bao gồm 427 nhiệm vụ Python, và ProjectDev bao gồm 14 nhiệm vụ phát triển phần mềm.
Đối với mỗi tập dữ liệu, mỗi mẫu hoặc nhiệm vụ được thực thi ba lần, và kết quả trung bình được báo cáo,
ngoại trừ #Errors và #ExceedingCL, được trình bày dưới dạng tổng số.

A.2 Chi tiết thêm về Phân tích
A.2.1 Tác động của Code Review Ba bước
Trong Phần 4.2.2, chúng tôi giới thiệu code review ba bước để tiến hành kiểm tra tĩnh cho
tính đúng đắn của mã nguồn. Quy trình chi tiết như sau:
1.Kiểm tra Triển khai Cơ bản: Xác minh các điều cơ bản của triển khai, như sự hiện diện
của các method rỗng (ví dụ: pass trong Python), tính đầy đủ của docstring, và sự hoàn thiện của
import statement.
2.Tuân thủ Backlog: Đánh giá liệu mã nguồn có thực hiện các nhiệm vụ được liệt kê trong sprint
backlog và bao gồm tất cả các tính năng được chỉ định.
3.Đáp ứng Tiêu chí và Xác định Lỗi: Đánh giá cuối cùng để đảm bảo mã đáp ứng
tiêu chí chấp nhận của sprint và không có lỗi tiềm ẩn.

Chúng tôi tiến hành phân tích để chứng minh tác động của code review ba bước được đề xuất của chúng tôi bằng cách
so sánh AGILE CODER với biến thể của nó, nơi ba bước được nén thành một bước duy nhất.
Kết quả trong Bảng 5 cho thấy việc chia code review thành ba bước cải thiện độ chính xác. Điều này là
vì chiến lược prompting nhiều bước cho phép LLMs thực hiện phân tích tĩnh hiệu quả hơn
và cung cấp phản hồi chính xác hơn. Ngược lại, đánh giá một bước bao gồm hướng dẫn
bao quát tất cả các ràng buộc mong muốn, làm cho nó thách thức hơn cho LLMs hiểu và tuân theo,
do đó giảm hiệu quả tổng thể.

Bảng 5: Nghiên cứu ablation về chiến lược prompting ba bước của chúng tôi cho code review
Mô hình HumanEval
GPT-3.5 Turbo AGILE CODER 70.53
w/o đánh giá ba bước 67.68 (-2.85)
Claude 3 Haiku AGILE CODER 79.27
w/o đánh giá ba bước 75.61 (-3.66)

A.2.2 Error Bar
Ngoài kết quả chính trong Phần 5.1, chúng tôi cũng báo cáo error bar để chứng minh độ bền vững của
phương pháp chúng tôi, AGILE CODER, dưới các lần chạy khác nhau. Kết quả trong Bảng 6 cho thấy AGILE CODER thể hiện
chỉ có biến động nhỏ qua các lần chạy khác nhau.

Bảng 6: Error bar của A GILE CODER trên HumanEval và MBPP
Mô hình Tập dữ liệu
HumanEval MBPP
GPT-3.5 Turbo 70.53±0.70 80.92±0.83
Claude 3 Haiku 79.27±0.86 84.31±0.34

--- TRANG 13 ---
A.2.3 Phân tích Khả năng
Trong phần này, chúng tôi cung cấp phân tích về khả năng của các framework đa tác nhân cho
các nhiệm vụ kỹ thuật phần mềm. Như được trình bày trong Bảng 7, so với ChatDev [Qian et al., 2023] và MetaGPT
[Hong et al., 2024], AGILE CODER có ba khả năng bổ sung, bao gồm tiến độ linh hoạt,
phát triển tăng dần, và mô hình hóa phụ thuộc file. Kết hợp những tính năng này có thể nâng cao
khả năng thực hiện các nhiệm vụ kỹ thuật phần mềm.

Bảng 7: So sánh với các framework đa tác nhân khác
Framework Khả năng ChatDev MetaGPT A GILE CODER
Tạo mã ✓ ✓ ✓
Quản lý nhiệm vụ dựa trên vai trò ✓ ✓ ✓
Code review ✓ ✓ ✓
Tiến độ linh hoạt ✗ ✗ ✓
Phát triển tăng dần ✗ ✗ ✓
Mô hình hóa phụ thuộc file ✗ ✗ ✓

A.2.4 Ví dụ về Code Dependency Graph
Trong Phần 4.3, chúng tôi đề xuất một dependency graph mới G mô hình hóa mối quan hệ giữa các file mã.
Hình 3 cung cấp một ví dụ minh họa về graph G với mỗi node đại diện cho một file mã. File
library.py phụ thuộc vào file book.py, vì vậy có một cạnh từ library.py đến book.py.

Hình 3: Một ví dụ về Code Dependency Graph

A.3 Chi tiết Đánh giá cho ProjectDev
Trong phần này, chúng tôi trình bày quy trình đánh giá chi tiết và ProjectDev. Chúng tôi sử dụng GPT-3.5-
Turbo-0613 làm mô hình backend.

A.3.1 Các Bước Đánh giá
Toàn bộ quy trình đánh giá được tiến hành thủ công để đảm bảo tính đúng đắn của kết quả đánh giá.
Người tham gia là các nhà phát triển có kinh nghiệm với ít nhất hai năm kinh nghiệm lập trình Python.
Đối với mỗi nhiệm vụ, chúng tôi chạy một phương pháp ba lần sử dụng cùng prompt, tạo ra một chương trình cho mỗi
lần chạy. Đối với mỗi chương trình được tạo ra, chúng tôi cố gắng thực thi chương trình này. Nếu chương trình có thể thực thi được,
chúng tôi đánh giá nó so với tất cả các yêu cầu dự kiến. Điểm số cuối cùng được xác định bởi tỷ lệ phần trăm
yêu cầu mà chương trình đáp ứng. Dưới đây là pseudocode để đánh giá từng nhiệm vụ từng bước:

A.3.2 Tập dữ liệu ProjectDev
Task Id: 1
Task: Trò chơi Snake

--- TRANG 14 ---
1:Input: Một nhiệm vụ t và các chương trình tương ứng được tạo ra bởi ChatDev, MetaGPT, và AGILE -
CODER
2:Output: Điểm số cuối cùng dưới dạng phần trăm
3:Tải các chương trình được tạo ra từ ChatDev, MetaGPT, và AGILE CODER tương ứng với
nhiệm vụ t
4:Tải danh sách yêu cầu của nhiệm vụ t từ tập dữ liệu ProjectDev
5:Khởi tạo requirements_met bằng 0
6:Khởi tạo total_requirements bằng độ dài của danh sách yêu cầu
7:Cố gắng chạy mỗi chương trình
8:nếu chương trình có thể thực thi được thì
9: với mỗi yêu cầu r trong danh sách yêu cầu làm
10: nếu yêu cầu r được đáp ứng thì
11: Tăng requirements_met lên 1
12: kết thúc nếu
13: kết thúc với
14:kết thúc nếu
15:Tính final_score như (requirements _met/total _requirements )×100%
16:trả về final_score

Prompt: Tạo một trò chơi rắn
Yêu cầu:
•Bảng Trò chơi:
⋄Tạo một bảng trò chơi dựa trên lưới.
⋄Định nghĩa kích thước của lưới (ví dụ: 10x10).
⋄Hiển thị lưới trên màn hình.
•Khởi tạo Rắn:
⋄Đặt rắn trên bảng trò chơi.
⋄Định nghĩa chiều dài ban đầu và vị trí bắt đầu của rắn.
⋄Chọn một hướng để rắn bắt đầu di chuyển (ví dụ: phải).
•Chuyển động Rắn:
⋄Triển khai điều khiển phím mũi tên cho chuyển động rắn.
⋄Đảm bảo rắn di chuyển liên tục theo hướng đã chọn.
⋄Cập nhật vị trí của rắn trên lưới.
•Tạo Thức ăn:
⋄Tạo thức ăn ở các vị trí ngẫu nhiên trên bảng trò chơi.
⋄Đảm bảo thức ăn không xuất hiện trên thân rắn.
•Xử lý Va chạm:
⋄Phát hiện va chạm giữa rắn và ranh giới bảng trò chơi.
⋄Phát hiện va chạm giữa đầu rắn và thân của nó.
⋄Phát hiện va chạm giữa đầu rắn và thức ăn.
•Tăng trưởng Rắn:
⋄Tăng chiều dài của rắn khi nó tiêu thụ thức ăn.
⋄Thêm một đoạn mới vào thân rắn.
•Hiển thị Điểm số:
⋄Triển khai hệ thống tính điểm.
⋄Hiển thị điểm số hiện tại trên màn hình.
•Điều kiện Kết thúc Trò chơi:
⋄Kích hoạt tình huống kết thúc trò chơi khi rắn va chạm với ranh giới.
⋄Kích hoạt tình huống kết thúc trò chơi khi rắn va chạm với thân của chính nó.

--- TRANG 15 ---
⋄Hiển thị thông báo kết thúc trò chơi.
⋄Cho phép người chơi khởi động lại trò chơi.
•Đồ họa và Giao diện Người dùng:
⋄Sử dụng đồ họa hoặc ký tự ASCII để đại diện cho rắn và thức ăn.
⋄Thiết kế giao diện thân thiện với người dùng với hướng dẫn rõ ràng và hiển thị điểm số.
•Hoạt ảnh và Hiệu ứng:
⋄Thêm hoạt ảnh cho chuyển động và tăng trưởng của rắn.
⋄Triển khai hiệu ứng hình ảnh cho va chạm và tiêu thụ thức ăn.

Task Id: 2
Task: Trò chơi đập gạch
Prompt: Tạo một trò chơi đập gạch
Yêu cầu:
•Bảng Trò chơi:
⋄Tạo một bảng trò chơi với bố cục dựa trên lưới.
⋄Định nghĩa kích thước của bảng trò chơi.
⋄Hiển thị bảng trò chơi trên màn hình.
•Thiết lập Paddle:
⋄Thêm một paddle ở dưới cùng của màn hình.
⋄Cho phép người chơi điều khiển paddle bằng bàn phím hoặc điều khiển cảm ứng.
•Hình thành Gạch:
⋄Tạo ra một hình thành gạch ở trên cùng của màn hình.
⋄Định nghĩa số hàng và cột của gạch.
⋄Gán các màu sắc hoặc loại khác nhau cho gạch.
•Khởi tạo Bóng:
⋄Đặt một quả bóng trên paddle ở đầu trò chơi.
⋄Cho phép người chơi phóng bóng.
•Chuyển động Bóng:
⋄Triển khai vật lý cho chuyển động của bóng.
⋄Cho phép bóng nảy off tường, paddle, và gạch.
⋄Cập nhật vị trí của bóng liên tục.
•Phát hiện Va chạm:
⋄Phát hiện va chạm giữa bóng và paddle.
⋄Phát hiện va chạm giữa bóng và gạch.
⋄Xử lý các loại va chạm khác nhau một cách thích hợp.
•Phá hủy Gạch:
⋄Loại bỏ gạch khi bóng va chạm với nó.
⋄Triển khai điểm số khác nhau cho các loại gạch khác nhau.
⋄Theo dõi số lượng gạch còn lại.
•Hệ thống Tính điểm:
⋄Triển khai hệ thống tính điểm dựa trên gạch bị phá hủy.
⋄Hiển thị điểm số hiện tại trên màn hình.
•Power-up:
⋄Giới thiệu power-up rơi xuống khi một số gạch nhất định bị phá hủy.
⋄Triển khai power-up như bóng thêm, paddle lớn hơn, hoặc tốc độ bóng chậm hơn.
•Cấp độ Trò chơi:
⋄Tạo nhiều cấp độ với độ khó tăng dần.

--- TRANG 16 ---
⋄Thiết kế hình thành gạch mới cho mỗi cấp độ.
•Điều kiện Kết thúc Trò chơi:
⋄Kết thúc trò chơi khi bóng đi xuống dưới paddle.
⋄Hiển thị thông báo kết thúc trò chơi.
⋄Cho phép người chơi khởi động lại trò chơi.
•Đồ họa và Giao diện Người dùng:
⋄Sử dụng đồ họa để đại diện cho gạch, paddle, và bóng.
⋄Thiết kế giao diện thân thiện với người dùng với hướng dẫn rõ ràng và hiển thị điểm số.

Task Id: 3
Task: Trò chơi 2048
Prompt: Tạo một trò chơi 2048
Yêu cầu:
•Bảng Trò chơi:
⋄Tạo một lưới 4x4 làm bảng trò chơi.
⋄Hiển thị lưới trên trang web.
•Tạo Ô:
⋄Tạo hai ô ban đầu với giá trị 2 hoặc 4 ở các vị trí ngẫu nhiên trên lưới.
⋄Cập nhật hiển thị để hiển thị các ô ban đầu.
•Chuyển động Ô:
⋄Triển khai điều khiển phím mũi tên cho chuyển động ô (lên, xuống, trái, phải).
⋄Cho phép các ô trượt theo hướng đã chọn cho đến khi chúng gặp ranh giới lưới hoặc
ô khác.
⋄Kết hợp các ô có cùng giá trị khi chúng va chạm.
•Theo dõi Điểm số:
⋄Triển khai hệ thống tính điểm.
⋄Hiển thị điểm số hiện tại trên trang web.
⋄Cập nhật điểm số khi các ô được kết hợp.
•Điều kiện Chiến thắng:
⋄Định nghĩa điều kiện chiến thắng là đạt được giá trị ô 2048.
⋄Hiển thị thông báo chiến thắng khi người chơi đạt được điều kiện chiến thắng.
⋄Cho phép người chơi tiếp tục chơi sau khi chiến thắng.
•Điều kiện Kết thúc Trò chơi:
⋄Triển khai tình huống kết thúc trò chơi khi không còn nước đi hợp lệ nào.
⋄Hiển thị thông báo kết thúc trò chơi.
⋄Cho phép người chơi khởi động lại trò chơi.
•Hoạt ảnh và Chuyển tiếp:
⋄Thêm hoạt ảnh mượt mà cho chuyển động ô.
⋄Triển khai chuyển tiếp cho việc hợp nhất ô.
•Đồ họa và Styling:
⋄Sử dụng đồ họa hoặc số được cách điệu để đại diện cho các giá trị ô khác nhau.

Task Id: 4
Task: Trò chơi Flappy bird
Prompt: Viết mã cho Flappy Bird bằng python nơi bạn điều khiển một con chim màu vàng bay liên tục
qua một loạt ống màu xanh. Con chim vẫy cánh mỗi khi bạn click chuột trái. Nếu nó
rơi xuống đất hoặc đâm vào ống, bạn thua. Trò chơi này tiếp tục vô hạn cho đến khi bạn thua; bạn được
điểm càng xa bạn đi.
Yêu cầu:

--- TRANG 17 ---
•Các Yếu tố Trò chơi:
⋄Tạo một con chim màu vàng làm nhân vật chính.
⋄Thiết kế các ống màu xanh để con chim điều hướng qua.
⋄Thiết lập mặt đất hoặc nền cho trò chơi.
•Chuyển động Con chim:
⋄Triển khai chuyển động tiến về phía trước liên tục của con chim.
⋄Làm cho con chim rơi do trọng lực.
⋄Cho phép con chim nhảy hoặc "vẫy cánh" khi nút chuột trái được click.
•Tạo Ống:
⋄Tạo ra một loạt ống với khoảng cách đều.
⋄Ngẫu nhiên hóa chiều cao của khoảng trống giữa các ống.
⋄Loại bỏ ống khỏi màn hình khi chúng di chuyển ra ngoài phía bên trái.
•Phát hiện Va chạm:
⋄Phát hiện va chạm giữa con chim và mặt đất.
⋄Phát hiện va chạm giữa con chim và các ống.
•Theo dõi Điểm số:
⋄Triển khai hệ thống tính điểm dựa trên khoảng cách di chuyển.
⋄Hiển thị điểm số hiện tại trên màn hình.
•Điều kiện Kết thúc Trò chơi:
⋄Kích hoạt tình huống kết thúc trò chơi khi con chim đâm vào mặt đất.
⋄Kích hoạt tình huống kết thúc trò chơi khi con chim đâm vào ống.
⋄Hiển thị thông báo kết thúc trò chơi.
⋄Cho phép người chơi khởi động lại trò chơi.
•Hoạt ảnh và Hiệu ứng:
⋄Thêm hoạt ảnh cho vẫy cánh con chim, chuyển động ống, và chuyển tiếp kết thúc trò chơi.
⋄Triển khai hiệu ứng hình ảnh cho va chạm.

Task Id: 5
Task: Trò chơi chiến đấu xe tăng
Prompt: Tạo một trò chơi chiến đấu xe tăng
Yêu cầu:
•Bảng Trò chơi:
⋄Tạo một bảng trò chơi dựa trên lưới đại diện cho chiến trường.
⋄Định nghĩa kích thước của lưới.
⋄Hiển thị lưới trên màn hình.
•Khởi tạo Xe tăng:
⋄Đặt hai xe tăng trên bảng trò chơi cho trò chơi hai người chơi.
⋄Đặt vị trí ban đầu cho mỗi xe tăng.
⋄Cho phép người chơi điều khiển xe tăng của họ bằng điều khiển bàn phím.
•Chướng ngại vật:
⋄Tạo ra chướng ngại vật (ví dụ: tường, rào cản) trên bảng trò chơi.
⋄Đảm bảo chướng ngại vật được đặt một cách chiến lược để tạo ra chiến trường đầy thách thức.
•Chuyển động Xe tăng:
⋄Triển khai điều khiển cho chuyển động xe tăng (ví dụ: tiến, lùi, quay trái, quay
phải).
⋄Cho phép xe tăng di chuyển tự do trên lưới.
⋄Hạn chế chuyển động xe tăng khi va chạm với chướng ngại vật.
•Bắn Xe tăng:

--- TRANG 18 ---
⋄Triển khai điều khiển để bắn đạn (ví dụ: đạn, tên lửa).
⋄Giới hạn tốc độ bắn để ngăn chặn spam.
⋄Hiển thị đạn trên màn hình.
•Va chạm Đạn:
⋄Phát hiện va chạm giữa đạn và xe tăng.
⋄Gây sát thương cho xe tăng khi bị đạn trúng.
⋄Loại bỏ đạn khi chúng va chạm với chướng ngại vật hoặc ra khỏi màn hình.
•Sức khỏe và Sát thương:
⋄Gán giá trị sức khỏe cho xe tăng.
⋄Hiển thị thanh sức khỏe cho mỗi xe tăng.
⋄Kích hoạt nổ hoặc hiệu ứng hình ảnh khi xe tăng bị phá hủy.
•Hệ thống Tính điểm:
⋄Triển khai hệ thống tính điểm dựa trên số xe tăng bị phá hủy.
⋄Hiển thị điểm số hiện tại trên màn hình.
•Điều kiện Kết thúc Trò chơi:
⋄Kích hoạt tình huống kết thúc trò chơi khi sức khỏe xe tăng về không.
⋄Hiển thị thông báo kết thúc trò chơi.
⋄Cho phép người chơi khởi động lại trò chơi.
•Đồ họa và Giao diện Người dùng:
⋄Sử dụng đồ họa để đại diện cho xe tăng, đạn, và chướng ngại vật.
⋄Thiết kế giao diện thân thiện với người dùng với hướng dẫn rõ ràng và hiển thị điểm số.
•Hoạt ảnh và Hiệu ứng:
⋄Thêm hoạt ảnh cho chuyển động xe tăng, bắn, và nổ.
⋄Triển khai hiệu ứng hình ảnh cho va chạm và nổ.

Task Id: 6
Task: Xử lý dữ liệu Excel
Prompt: Viết một chương trình xử lý dữ liệu excel dựa trên streamlit và pandas. Màn hình
đầu tiên hiển thị nút tải file excel. Sau khi file excel được tải lên, sử dụng pandas để hiển thị
nội dung dữ liệu của nó. Chương trình được yêu cầu ngắn gọn, dễ bảo trì, và không thiết kế quá mức. Nó
sử dụng streamlit để xử lý hiển thị màn hình web, và pandas đủ để xử lý đọc và hiển thị excel.
Vui lòng đảm bảo người khác có thể thực thi trực tiếp mà không cần giới thiệu các gói bổ sung.
Yêu cầu:
•Nút Tải File:
⋄Hiển thị nút tải file sử dụng bất kỳ thư viện web nào (như Streamlit).
⋄Cho phép người dùng tải lên file Excel.
•Xử lý Dữ liệu Pandas:
⋄Sử dụng Pandas để đọc file Excel đã tải lên.
⋄Tải dữ liệu vào Pandas DataFrame.
•Hiển thị Dữ liệu:
⋄Hiển thị nội dung của DataFrame.
⋄Hiển thị vài hàng đầu tiên của dữ liệu theo mặc định.
•Toggle cho Hiển thị Dữ liệu Đầy đủ:
⋄Thêm nút toggle để chuyển đổi giữa hiển thị vài hàng đầu tiên và dữ liệu đầy đủ.
•Xử lý Giá trị Bị thiếu:
⋄Kiểm tra và xử lý giá trị bị thiếu trong dữ liệu.
•Lựa chọn Cột:

--- TRANG 19 ---
⋄Cho phép người dùng chọn các cột cụ thể để hiển thị.
⋄Chỉ hiển thị các cột đã chọn.
•Lọc:
⋄Triển khai lọc dữ liệu đơn giản dựa trên đầu vào của người dùng.
⋄Hiển thị kết quả được lọc.
•Sắp xếp:
⋄Cho phép người dùng sắp xếp dữ liệu dựa trên một hoặc nhiều cột.
⋄Hiển thị kết quả được sắp xếp.
•Tải xuống Dữ liệu Đã xử lý:
⋄Cung cấp nút để cho phép người dùng tải xuống dữ liệu đã xử lý.
•Trực quan hóa (Tùy chọn):
⋄Bao gồm các trực quan hóa đơn giản tùy chọn (ví dụ: biểu đồ cột, biểu đồ đường).
•Xử lý Lỗi:
⋄Triển khai xử lý lỗi cho các vấn đề tải file hoặc lỗi xử lý dữ liệu (ví dụ: file không
ở định dạng excel hoặc csv).
⋄Hiển thị thông báo thông tin cho người dùng.

Task Id: 7
Task: Quản lý CRUD
Prompt: Viết một chương trình quản lý dựa trên xử lý CRUD thêm, xóa, sửa đổi và truy vấn
của thực thể kinh doanh khách hàng. Khách hàng cần lưu thông tin này: tên, ngày sinh, tuổi, giới tính,
và điện thoại. Dữ liệu được lưu trữ trong client.db, và có một đánh giá liệu bảng khách hàng có
tồn tại. Nếu không, cần được tạo trước. Truy vấn được thực hiện theo tên; tương tự cho việc xóa.
Chương trình được yêu cầu ngắn gọn, dễ bảo trì, và không thiết kế quá mức. Màn hình được thực hiện
thông qua streamlit và sqlite—không cần giới thiệu các gói bổ sung khác.
Yêu cầu:
•Khởi tạo Cơ sở dữ liệu:
⋄Kết nối với cơ sở dữ liệu SQLite (client.db).
⋄Kiểm tra xem bảng khách hàng có tồn tại không.
⋄Nếu không, tạo bảng khách hàng với các trường: tên, ngày sinh, tuổi, giới tính, và điện thoại.
•Thêm Khách hàng (Create):
⋄Cung cấp các trường nhập liệu cho tên, ngày sinh, tuổi, giới tính, và điện thoại.
⋄Cho phép người dùng thêm khách hàng mới vào cơ sở dữ liệu.
⋄Xác thực dữ liệu đầu vào (ví dụ: kiểm tra xem điện thoại có hợp lệ không).
•Truy vấn Khách hàng (Read):
⋄Triển khai giao diện truy vấn với trường nhập liệu cho tên khách hàng.
⋄Hiển thị thông tin khách hàng nếu tìm thấy.
⋄Cung cấp thông báo nếu không tìm thấy khách hàng.
•Cập nhật Khách hàng (Modify):
⋄Cho phép người dùng cập nhật thông tin khách hàng.
⋄Hiển thị thông tin hiện tại và cung cấp các trường nhập liệu cho việc sửa đổi.
⋄Cập nhật cơ sở dữ liệu với dữ liệu đã sửa đổi.
•Xóa Khách hàng (Delete):
⋄Cho phép người dùng xóa khách hàng dựa trên tên của họ.
⋄Hiển thị thông báo xác nhận trước khi xóa.
⋄Cập nhật cơ sở dữ liệu bằng cách loại bỏ khách hàng.
•Hiển thị Tất cả Khách hàng:
⋄Tạo một phần để hiển thị tất cả khách hàng trong cơ sở dữ liệu.

--- TRANG 20 ---
⋄Hiển thị thông tin liên quan cho mỗi khách hàng.
•UI:
⋄Thiết kế giao diện người dùng (Streamlit) với bố cục sạch sẽ.
⋄Sử dụng các thành phần (Streamlit) cho các trường nhập liệu, nút, và hiển thị thông tin.
•Xử lý Lỗi:
⋄Triển khai xử lý lỗi cho các vấn đề kết nối cơ sở dữ liệu.
⋄Cung cấp thông báo lỗi thân thiện với người dùng.

Task Id: 8
Task: Thông cáo báo chí tùy chỉnh
Prompt: Tạo thông cáo báo chí tùy chỉnh; phát triển một script Python trích xuất thông tin liên quan
về tin tức công ty từ các nguồn bên ngoài, như mạng xã hội; trích xuất cơ sở dữ liệu khoảng thời gian cập nhật
cho các thay đổi gần đây. Chương trình nên tạo thông cáo báo chí với các tùy chọn có thể tùy chỉnh
và xuất bài viết ra PDF, JSONs API NYTimes, định dạng media được cách điệu với metadata
nội bộ liên kết có độ dài ký tự cố định.
Yêu cầu:
•Trích xuất Dữ liệu từ Nguồn Bên ngoài:
⋄Triển khai web scraping hoặc sử dụng API để trích xuất thông tin liên quan từ mạng xã hội
và các nguồn bên ngoài khác.
⋄Trích xuất dữ liệu như cập nhật công ty, tin tức, và sự kiện.
•Cơ sở dữ liệu Khoảng thời gian Cập nhật:
⋄Phát triển cơ sở dữ liệu để lưu trữ thông tin về các thay đổi hoặc cập nhật gần đây.
⋄Bao gồm các trường như timestamp, nguồn, và nội dung.
•Tùy chọn Thông cáo Báo chí Có thể Tùy chỉnh:
⋄Thiết kế giao diện người dùng hoặc tùy chọn dòng lệnh cho người dùng tùy chỉnh thông cáo báo chí.
⋄Cho phép tùy chỉnh nội dung, định dạng, và metadata.
•Tạo Nội dung Thông cáo Báo chí:
⋄Phát triển thuật toán để tạo nội dung thông cáo báo chí mạch lạc và ngắn gọn.
⋄Sử dụng thông tin đã trích xuất để tạo ra những câu chuyện hấp dẫn.
•Tùy chọn Xuất:
⋄Cung cấp tùy chọn xuất thông cáo báo chí ở các định dạng khác nhau, như PDF và JSONs API NYTimes.
⋄Bao gồm các template có thể tùy chỉnh cho các định dạng media khác nhau.
•Bao gồm Metadata:
⋄Thêm metadata vào thông cáo báo chí, bao gồm metadata có độ dài ký tự cố định.
⋄Đảm bảo metadata bao gồm thông tin liên quan như ngày xuất bản, nguồn, và tác giả.
•Xuất PDF:
⋄Triển khai chức năng xuất thông cáo báo chí dưới dạng file PDF.
⋄Cho phép người dùng chỉ định tùy chọn xuất PDF (ví dụ: bố cục, font).
•Xuất JSON API NYTimes:
⋄Tích hợp với API NYTimes để lấy thông tin liên quan bổ sung.
⋄Định dạng và xuất thông cáo báo chí ở định dạng JSON tương thích với API NYTimes.
•Cách điệu Định dạng Media:
⋄Áp dụng cách điệu cho thông cáo báo chí dựa trên các định dạng media khác nhau.
⋄Đảm bảo cách điệu phù hợp với tiêu chuẩn ngành.
•Liên kết Nội dung Nội bộ:
⋄Triển khai liên kết nội dung nội bộ trong thông cáo báo chí.

--- TRANG 21 ---
⋄Bao gồm liên kết đến các bài viết, tài liệu, hoặc tài nguyên liên quan.
•Xử lý Lỗi:
⋄Triển khai cơ chế xử lý lỗi cho trích xuất dữ liệu, tùy chỉnh, và quá trình xuất.
⋄Cung cấp thông báo lỗi rõ ràng và ghi log.

Task Id: 9
Task: Trò chơi Caro
Prompt: Tạo một trò chơi caro bằng python
Yêu cầu:
•Bảng Trò chơi:
⋄Tạo một bảng trò chơi dựa trên lưới cho Caro.
⋄Định nghĩa kích thước của bảng (thường là 15x15 cho Caro).
⋄Hiển thị bảng trò chơi trên console hoặc giao diện người dùng đồ họa.
•Người chơi vs. Người chơi:
⋄Triển khai chế độ hai người chơi nơi hai người chơi có thể thay phiên nhau.
⋄Cho phép người chơi đặt dấu của họ (X hoặc O) trên bảng.
•Điều kiện Chiến thắng:
⋄Phát hiện và thông báo người chiến thắng khi một người chơi có năm dấu liên tiếp theo hàng ngang,
dọc, hoặc chéo.
⋄Tuyên bố hòa khi bảng đầy và không có người chơi nào thắng.
•Giao diện Người dùng:
⋄Tạo giao diện thân thiện với người dùng để người chơi tương tác với trò chơi.
⋄Hiển thị trạng thái hiện tại của bảng sau mỗi nước đi.
•Xử lý Đầu vào:
⋄Triển khai xử lý đầu vào cho nước đi của người chơi.
⋄Đảm bảo nước đi hợp lệ và xử lý đầu vào không hợp lệ một cách duyên dáng.
•Tùy chọn Khởi động lại và Thoát:
⋄Cung cấp tùy chọn để khởi động lại trò chơi hoặc thoát chương trình sau khi trò chơi hoàn thành.
⋄Hỏi xác nhận trước khi khởi động lại hoặc thoát.
•Logic Trò chơi:
⋄Triển khai logic trò chơi cốt lõi, bao gồm kiểm tra điều kiện chiến thắng, cập nhật
bảng, và quản lý lượt.

Task Id: 10
Task: Trình phát video
Prompt: Tạo một trình phát video bằng python có thể phát video từ người dùng. Ứng dụng cũng có thể
hỗ trợ nhiều điều khiển như phát, tạm dừng và dừng.
Yêu cầu:
•Giao diện Người dùng:
⋄Phát triển giao diện người dùng để hiển thị trình phát video.
⋄Bao gồm một phần để hiển thị nội dung video.
⋄Tạo không gian cho các nút điều khiển (phát, tạm dừng, dừng).
•Tải Video:
⋄Triển khai chức năng tải video từ đầu vào của người dùng.
⋄Hỗ trợ các định dạng video phổ biến (ví dụ: MP4, AVI).
⋄Xử lý lỗi một cách duyên dáng nếu định dạng video không được hỗ trợ.
•Nút Phát:

--- TRANG 22 ---
⋄Triển khai nút "Phát" để bắt đầu phát video đã tải.
⋄Đảm bảo nút phản hồi và cập nhật trạng thái của nó (ví dụ: thay đổi thành nút tạm dừng
khi video đang phát).
•Nút Tạm dừng:
⋄Triển khai nút "Tạm dừng" để tạm thời tạm dừng video.
⋄Cho phép người dùng tiếp tục phát từ trạng thái tạm dừng.
•Nút Dừng:
⋄Triển khai nút "Dừng" để dừng phát video.
⋄Đặt lại video về đầu khi dừng.
•Thanh trượt Thời gian:
⋄Thêm thanh trượt thời gian hoặc thanh tiến độ để hiển thị vị trí hiện tại trong video.
⋄Cho phép người dùng click vào thanh trượt để nhảy đến các điểm cụ thể trong video.
•Xử lý Lỗi:
⋄Triển khai xử lý lỗi cho các trường hợp video không tải được hoặc gặp vấn đề phát.
⋄Hiển thị thông báo lỗi thông tin cho người dùng.

Task Id: 11
Task: Trình Tải Video Youtube
Prompt: Tạo một Trình Tải Video Youtube bằng Python nhận liên kết Youtube làm
đầu vào và sau đó tải video với nhiều tùy chọn độ phân giải
Yêu cầu:
•Đầu vào Người dùng:
⋄Phát triển giao diện người dùng hoặc giao diện dòng lệnh để chấp nhận liên kết video YouTube làm
đầu vào.
•Tích hợp API YouTube (Tùy chọn):
⋄Tích hợp với API YouTube để lấy thông tin về các độ phân giải video có sẵn
và định dạng.
⋄Truy xuất chi tiết như tiêu đề video, độ phân giải có sẵn, và định dạng.
•Tùy chọn Độ phân giải Video:
⋄Trình bày cho người dùng các tùy chọn để chọn từ các độ phân giải video khác nhau.
⋄Hiển thị thông tin về mỗi độ phân giải (ví dụ: độ phân giải, định dạng, kích thước file).
•Cơ chế Tải xuống:
⋄Triển khai cơ chế tải video sử dụng thư viện như pytube hoặc tương tự.
⋄Cho phép người dùng chọn độ phân giải video mong muốn.
•Hiển thị Tiến độ Tải xuống:
⋄Hiển thị thanh tiến độ hoặc phần trăm để hiển thị tiến độ tải xuống.
⋄Cập nhật tiến độ theo thời gian thực trong quá trình tải xuống.
•Tùy chọn Đặt tên File:
⋄Cung cấp tùy chọn cho người dùng chỉ định tên của file đã tải xuống.
⋄Tạo tên mặc định dựa trên tiêu đề video.
•Vị trí Tải xuống:
⋄Cho phép người dùng chỉ định thư mục nơi video sẽ được lưu.
⋄Sử dụng thư mục mặc định nếu người dùng không chỉ định.
•Hiển thị Thông tin Video:
⋄Hiển thị thông tin liên quan về video, như tiêu đề, thời lượng, và người tải lên.
⋄Hiển thị thông tin trước và sau khi tải xuống.
•Xử lý Lỗi:

--- TRANG 23 ---
⋄Triển khai xử lý lỗi để xử lý một cách duyên dáng các vấn đề như URL không hợp lệ, lỗi mạng,
hoặc thất bại tải xuống.

Task Id: 12
Task: Trình Tạo và Phát hiện Mã QR
Prompt: Tạo một chương trình Python tạo ra mã QR cho đầu vào từ người dùng và
giải mã mã QR từ người dùng.
Yêu cầu:
•Tạo Mã QR:
⋄Đầu vào Người dùng:
⋄Phát triển giao diện người dùng hoặc giao diện dòng lệnh để chấp nhận đầu vào của người dùng.
⋄Cho phép người dùng nhập văn bản hoặc URL mà mã QR sẽ được tạo.
⋄Thư viện Tạo Mã QR:
⋄Chọn thư viện tạo mã QR trong Python (ví dụ: qrcode).
⋄Tạo Mã QR:
⋄Tạo mã QR thành công với đầu vào hợp lệ.
⋄Cho phép người dùng tùy chỉnh tham số mã QR (ví dụ: kích thước, màu sắc).
⋄Hiển thị Mã QR:
⋄Hiển thị mã QR được tạo cho người dùng trên màn hình.
⋄Lưu Mã QR:
⋄Triển khai tùy chọn cho người dùng lưu mã QR được tạo dưới dạng file ảnh (ví dụ:
PNG).
•Giải mã Mã QR:
⋄Đầu vào Người dùng cho Giải mã:
⋄Cho phép người dùng nhập file ảnh chứa mã QR để giải mã.
⋄Hỗ trợ các định dạng ảnh phổ biến (ví dụ: PNG, JPEG).
⋄Thư viện Giải mã Mã QR:
⋄Chọn thư viện giải mã mã QR trong Python (ví dụ: opencv, pyzbar).
⋄Giải mã Mã QR:
⋄Giải mã mã QR thành công với đầu vào hợp lệ.
⋄Hiển thị văn bản hoặc URL đã giải mã cho người dùng.
⋄Xử lý Lỗi:
⋄Triển khai xử lý lỗi cho các trường hợp giải mã thất bại hoặc đầu vào không hợp lệ.

Task Id: 13
Task: Ứng dụng Danh sách Việc cần làm
Prompt: Tạo một ứng dụng danh sách việc cần làm đơn giản bằng python nơi người dùng có thể thêm, chỉnh sửa, và xóa
nhiệm vụ. Ứng dụng bao gồm một số tính năng như đánh dấu nhiệm vụ đã hoàn thành và phân loại
nhiệm vụ.
Yêu cầu:
•Giao diện Người dùng:
⋄Cung cấp tùy chọn để thêm, chỉnh sửa, xóa, đánh dấu đã hoàn thành, và phân loại nhiệm vụ.
•Hiển thị Danh sách Nhiệm vụ:
⋄Hiển thị danh sách nhiệm vụ ở định dạng dễ đọc.
⋄Bao gồm thông tin như tên nhiệm vụ, trạng thái (hoàn thành hay chưa), và danh mục.
•Thêm Nhiệm vụ:
⋄Triển khai chức năng thêm nhiệm vụ mới vào danh sách việc cần làm.
⋄Cho phép người dùng nhập tên nhiệm vụ, trạng thái, và danh mục.
•Chỉnh sửa Nhiệm vụ:
⋄Cung cấp giao diện để sửa đổi chi tiết nhiệm vụ như tên, trạng thái, và danh mục.

--- TRANG 24 ---
•Xóa Nhiệm vụ:
⋄Triển khai khả năng xóa nhiệm vụ khỏi danh sách việc cần làm.
⋄Xác nhận ý định của người dùng trước khi xóa nhiệm vụ.
•Đánh dấu Nhiệm vụ đã Hoàn thành:
⋄Cho phép người dùng đánh dấu nhiệm vụ đã hoàn thành.
⋄Chuyển đổi trạng thái hoàn thành của chúng.
•Phân loại Nhiệm vụ:
⋄Lọc nhiệm vụ theo danh mục.
•Lưu và Tải Nhiệm vụ:
⋄Lưu dữ liệu danh sách việc cần làm vào file (ví dụ: JSON hoặc CSV).
⋄Tải dữ liệu đã lưu khi ứng dụng khởi động.

Task Id: 14
Task: Máy tính
Prompt: Tạo một máy tính bằng python thực hiện các phép toán số học cơ bản. Thực hành
đầu vào người dùng, hàm, và phép toán học.
Yêu cầu:
•Giao diện Người dùng:
⋄Tạo giao diện cho các phép toán số học cơ bản (cộng, trừ, nhân,
chia).
•Đầu vào Người dùng:
⋄Chấp nhận đầu vào của người dùng cho các giá trị số và phép toán học.
⋄Cho phép nhiều số đầu vào và phép toán.
•Phép toán Số học:
⋄Triển khai thành công các hàm cho phép cộng.
⋄Triển khai thành công các hàm cho phép trừ.
⋄Triển khai thành công các hàm cho phép nhân.
⋄Triển khai thành công các hàm cho phép chia.
•Chức năng:
⋄Cho phép người dùng chọn phép toán họ muốn thực hiện.
•Thực hiện Tính toán:
⋄Hiển thị kết quả của phép tính.
•Tính toán Liên tục (Tùy chọn):
⋄Tùy chọn, cho phép người dùng thực hiện tính toán liên tục mà không cần khởi động lại
chương trình.
•Xử lý Lỗi:
⋄Triển khai xử lý lỗi cho các trường hợp người dùng cung cấp đầu vào không hợp lệ hoặc cố gắng
thực hiện phép toán không được hỗ trợ.
