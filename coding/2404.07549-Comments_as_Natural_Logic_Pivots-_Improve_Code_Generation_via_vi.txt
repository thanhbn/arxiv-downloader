--- TRANG 9 ---
Trong kết luận, công trình của chúng tôi giới thiệu trục bình luận như một góc nhìn mới, và việc hướng dẫn các mô hình sử dụng bình luận có thể tăng cường khả năng sinh mã một cách ổn định. Trong tương lai, chúng tôi sẽ khám phá thêm tiềm năng ứng dụng của bình luận trong các tình huống phức tạp rộng hơn, chẳng hạn như sử dụng công cụ và các agent LLM.

Tài liệu Tham khảo

Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. 2023. Báo cáo kỹ thuật Gpt-4. arXiv preprint arXiv:2303.08774.

Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, et al. 2021. Tổng hợp chương trình với các mô hình ngôn ngữ lớn. arXiv preprint arXiv:2108.07732.

Angelica Chen, Jérémy Scheurer, Tomasz Korbak, Jon Ander Campos, Jun Shern Chan, Samuel R Bowman, Kyunghyun Cho, and Ethan Perez. 2023. Cải thiện sinh mã bằng cách đào tạo với phản hồi ngôn ngữ tự nhiên. arXiv preprint arXiv:2303.16749.

Bei Chen, Fengji Zhang, Anh Nguyen, Daoguang Zan, Zeqi Lin, Jian-Guang Lou, and Weizhu Chen. 2022. Codet: Sinh mã với các bài kiểm tra được tạo ra. Trong Hội nghị Quốc tế lần thứ mười một về Biểu diễn Học tập.

Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, et al. 2021. Đánh giá các mô hình ngôn ngữ lớn được đào tạo trên mã. arXiv preprint arXiv:2107.03374.

Yao Fu, Hao Peng, and Tushar Khot. 2022. Gpt thu được khả năng của nó như thế nào? theo dõi các khả năng nổi lên của các mô hình ngôn ngữ đến nguồn gốc của chúng. Yao Fu's Notion.

Xue Jiang, Yihong Dong, Lecheng Wang, Qiwei Shang, and Ge Li. 2023. Sinh mã tự lập kế hoạch với mô hình ngôn ngữ lớn. arXiv preprint arXiv:2303.06689.

Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. 2022. Các mô hình ngôn ngữ lớn là những người lý luận zero-shot. Tiến bộ trong hệ thống xử lý thông tin neural, 35:22199–22213.

Jia Li, Ge Li, Yongmin Li, and Zhi Jin. 2023a. Prompting chuỗi suy nghĩ có cấu trúc cho sinh mã. arXiv preprint arXiv:2305.06599.

Raymond Li, Loubna Ben Allal, Yangtian Zi, Niklas Muennighoff, Denis Kocetkov, Chenghao Mou, Marc Marone, Christopher Akiki, Jia Li, Jenny Chim, et al. 2023b. Starcoder: cầu nguồn ở cùng bạn! arXiv preprint arXiv:2305.06161.

Xin-Ye Li, Jiang-Tian Xue, Zheng Xie, and Ming Li. 2023c. Suy nghĩ bên ngoài mã: Brainstorming thúc đẩy các mô hình ngôn ngữ lớn trong sinh mã. arXiv preprint arXiv:2305.10679.

Ziyang Luo, Can Xu, Pu Zhao, Qingfeng Sun, Xiubo Geng, Wenxiang Hu, Chongyang Tao, Jing Ma, Qingwei Lin, and Daxin Jiang. 2023. Wizardcoder: Trao quyền cho các mô hình ngôn ngữ lớn mã với evol-instruct. arXiv preprint arXiv:2306.08568.

Yingwei Ma, Yue Liu, Yue Yu, Yuanliang Zhang, Yu Jiang, Changjian Wang, and Shanshan Li. 2023. Ở giai đoạn đào tạo nào dữ liệu mã giúp llms lý luận? arXiv preprint arXiv:2309.16298.

Niklas Muennighoff, Qian Liu, Armel Zebaze, Qinkai Zheng, Binyuan Hui, Terry Yue Zhuo, Swayam Singh, Xiangru Tang, Leandro von Werra, and Shayne Longpre. 2023. Octopack: Instruction tuning các mô hình ngôn ngữ lớn mã. arXiv preprint arXiv:2308.07124.

Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy Rapin, et al. 2023. Code llama: Các mô hình nền tảng mở cho mã. arXiv preprint arXiv:2308.12950.

Noah Shinn, Federico Cassano, Ashwin Gopinath, Karthik R Narasimhan, and Shunyu Yao. 2023. Reflexion: Các agent ngôn ngữ với học tăng cường bằng lời nói. Trong Hội nghị lần thứ ba mươi bảy về Hệ thống Xử lý Thông tin Neural.

Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc V Le, Denny Zhou, et al. 2022. Prompting chuỗi suy nghĩ gợi ra lý luận trong các mô hình ngôn ngữ lớn. Tiến bộ trong Hệ thống Xử lý Thông tin Neural, 35:24824–24837.

Can Xu, Qingfeng Sun, Kai Zheng, Xiubo Geng, Pu Zhao, Jiazhan Feng, Chongyang Tao, and Daxin Jiang. 2023. Wizardlm: Trao quyền cho các mô hình ngôn ngữ lớn để tuân theo các hướng dẫn phức tạp. arXiv preprint arXiv:2304.12244.

Daoguang Zan, Ailun Yu, Bo Shen, Jiaxin Zhang, Taihong Chen, Bing Geng, Bei Chen, Jichuan Ji, Yafen Yao, Yongji Wang, et al. 2023. Liệu các ngôn ngữ lập trình có thể thúc đẩy lẫn nhau thông qua instruction tuning? arXiv preprint arXiv:2308.16824.

Eric Zelikman, Qian Huang, Gabriel Poesia, Noah Goodman, and Nick Haber. 2023. Parsel: Lý luận thuật toán với các mô hình ngôn ngữ bằng cách kết hợp các phân tách. Trong Hội nghị lần thứ ba mươi bảy về Hệ thống Xử lý Thông tin Neural.

Wayne Xin Zhao, Kun Zhou, Junyi Li, Tianyi Tang, Xiaolei Wang, Yupeng Hou, Yingqian Min, Beichen Zhang, Junjie Zhang, Zican Dong, et al. 2023. Một khảo sát về các mô hình ngôn ngữ lớn. arXiv preprint arXiv:2303.18223.

--- TRANG 10 ---
Yuqi Zhu, Jia Allen Li, Ge Li, YunFei Zhao, Jia Li, Zhi Jin, and Hong Mei. 2023. Cải thiện sinh mã bằng lấy mẫu nhiệt độ động. arXiv preprint arXiv:2309.02772.

A Chi tiết các Prompt Biến thể
Chúng tôi sử dụng ba loại prompt để tạo ra mã với các kiểu khác nhau. CoT-pre chỉ ra các prompt yêu cầu mô hình tạo ra chuỗi suy nghĩ từng bước trước khi tạo mã, và CoT-No-Position chỉ ra các prompt chỉ yêu cầu mô hình tạo ra chuỗi suy nghĩ từng bước. Các prompt cụ thể của ba loại được hiển thị như sau: Chúng tôi hiển thị các prompt cụ thể của ba prompt hạt giống cho mỗi loại trong Bảng 11, và các prompt khác được diễn đạt lại bởi GPT-4.

B Nghiên cứu Trường hợp
Chúng tôi sử dụng một nhiệm vụ lập trình đơn giản để minh họa sự khác biệt giữa prompt gốc, prompt LCP và prompt CoT. Mô tả vấn đề được hiển thị như sau.

def is_simple_power(x, n):
    """Nhiệm vụ của bạn là viết một hàm
    trả về true nếu số x là lũy thừa đơn giản của n
    và false trong các trường hợp khác.
    x là lũy thừa đơn giản của n nếu n**int=x
    Ví dụ:
    is_simple_power(1, 4) => true
    is_simple_power(2, 2) => true
    is_simple_power(8, 2) => true
    is_simple_power(3, 2) => false
    is_simple_power(3, 1) => false
    is_simple_power(5, 3) => false
    """

Kết quả Prompt Gốc [Thất bại] Prompt gốc không chứa hướng dẫn bổ sung, và mã được tạo ra thất bại trong việc vượt qua tất cả các bài kiểm tra đơn vị vì nó chỉ có thể giải quyết các trường hợp được cung cấp làm ví dụ.

```python
def is_simple_power(x, n):
    """Nhiệm vụ của bạn là viết một hàm
    trả về true nếu số x là lũy thừa đơn giản của n
    và false trong các trường hợp khác.
    x là lũy thừa đơn giản của n nếu n**int=x
    Ví dụ:
    is_simple_power(1, 4) => true
    is_simple_power(2, 2) => true
    is_simple_power(8, 2) => true
    is_simple_power(3, 2) => false
    is_simple_power(3, 1) => false
    is_simple_power(5, 3) => false
    """
    if n == 1:
        return True
    elif x == n:
        return True
    elif x == n**2:
        return True
    elif x == n**3:
        return True
    else:
        return False
```

Trong script này, chúng tôi định nghĩa một hàm gọi là `is_simple_power` nhận hai tham số `x` và `n`. Chúng tôi kiểm tra một vài trường hợp có thể để xác định liệu `x` có phải là lũy thừa đơn giản của `n` hay không. Nếu bất kỳ trường hợp nào trong số này đúng, chúng tôi trả về `True`, ngược lại chúng tôi trả về `False`.

Kết quả CoT [Thất bại] Mã được tạo ra trong cài đặt prompt CoT chứa giải thích từng bước đơn giản phân tách mô tả vấn đề thành hai điểm. Mã cuối cùng được tạo ra thất bại do các điểm được diễn giải lại mơ hồ, và có khoảng cách lớn giữa việc triển khai mã và mô tả vấn đề.

1. Định nghĩa một hàm gọi là `is_simple_power` nhận hai tham số, `x` và `n`.
2. Bên trong hàm, kiểm tra liệu `x` có bằng `n**int(n)` hay không. Nếu có, trả về `True`. Ngược lại, trả về `False`.

Đây là script Python triển khai các bước trên:

```python
def is_simple_power(x, n):
    if x == n**int(n):
        return True
    else:
        return False
```

Hàm này kiểm tra liệu số `x` có phải là lũy thừa đơn giản của `n` hay không. Nếu `x` bằng `n` nâng lên lũy thừa của `int(n)`, nó trả về `True`. Ngược lại, nó trả về `False`.

Kết quả LCP [Vượt qua] Mã được tạo ra trong cài đặt prompt LCP chứa bình luận rõ ràng để giải thích logic mã và tất cả các bài kiểm tra đơn vị đều vượt qua thành công.

--- TRANG 11 ---
```python
def is_simple_power(x, n):
    """
    Nhiệm vụ của bạn là viết một hàm
    trả về true nếu số x là lũy thừa đơn giản của n
    và false trong các trường hợp khác.
    x là lũy thừa đơn giản của n nếu n**int=x
    Ví dụ:
    is_simple_power(1, 4) => true
    is_simple_power(2, 2) => true
    is_simple_power(8, 2) => true
    is_simple_power(3, 2) => false
    is_simple_power(3, 1) => false
    is_simple_power(5, 3) => false
    """
    # Kiểm tra liệu x có phải là lũy thừa hoàn hảo của n hay không
    if n == 1:
        return x == 1
    # Kiểm tra liệu x có phải là lũy thừa đơn giản của n hay không
    if x % n == 0:
        return is_simple_power(x // n, n)
    # Kiểm tra liệu x có phải là lũy thừa hoàn hảo của n hay không
    for i in range(2, x):
        if x == n ** i:
            return True
    # Nếu x không thỏa mãn bất kỳ điều kiện nào ở trên,
    # thì nó không phải là lũy thừa đơn giản của n
    return False
```

Bây giờ, bạn có thể gọi hàm `is_simple_power` với các đầu vào mong muốn để kiểm tra liệu một số có phải là lũy thừa đơn giản của một cơ số cho trước hay không.

| tên prompt | nội dung |
|-----------|----------|
| CoT-pre1 | Đầu tiên, xem xét quá trình từng bước, sau đó trình bày script Python: |
| CoT-pre2 | Bắt đầu bằng cách tạo một kế hoạch lập trình từng bước, sau đó thực hiện nó với script Python cho vấn đề được cung cấp: |
| CoT-pre3 | Script Python sau đây giải quyết vấn đề được chỉ định và bao gồm một giải thích chi tiết ở đầu: |
| Comment1 | Đây là script Python có chú thích giải quyết vấn đề được chỉ định: |
| Comment2 | Để làm rõ logic, tốt hơn là nên bao gồm các chú thích trong script. Đây là mã Python cho vấn đề đã cho: |
| Comment3 | Script Python sau đây giải quyết vấn đề đã cho, với logic phức tạp được phân tách bằng các bình luận đơn giản: |
| CoT-No-Position1 | Đây là mã Python cho vấn đề được chỉ định, được chia thành các bước logic: |
| CoT-No-Position6 | Chương trình Python cho vấn đề được đề cập ở trên được trình bày ở đây, với giải thích từng bước: |
| CoT-No-Position11 | Đây là một script Python giải quyết vấn đề đã cho, kèm theo một phân tích toàn diện: |

Bảng 11: Ba prompt hạt giống thủ công cho mỗi loại.
