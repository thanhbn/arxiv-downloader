Xếp hạng lại Chồng chéo Chức năng cho Sinh mã Neural

Hung Quoc To , Minh Huynh Nguyen , Nghi D. Q. Bui
FPT Software AI Center, Việt Nam
hungtq29@fpt.com, minh.nghminh@gmail.com, bdqnghi@gmail.com

Tóm tắt
Các Mô hình Ngôn ngữ Lớn về Mã (CodeLLMs) đã mở ra một kỷ nguyên mới trong các tiến bộ sinh mã. Tuy nhiên, việc lựa chọn các giải pháp mã tốt nhất từ tất cả các đầu ra có thể của CodeLLM vẫn là một thách thức. Các phương pháp trước đây thường bỏ qua những tương đồng chức năng phức tạp và tương tác giữa các cụm giải pháp. Chúng tôi giới thiệu SRank, một chiến lược xếp hạng lại mới để lựa chọn các giải pháp tốt nhất từ việc sinh mã, tập trung vào việc mô hình hóa các mối quan hệ giữa các cụm giải pháp. Bằng cách định lượng mức độ chồng chéo chức năng giữa các cụm giải pháp, phương pháp của chúng tôi cung cấp một chiến lược xếp hạng tốt hơn cho các giải pháp mã. Kết quả thực nghiệm cho thấy phương pháp của chúng tôi đạt được kết quả đáng chú ý về điểm pass@1. Ví dụ, trên benchmark Human-Eval, chúng tôi đạt được 69.66% ở pass@1 với Codex002, 75.31% với WizardCoder, 53.99% với StarCoder, và 60.55% với CodeGen, vượt qua các phương pháp xếp hạng lại sinh mã tiên tiến như CodeT và Coder-Reviewer trên cùng CodeLLM với biên độ đáng kể (≈6.1% cải thiện trung bình). Ngay cả trong các tình huống với số lượng giải pháp lấy mẫu và test case hạn chế, phương pháp của chúng tôi thể hiện tính mạnh mẽ và vượt trội, đánh dấu một chuẩn mực mới trong xếp hạng lại sinh mã. Triển khai của chúng tôi có thể được tìm thấy tại https://github.com/FSoft-AI4Code/SRank-CodeRanker.

1 Giới thiệu
Những tiến bộ gần đây trong các mô hình ngôn ngữ được thiết kế riêng cho mã, được gọi là Mô hình Ngôn ngữ Lớn về Mã (CodeLLMs) (Luo et al., 2023; Wang et al., 2023; Nijkamp et al., 2023b; Rozière et al., 2023; Wei et al., 2023; Lozhkov et al., 2024; Pinnaparaju et al., 2024; Guo et al., 2024; Bui et al., 2023), đã thu hút sự quan tâm đáng kể, đặc biệt là do sự mở rộng của các mô hình ngôn ngữ quy mô lớn và khối lượng dữ liệu pre-training (Kaplan et al., 2020; Zhao et al., 2023). Một tiện ích chính của CodeLLMs là khả năng sinh mã dựa trên các mô tả ngôn ngữ tự nhiên được con người viết (Chen et al., 2021; Fried et al., 2023; Chowdhery et al., 2022; Nijkamp et al., 2023b). Tuy nhiên, các nghiên cứu trước đây (Holtzman et al., 2020; Austin et al., 2021) đã nhấn mạnh rằng các chuỗi được sinh ra bởi những mô hình này có thể dễ mắc lỗi, đặc biệt khi sử dụng các kỹ thuật giải mã dựa trên khả năng như tìm kiếm tham lam và tìm kiếm chùm. Thay vào đó, các kỹ thuật giải mã dựa trên lấy mẫu (Fan et al., 2018; Holtzman et al., 2020) trích xuất nhiều giải pháp từ phân phối đa thức của mô hình. Phương pháp này sinh ra một loạt các giải pháp mã, nhiều trong số đó là chính xác (Austin et al., 2021; Ni et al., 2023). Do đó, có một sự quan tâm ngày càng tăng trong việc phát triển các chiến lược xếp hạng lại cho sinh mã (Li et al., 2022; Inala et al., 2022; Chen et al., 2023; Zhang et al., 2023; Ni et al., 2023), với mục tiêu sắp xếp qua nhiều giải pháp lấy mẫu để xác định những giải pháp chất lượng cao và chính xác.

Mục tiêu của xếp hạng lại là tổ chức tập hợp các chương trình ứng viên sao cho các chương trình chính xác được ưu tiên. Li et al. (2022), Chen et al. (2023), và Ni et al. (2023) đã phân cụm các giải pháp mã dựa trên chức năng của chúng, sau đó sử dụng dữ liệu cụm cụ thể để xác định điểm xếp hạng. Do các mô hình ngôn ngữ thường tạo ra các giải pháp mã khác nhau về cú pháp nhưng tương tự về ngữ nghĩa, phân cụm chức năng thu hẹp pool ứng viên. Trọng tâm sau đó chuyển từ xếp hạng các giải pháp cá nhân sang xếp hạng bản thân các cụm. Các chiến lược xếp hạng trước đây, chẳng hạn như AlphaCode (Li et al., 2022) và CodeT (Chen et al., 2023), cung cấp các phương pháp để phân cụm và xếp hạng lại các giải pháp mã. Trong khi AlphaCode (Li et al., 2022) tập trung vào các đầu ra giống hệt nhau từ đầu vào test được mô hình sinh ra, CodeT (Chen et al., 2023) tập trung vào các giải pháp vượt qua các test case được mô hình sinh ra. Phương pháp Coder-Reviewer (Zhang et al., 2023), lấy cảm hứng từ phát triển phần mềm cộng tác, sử dụng một hệ thống mô hình kép để kiểm tra chéo các chương trình được sinh ra với các hướng dẫn ngôn ngữ. Tuy nhiên, bằng cách xem xét các cụm một cách riêng lẻ, chúng không thể mô hình hóa những tương đồng chức năng và tương tác tiềm năng thông tin qua các cụm.

Để giải quyết hạn chế này, chúng tôi đề xuất SRank, một phương pháp xếp hạng lại mới nhấn mạnh vào việc mô hình hóa các mối quan hệ giữa các cụm. Cụ thể, chúng tôi giới thiệu một thước đo mới gọi là chồng chéo chức năng để định lượng sự tương đồng giữa các cụm dựa trên đầu ra thực thi của chúng. Điều này cho phép xác định cụm đại diện nhất thể hiện sự chồng chéo tối đa với tất cả các cụm khác. Vì sự không nhất quán thường chỉ ra chức năng không chính xác, cụm tương tác toàn diện nhất có thể đại diện cho giải pháp tối ưu. Bằng cách kết hợp những mối quan hệ giữa các cụm này vào pipeline xếp hạng, chúng ta có thể xác định tốt hơn những giải pháp hứa hẹn nhất. Thông qua đánh giá rộng rãi, chúng tôi chứng minh rằng việc mô hình hóa các mối quan hệ giữa các cụm và chồng chéo chức năng cung cấp những cải thiện đáng kể và nhất quán so với các phương pháp xếp hạng giải pháp tiên tiến trước đây (Li et al., 2022; Chen et al., 2023; Zhang et al., 2023) trên một loạt các CodeLLM tiên tiến, bao gồm Codex, WizardCoder, StarCoder, và CodeGen. Ví dụ, trên benchmark HumanEval, phương pháp của chúng tôi đạt được điểm pass@1 là 75.31% với WizardCoder34B, vượt qua điểm 66.9% của Coder-Reviewer. Tương tự, trên benchmark MBPP-S, phương pháp của chúng tôi cải thiện điểm pass@1 cho WizardCoder từ 50.3% với Coder-Reviewer lên 51.03% với phương pháp của chúng tôi. Những cải thiện tương tự được áp dụng cho các CodeLLM khác, bao gồm StarCoder, CodeGen, và Codex002. Nếu chúng ta so sánh SRank với phương pháp lấy mẫu ngẫu nhiên đơn giản để có được các giải pháp mã, chúng ta quan sát thấy những cải thiện đáng kể qua các mô hình, với những cải thiện trung bình là 23.07% và 17.64% cho HumanEval và MBPP-S, tương ứng. Đánh giá của chúng tôi toàn diện hơn vì chúng tôi bao gồm nhiều CodeLLM SOTA với kích thước khác nhau, trong khi CodeT và Coder-Reviewer thì không. Điều này cung cấp bằng chứng thuyết phục về tính mạnh mẽ của phương pháp chúng tôi qua một loạt các mô hình.

Chúng tôi cũng đã tiến hành một phân tích rộng rãi để chứng minh một số lợi thế của chúng tôi, chẳng hạn như tính mạnh mẽ đáng chú ý của phương pháp chúng tôi ngay cả với các giải pháp và test case hạn chế. Tóm lại, bằng cách chuyển từ các cụm riêng lẻ sang các cụm tương tác với chồng chéo chức năng được định lượng, chiến lược xếp hạng lại mới của chúng tôi nhằm giải quyết những hạn chế của các kỹ thuật xếp hạng trước đây cho sinh mã. Để tóm tắt các đóng góp của chúng tôi, chúng như sau:

• Chúng tôi giới thiệu một chiến lược xếp hạng lại mới cho CodeLLMs nhấn mạnh vào các mối quan hệ giữa các cụm và tận dụng sự chồng chéo chức năng giữa chúng, cung cấp một phương pháp mạnh mẽ và chính xác hơn để chọn ra các giải pháp tốt nhất.

• Thông qua các đánh giá rộng rãi và toàn diện, chúng tôi chứng minh rằng phương pháp của chúng tôi luôn vượt trội hơn các phương pháp tiên tiến hiện có trong sinh mã. Ví dụ, phương pháp của chúng tôi đạt được kết quả vượt trội trên cả benchmark HumanEval và MBPP-S qua nhiều CodeLLM khác nhau.

• Chúng tôi thực hiện phân tích rộng rãi để đánh giá tính mạnh mẽ của phương pháp chúng tôi, làm nổi bật tính hiệu quả của nó ngay cả với số lượng giải pháp lấy mẫu và test case hạn chế, và khả năng nắm bắt các tương tác phức tạp giữa các cụm, tạo ra sự khác biệt so với các kỹ thuật xếp hạng trước đây.

2 Bối cảnh & Động lực

2.1 Sinh mã
Sinh mã bao gồm việc sinh ra các giải pháp mã cho các bài toán lập trình dựa trên một ngữ cảnh c đã cho. Ngữ cảnh bao gồm một mô tả ngôn ngữ tự nhiên và một đoạn mã chứa các câu lệnh như imports và một chữ ký hàm. Ngoài ra, một tập hợp các test case được định nghĩa trước, ký hiệu là T, được cung cấp để đánh giá tính đúng đắn của các giải pháp mã được sinh ra. Sử dụng c như đầu vào trên CodeLLM, chúng ta thu được một tập hợp các giải pháp S={s1, s2, ..., sN}, trong đó N là một siêu tham số định nghĩa số lượng chuỗi trả về từ việc thực thi CodeLLM. Một giải pháp s được coi là hợp lệ nếu nó thành công vượt qua tập hợp các test case được định nghĩa trước T.

2.2 Phân cụm và Xếp hạng lại Giải pháp
Nhiệm vụ xếp hạng lại nhằm ưu tiên các chương trình chính xác trong danh sách ứng viên S. Trước đây, các giải pháp được phân cụm theo chức năng, đơn giản hóa nhiệm vụ do xu hướng của các mô hình ngôn ngữ tạo ra các giải pháp khác nhau về cú pháp nhưng tương tự về ngữ nghĩa. Do đó, trọng tâm chuyển từ xếp hạng các giải pháp cá nhân sang xếp hạng các cụm chức năng này. Ví dụ, AlphaCode (Li et al., 2022) sử dụng một mô hình riêng biệt để tạo đầu vào test. Các giải pháp sau đó được thực thi với những đầu vào này, và những giải pháp có đầu ra khớp nhau được phân cụm. Chiến lược xếp hạng lại dựa trên hiểu biết rằng trong khi có thể có nhiều biến thể chương trình không chính xác, những chương trình chính xác thường thể hiện các mẫu tương tự, dẫn đến việc các cụm được xếp hạng theo số lượng giải pháp của chúng.

Ngược lại, CodeT (Chen et al., 2023) phân cụm các giải pháp vượt qua cùng các test case được mô hình sinh ra. Tuy nhiên, điều này có thể nhóm các giải pháp khác nhau về mặt chức năng. Nếu các giải pháp của một cụm chỉ vượt qua một số test case, không chắc chắn liệu đầu ra cho các trường hợp thất bại có nhất quán qua các giải pháp hay không, có thể làm tổn hại đến chức năng cụm và độ tin cậy trong việc lựa chọn từ những cụm được xếp hạng này. Chúng tôi trình bày một ví dụ cụ thể để phân tích vấn đề này trong Phụ lục G.

2.3 Mô hình hóa Mối quan hệ Giữa các Cụm
Các phương pháp phân cụm và xếp hạng lại hiện tại phân tích các cụm một cách độc lập mà không xem xét các mối quan hệ giữa các cụm (Li et al., 2022; Chen et al., 2023). Tuy nhiên, việc mô hình hóa những tương tác này có thể chỉ ra tính đúng đắn của cụm tốt hơn. Do đó, chúng tôi đề xuất một thước đo mới gọi là "chồng chéo chức năng" để định lượng sự tương đồng cụm dựa trên đầu ra thực thi, như được hiển thị trong Hình 1. Chúng ta có thể thực thi các giải pháp mã từ mỗi cụm trên cùng đầu vào test và so sánh đầu ra của chúng. Mức độ khớp đầu ra chỉ ra mức độ chồng chéo chức năng giữa hai cụm.

Trực giác là các cụm có sự chồng chéo cao thể hiện chức năng được chia sẻ lớn hơn. Bằng cách mô hình hóa mức độ mà một cụm chồng chéo với các cụm khác, chồng chéo chức năng xác định cụm "đại diện" nhất. Một cụm có sự chồng chéo tích lũy tối đa có đầu ra nhất quán nhất với tất cả các cụm khác. Vì sự không nhất quán thường chỉ ra chức năng không chính xác, cụm tương tác toàn diện nhất có thể là giải pháp tối ưu. Điều này tương tự như các giả định của Fischler và Bolles (1981), trong đó các giải pháp không chính xác đa dạng và có xác suất thấp có sự thỏa thuận chức năng giữa các giải pháp không chính xác.

3 Chi tiết Phương pháp

3.1 Tổng quan
Hình 2 cung cấp tổng quan về phương pháp end-to-end của chúng tôi. Đầu tiên, với một CodeLLM được huấn luyện tốt, ví dụ như Codex, và ba đầu vào: (1) Mô tả nhiệm vụ, (2) Prompt sinh mã, (3) Prompt sinh test case, chúng tôi hướng dẫn CodeLLM sinh ra một tập hợp các giải pháp mã cũng như test case. Cụ thể, chúng tôi prompt CodeLLM để tạo ra một tập hợp các giải pháp mã S={s1, s2, ..., sN} và một tập hợp test case T={t1, t2, ..., tM}, trong đó N và M là các siêu tham số định nghĩa số lượng giải pháp và test case.

Mỗi test case ti bao gồm hai thành phần: đầu vào test zi và đầu ra mong đợi ôi dựa trên ngữ cảnh (ví dụ, assert add(1,2) == 3, trong đó (1,2) là đầu vào và 3 là đầu ra). Sau đó chúng ta có thể thực thi các đầu vào test Z = {z1, z2, ..., zM} trên tập hợp giải pháp S để sinh ra các đầu ra thực thi O={o11, o12, ..., oNM}. Tiếp theo, chúng tôi phân cụm các giải pháp S thành các nhóm C = {C1, C2, ..., CK} dựa trên đầu ra thực thi của chúng, trong đó K là số lượng cụm duy nhất. Sau đó chúng tôi tính toán một ma trận tương tác I để định lượng sự chồng chéo chức năng giữa các cụm. Cuối cùng, chúng tôi nhân ma trận tương tác I với một vector điểm xác thực V để có được điểm xếp hạng cuối cùng R để lựa chọn các giải pháp tối ưu. Các điểm xác thực trong V đại diện cho các đặc trưng của mỗi cụm, chẳng hạn như số lượng giải pháp.

Trong các phần tiếp theo, chúng tôi sẽ mô tả chi tiết các bước chính của thuật toán.

3.2 Phân cụm Giải pháp theo Đầu ra Thực thi
Đầu tiên chúng tôi thực thi mỗi giải pháp si ∈ S trên các đầu vào test Z để tạo ra đầu ra thực thi O. Các giải pháp thể hiện đầu ra thực thi giống hệt nhau được nhóm vào cùng một cụm:

F(si) = F(sj) ⇐⇒ Osi = Osj.

Ở đây, F đại diện cho hàm phân cụm ánh xạ một giải pháp s vào một định danh cụm Ck. Phương trình trên chỉ ra rằng hai giải pháp si và sj được gán vào cùng một cụm khi và chỉ khi các tập hợp đầu ra Osi và Osj của chúng hoàn toàn bằng nhau.

3.3 Tính toán Ma trận Tương tác
Sau khi có được đầu ra thực thi oij cho mỗi cụm Ci trên đầu vào test zj, chúng tôi định nghĩa một ma trận tương tác I ∈ RK×K để định lượng chồng chéo chức năng:

Iij = (1/M) ∑(k=1 to M) δ(oik = ojk), (1)

trong đó oik và ojk tham chiếu trực tiếp đến đầu ra thực thi của các cụm Ci và Cj, tương ứng, trên đầu vào test thứ k. δ là hàm chỉ thị trả về 1 nếu điều kiện bên trong đúng và 0 nếu ngược lại.

3.4 Tính toán Điểm Xếp hạng Cuối cùng
Ngoài việc mô hình hóa các tương tác giữa các cụm thông qua I, chúng tôi cũng xem xét một chiều xác thực bổ sung V ∈ RK×1 chứa các đặc trưng cụm. Ví dụ, Vi có thể đại diện cho số lượng giải pháp trong cụm Ci (viết tắt là kích thước cụm) hoặc số lượng test case mà các giải pháp trong cụm Ci đã vượt qua (viết tắt là tỷ lệ pass), cung cấp một khái niệm về độ tin cậy của cụm. Vector xếp hạng cuối cùng R ∈ RK×1 có thể được tính toán như R = I·V. Ở đây, Ri tổng hợp thông tin về cả các tương tác giữa các cụm của Ci (thông qua I) và các đặc trưng cụm của nó (thông qua V). Các cụm có điểm xếp hạng cao hơn trong R là những cụm có sự chồng chéo chức năng đáng kể với các cụm khác và có tính hợp lệ cao theo V. Bằng cách xem xét các mối quan hệ giữa các cụm và sự tương đồng chức năng một cách có nguyên tắc, chúng tôi tin rằng phương pháp xếp hạng của chúng tôi có thể xác định hiệu quả các giải pháp hứa hẹn nhất. Chúng tôi xác thực phương pháp của mình thông qua các thử nghiệm rộng rãi trong các phần tiếp theo.

4 Thiết lập Thực nghiệm

Mô hình Chúng tôi đánh giá phương pháp của mình trên một số CodeLLM tiên tiến, bao gồm Codex, WizardCoder, StarCoder, và CodeGen. Mỗi họ mô hình có các kích thước mô hình khác nhau (ví dụ, WizardCoder 15B và 34B) và các phương pháp huấn luyện khác nhau (ví dụ, mô hình cơ sở và mô hình được fine-tune theo hướng dẫn). Do đó, chúng tôi đã chọn một tập hợp các mô hình đa dạng, từ quy mô nhỏ đến lớn, và từ mô hình cơ sở đến mô hình được fine-tune theo hướng dẫn, để chứng minh hiệu quả của phương pháp xếp hạng của chúng tôi. Tổng cộng, chúng tôi chứng minh phương pháp của mình trên 6 mô hình từ 6B đến 34B tham số.

Thước đo Chúng tôi sử dụng pass@k (Chen et al., 2021), thường được sử dụng để đánh giá tính đúng đắn chức năng của các giải pháp mã dựa trên thực thi mã thay vì các thước đo dựa trên độ tương tự.

Baseline Chúng tôi so sánh SRank với các phương pháp gần đây cho xếp hạng lại giải pháp, bao gồm Coder-Reviewer (Zhang et al., 2023) và CodeT (Chen et al., 2023). Coder-Reviewer (Zhang et al., 2023) là phương pháp tiên tiến. Mặt khác, CodeT (Chen et al., 2023) chia sẻ một phương pháp phân cụm-xếp hạng lại tương tự với phương pháp của chúng tôi.

Benchmark Chúng tôi sử dụng hai benchmark phổ biến trong sinh mã: HumanEval (Chen et al., 2021) và MBPP-S (phiên bản được làm sạch) (Austin et al., 2021). Để đánh giá thách thức hơn, chúng tôi đánh giá SRank trên APPS (Hendrycks et al., 2021). Để tránh để lộ các test case thực cho mô hình ngôn ngữ, chúng tôi tuân theo thiết kế prompt trong (Chen et al., 2021) bằng cách loại bỏ tất cả các ví dụ input-output khỏi ngữ cảnh trước khi sinh các giải pháp mã và test case.

Chi tiết Triển khai Đối với Codex002 và CodeGen16B, chúng tôi tham khảo các artifact, bao gồm cả giải pháp và test case, được cung cấp bởi Chen et al. (2023). Đối với các mô hình còn lại, chúng tôi sử dụng thư viện HuggingFace (Wolf et al., 2019) và tải các mô hình ở độ chính xác nửa. Chúng tôi đặt nhiệt độ là 0.8, top p là 0.95, số token mới tối đa là 2048, và timeout để thực thi giải pháp là 5 giây. Đối với mỗi bài toán, chúng tôi lấy mẫu 100 giải pháp mã và 100 chuỗi test case, mỗi chuỗi chứa nhiều test case. Các prompt chúng tôi sử dụng để lấy mẫu giải pháp mã và test case từ mỗi mô hình có thể được tìm thấy trong Phụ lục B. Để xử lý hậu kỳ các giải pháp mã và test case, chúng tôi tuân theo Chen et al. (2023) để cắt bớt các chuỗi được sinh ra bởi năm từ dừng: "\nclass", "\ndef", "\n#", "\nif", và "\nprint".

5 Kết quả Thực nghiệm

Bảng 1 trình bày kết quả pass@1 trên các benchmark HumanEval và MBPP-S cho nhiều CodeLLM khác nhau. Phương pháp của chúng tôi, SRank, luôn vượt trội hơn các kỹ thuật khác qua hầu hết các mô hình và benchmark. Ví dụ, trên benchmark HumanEval, SRank đạt được những cải thiện trung bình so với CodeT và Coder-Reviewer khoảng 3.63% và 8.81% trong pass@1, tương ứng.

Ngoài ra, khi so sánh Coder-Reviewer với phương pháp lấy mẫu ngẫu nhiên, nó không ổn định qua các mô hình. Cụ thể, sử dụng WizardCoder15B và StarCoder làm ví dụ, Coder-Reviewer mang lại những cải thiện khiêm tốn là 4.17% và 6.16%, so với những cải thiện của chúng tôi là 14.79% và 21.44%. Trên benchmark MBPP-S, SRank vẫn đạt được hiệu suất xuất sắc, mặc dù mức độ cải thiện hơi ít hơn so với HumanEval. Các thử nghiệm toàn diện của chúng tôi chứng minh hiệu quả của SRank so với CodeT và Coder-Reviewer.

Để đánh giá hiệu quả của phương pháp đề xuất trên một loạt mức độ khó khăn của bài toán lập trình, chúng tôi đánh giá SRank trên APPS sử dụng Codex002. Kết quả được hiển thị trong Bảng 3. Chúng tôi quan sát thấy SRank luôn vượt trội hơn tất cả các baseline khác với biên độ đáng kể. So với CodeT, việc thêm mô hình hóa giữa các cụm cải thiện đáng kể kết quả xếp hạng lại. Mặt khác, do tính khó khăn của các nhiệm vụ, sự cải thiện ít đáng kể hơn khi mức độ khó khăn tăng lên. Kết quả cho thấy SRank mạnh mẽ và mở rộng tốt với các mức độ khó khăn khác nhau.

Ngoài ra, để xác thực phương pháp của chúng tôi trên các mô hình closed source và khả năng cao, chúng tôi chọn Anthropic Claude 3 Opus (?) như một LLM đại diện trong thử nghiệm của chúng tôi. Vui lòng tham khảo Phụ lục F để biết kết quả.

6 Phân tích

Xác thực Giả định Chúng tôi cung cấp một phân tích toàn diện để xác thực giả định của chúng tôi rằng các giải pháp không chính xác đa dạng và có xác suất thấp có sự thỏa thuận chức năng giữa các giải pháp không chính xác. Chính thức, cho S biểu thị tập hợp các giải pháp được lấy mẫu từ một CodeLLM nhất định, si là giải pháp thứ i trong S, Ck là cụm thứ k bởi thuật toán phân cụm của chúng tôi, Ci là cụm bao gồm giải pháp si, và |Ck| và |Ck|* là số lượng giải pháp và số lượng giải pháp không chính xác trong cụm thứ k, tương ứng. Hàm f(si, sj) được định nghĩa là tính toán chồng chéo chức năng giữa si và sj, tương tự như Eq. 1. Sau đó chúng tôi tính toán xác suất của các giải pháp không chính xác với các mức độ chồng chéo chức năng khác nhau.

p(l ≤ f(si, sj) < h, si và sj đều không chính xác)
= ∑(i,j)∈M |Ci|*|Cj|* / |S|² (2)

Ở đây, M bao gồm các cặp (si, sj) trong đó l ≤ f(si, sj) < h, và l và h là hai siêu tham số. Chúng tôi xem xét hai giá trị phạm vi, (l1,h1) và (l2,h2) với cùng độ dài, trong đó l1 < l2 và h1 < h2. Theo giả định của chúng tôi, chúng tôi dự đoán rằng bất đẳng thức sau đây có hiệu lực:

p(l1 ≤ f(si, sj) < h1, si và sj đều không chính xác) >
p(l2 ≤ f(si, sj) < h2, si và sj đều không chính xác)

Thuật ngữ bên trái biểu thị xác suất của sự thỏa thuận chức năng thấp hơn giữa các giải pháp không chính xác, trong khi thuật ngữ bên phải biểu thị xác suất tương ứng của sự thỏa thuận chức năng cao hơn giữa các giải pháp không chính xác. Mối quan hệ quan sát được chỉ ra rằng xác suất của sự thỏa thuận chức năng thấp hơn vượt qua xác suất của sự thỏa thuận chức năng cao hơn, củng cố giả định của chúng tôi. Kết quả trong Hình 3 cho thấy sự suy giảm chung về xác suất với các giá trị l và h tăng lên. Đặc biệt đối với phạm vi (l,h) = (0,0.1), xác suất cao hơn đáng kể so với các phạm vi khác, và ở phạm vi tiếp theo, (l,h) = (0.1,0.2), xác suất giảm đáng chú ý. Hơn nữa, khi các giải pháp không chính xác thể hiện sự chồng chéo chức năng cao, vượt quá 0.7, xác suất thấp ở khoảng 3%. Những phát hiện này phù hợp với giả định của chúng tôi. Nhiều kết quả hơn có thể được tìm thấy trong Phụ lục A.

Ảnh hưởng của Đặc trưng Cụm Chúng tôi nhằm đánh giá hiệu suất xếp hạng lại chỉ với các đặc trưng cụm, tức là chỉ kích thước cụm, tỷ lệ pass, hoặc sự kết hợp của cả hai. Bảng 2 cho thấy hiệu suất SRank khi những đặc trưng này được thêm vào hoặc loại bỏ khỏi pipeline xếp hạng. Khi xếp hạng các giải pháp mã chỉ sử dụng một trong những đặc trưng đã đề cập, chúng ta có thể thấy rằng kích thước cụm quan trọng hơn tỷ lệ pass. Tuy nhiên, điều này không có nghĩa là tỷ lệ pass không quan trọng. Khi cả hai đặc trưng được kết hợp, kết quả có thể được cải thiện thậm chí còn nhiều hơn. Cuối cùng, chúng tôi đạt được hiệu suất SRank tốt nhất bằng cách kết hợp cả hai đặc trưng này hoặc một trong số chúng với ma trận Tương tác.

Đáng chú ý là các đặc trưng cụm sở hữu tính chất chung và thích ứng, cho phép mở rộng tiềm năng để kết hợp thông tin bổ sung như khả năng. Chúng tôi cũng báo cáo kết quả của sự kết hợp giữa khả năng của các cụm và tiêu chí xếp hạng Coder-Reviewer như đặc trưng cụm với chồng chéo chức năng trong Phụ lục D.

Ảnh hưởng của Ma trận Tương tác Chúng tôi tiến hành các thử nghiệm bổ sung để chứng minh hiệu quả của ma trận tương tác I. Từ kết quả trong Bảng 2, rõ ràng là ma trận tương tác I giúp tăng cường hiệu suất cho bất kỳ đặc trưng cụm nào. Quan trọng là việc tích hợp kích thước cụm với I đạt được kết quả ngang bằng với CodeT, làm nổi bật tầm quan trọng của các tương tác giữa các cụm.

Mở rộng Số lượng Test Case Được Sinh ra Chúng tôi đã tiến hành một nghiên cứu ablation để đánh giá cách số lượng test case được sinh ra ảnh hưởng đến hiệu suất xếp hạng lại mã. Hình 4 cho thấy hiệu suất pass@1 như một hàm của số lượng test case được sinh ra, từ 2 đến 50, trên benchmark HumanEval. Vui lòng tham khảo Phụ lục C cho kết quả của MBPP-S.

So sánh mỗi cặp đường liền (với ma trận tương tác) và đường đứt nét (không có ma trận tương tác), tương tác cụm luôn tăng cường hiệu suất so với việc chỉ xếp hạng theo đặc trưng cụm. Khoảng cách hiệu suất của xếp hạng lại có và không có tương tác tăng lên khi số lượng test case được sinh ra tăng lên, thể hiện khả năng mở rộng của phương pháp chúng tôi. Tuy nhiên, với số lượng test case hạn chế, SRank đôi khi kém hiệu quả hơn do tác động tiềm ẩn tiêu cực của các đặc trưng cụm khi được tích hợp với tương tác cụm. Để có sự cân bằng tối ưu giữa hiệu quả và hiệu suất, chúng tôi đề xuất sinh ít nhất 30 test case để được hưởng lợi đầy đủ từ tương tác cụm, khả thi trong vòng 1 đến 2 vòng lấy mẫu khi nhiều test case được sinh ra trong một chuỗi được lấy mẫu duy nhất.

Ngoài ra, so sánh hiệu suất của phương pháp chúng tôi và CodeT cho thấy sự khác biệt trong một số CodeLLM. Sự khác biệt này phát sinh từ chất lượng phân cụm của CodeT, do đó các test case hạn chế, chất lượng thấp có thể dẫn đến các cụm không nhất quán về mặt ngữ nghĩa, làm cho việc xếp hạng chúng ít ý nghĩa hơn. Ngược lại, phương pháp của chúng tôi phân cụm các giải pháp bằng cách khớp đầu ra thực thi, đảm bảo tính nhất quán chức năng, tăng cường độ tin cậy xếp hạng.

Mở rộng Số lượng Giải pháp Được Lấy mẫu Trong môi trường thực tế, việc có giới hạn về số lượng cả giải pháp và test case được sinh ra là thực tế, vì việc lấy mẫu nhiều chuỗi từ LLM tốn kém và không hiệu quả về thời gian cho máy tính tài nguyên thấp. Trong phần này, chúng tôi kiểm tra hiệu quả của SRank bằng cách thu nhỏ số lượng giải pháp được lấy mẫu xuống nhỏ hơn hoặc bằng 50 mẫu.

Vì lý do thực tế, chúng tôi chỉ chạy mỗi thử nghiệm với 50 test case được sinh ra bởi mỗi mô hình, thay vì tất cả test case được trích xuất từ 100 chuỗi test case. Chúng tôi prompt WizardCoder34B, WizardCoder15B, và CodeGen2.5-Instruct để sinh ra 50 test case khác nhau trong một chuỗi duy nhất. Kỹ thuật prompting này cải thiện hiệu quả pipeline tổng thể bằng cách giảm đáng kể chi phí tính toán của việc lấy mẫu từ CodeLLM. Hình 5 cho thấy hiệu suất pass@1 với số lượng giải pháp được lấy mẫu từ 2 đến 50. Kết quả của benchmark MBPP-S có thể được tìm thấy trong Phụ lục C. Hình này cho thấy xu hướng tương tự khi chúng tôi mở rộng số lượng test case được sinh ra. Thật vậy, việc thêm tương tác cụm cùng với các đặc trưng cụm mang lại sự tăng cường hiệu suất, ngay cả khi số lượng giải pháp mã được lấy mẫu nhỏ.

So với CodeT, như đã giải thích trước đó, do quá trình phân cụm nhất quán về mặt ngữ nghĩa trong phương pháp của chúng tôi, cả xếp hạng lại có hoặc không có tương tác đều vượt trội hơn CodeT.

Hơn nữa, với số lượng giải pháp được lấy mẫu và test case hạn chế, kết quả vượt qua tìm kiếm tham lam (được đại diện bởi các đường màu đen). Điều này chứng minh cả tính hiệu quả và hiệu suất của phương pháp chúng tôi.

7 Công trình Liên quan

Mô hình Ngôn ngữ Lớn về Mã Sự xuất hiện của các mô hình ngôn ngữ lớn (LLMs) đã biến đổi các nhiệm vụ hiểu và sinh mã (Rozière et al., 2023; Li et al., 2023a; Nijkamp et al., 2023a; Wang et al., 2023; Nijkamp et al., 2023b; Fried et al., 2023; Li et al., 2023b). Nghiên cứu gần đây đã sử dụng các mô hình xử lý ngôn ngữ tự nhiên cho các nhiệm vụ liên quan đến mã, sử dụng các chiến lược pretraining tương tự như cho ngôn ngữ tự nhiên (Feng et al., 2020; Wang et al., 2021; Guo et al., 2020; Ahmad et al., 2021; Elnaggar et al., 2021; Peng et al., 2021; Kanade et al., 2020; Chakraborty et al., 2022; Ahmed and Devanbu, 2022; Niu et al., 2022). Trong số các CodeLLM khác nhau, những mô hình có khả năng lớn hơn có xu hướng hoạt động tốt hơn trong các nhiệm vụ sinh mã. Ví dụ, StarCoder (Li et al., 2023a) và CodeLlama (Rozière et al., 2023) xử lý ngữ cảnh với tới 8,000 và 100,000 token, tương ứng, trong khi WizardCoder (Luo et al., 2023) xuất sắc trong việc phát triển hướng dẫn. Ngoài ra, các mô hình như CodeGen2.5-Instruct (Nijkamp et al., 2023a), CodeT5+Instruct (Wang et al., 2023), Codex002 (Chen et al., 2021), CodeGen-Mono 16B (Nijkamp et al., 2023b), và InCoder 6B (Fried et al., 2023) cũng đã cho thấy triển vọng trong lĩnh vực này.

Phương pháp Xếp hạng lại cho Sinh mã Một số nghiên cứu đã khám phá việc xếp hạng lại mã được sinh ra bởi các mô hình ngôn ngữ (Chen et al., 2021; Zhang et al., 2023; Ni et al., 2023; Chen et al., 2023; Inala et al., 2022; To et al.), ưu tiên các giải pháp từ những mô hình này. Chen et al. (2021) đã chỉ ra thực nghiệm rằng việc lựa chọn giải pháp dựa trên xác suất log trung bình của các token cải thiện hiệu suất. Coder-Reviewer (Zhang et al., 2023) đề xuất một phương pháp xếp hạng dựa trên thông tin tương hỗ cho các hướng dẫn ngôn ngữ tự nhiên và các giải pháp được sinh ra. Xếp hạng lại cũng đã được tiếp cận sử dụng các thước đo dựa trên thực thi. MBR-exec (Shi et al., 2022) giảm thiểu một hàm mất mát qua tất cả các giải pháp, trong khi AlphaCode (Li et al., 2022) phân cụm các giải pháp dựa trên đầu ra thực thi. LEVER (Ni et al., 2023) sử dụng một trình xác minh để đánh giá tính đúng đắn của chương trình, và CodeT (Chen et al., 2023) sinh ra các test case chất lượng cao. Phương pháp của chúng tôi nổi bật vì nó không yêu cầu huấn luyện hoặc fine-tuning mô hình và có thể bổ sung cho các phương pháp như LEVER (Ni et al., 2023).

8 Kết luận

Chúng tôi đề xuất SRank, một chiến lược xếp hạng lại mới được thiết kế để trích xuất các giải pháp sinh mã tối ưu từ CodeLLMs. SRank tập trung vào việc mô hình hóa các mối quan hệ giữa các cụm để xác định các cụm có sự chồng chéo chức năng cao nhất với các cụm khác. Bằng cách ưu tiên cụm có tương tác toàn diện nhất, thường chỉ ra chức năng chính xác, chúng ta có thể xác định giải pháp hứa hẹn nhất. Việc kết hợp những mối quan hệ giữa các cụm này vào pipeline xếp hạng tăng cường việc xác định giải pháp. Chúng tôi thể hiện hiệu suất tiên tiến của SRank về pass@1 qua nhiều CodeLLM nổi tiếng, vượt qua các phương pháp xếp hạng khác như CodeT và Coder-Reviewer trong các đánh giá rộng rãi. Phân tích kỹ lưỡng của chúng tôi tiếp tục làm nổi bật hiệu quả của phương pháp trong các tình huống thực tế với số lượng giải pháp và test case hạn chế. Những phát hiện này rất quan trọng vì chúng giải quyết các thách thức của sinh mã trong các ứng dụng thực tế, làm sáng tỏ các chiến lược để lựa chọn các giải pháp vượt trội trong môi trường lập trình bị hạn chế.

Hạn chế

Phương pháp của chúng tôi trình bày một số cơ hội để phát triển và cải tiến thêm. Trong khi phương pháp của chúng tôi chứng minh sự vượt trội so với các phương pháp khác trong đánh giá thực nghiệm của chúng tôi, tập trung vào Python, việc mở rộng SRank sang một benchmark đa ngôn ngữ sẽ cung cấp một đánh giá toàn diện hơn về hiệu quả của nó qua các ngôn ngữ lập trình khác nhau.

SRank đã cho thấy kết quả hứa hẹn trong phạm vi hiện tại của nó, chủ yếu tập trung vào các hàm với các thước đo đầu ra rõ ràng, chẳng hạn như các bài toán số học hoặc thuật toán. Để mở rộng SRank sang các nhiệm vụ lập trình phức tạp hơn, chẳng hạn như kiến trúc hệ thống, quản lý bộ nhớ, và quản lý tiến trình, chúng ta sẽ cần xác thực rằng giả định cơ bản về các giải pháp không chính xác đa dạng của chúng tôi có hiệu lực trong những lĩnh vực này và điều chỉnh hàm δ để nắm bắt hiệu quả những phức tạp của những nhiệm vụ này. Điều này mang lại một cơ hội thú vị để mở rộng khả năng ứng dụng của phương pháp chúng tôi.

Trong khi việc triển khai SRank có thể đưa ra chi phí tính toán do cần sinh ra một số lượng lớn các giải pháp ứng viên và test case, nghiên cứu ablation của chúng tôi chứng minh rằng SRank có thể đạt được hiệu suất vượt trội với số lượng giải pháp được lấy mẫu và test case hạn chế. Để tối ưu hóa thêm hiệu quả của phương pháp chúng tôi, đặc biệt trong các môi trường hạn chế tài nguyên hoặc khi việc sinh giải pháp nhanh chóng là quan trọng, chúng tôi dự định tiến hành các phân tích bổ sung và khám phá các tối ưu hóa tiềm năng. Hiện tại, SRank tập trung vào việc đánh giá tính đúng đắn chức năng bằng cách mô hình hóa sự chồng chéo chức năng giữa các giải pháp. Trong khi tính đúng đắn chức năng là một khía cạnh quan trọng của chất lượng mã, chúng tôi thừa nhận tầm quan trọng của các yếu tố khác như hiệu quả và tính mạnh mẽ. Việc tích hợp những yếu tố này vào framework của chúng tôi mang lại một hướng thú vị cho công việc tương lai, vì nó sẽ tăng cường tính toàn diện và mạnh mẽ của SRank trong việc đáp ứng các yêu cầu đa dạng của các nhiệm vụ lập trình thực tế. Bằng cách giải quyết những khía cạnh này, chúng tôi nhằm làm cho SRank trở thành một công cụ thậm chí còn có giá trị hơn cho cộng đồng lập trình.
