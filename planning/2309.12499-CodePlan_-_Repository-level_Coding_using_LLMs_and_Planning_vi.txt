# CodePlan : Lập trình cấp độ repository sử dụng LLMs và Planning
RAMAKRISHNA BAIRI, Microsoft Research, India
ATHARV SONWANE, Microsoft Research, India
ADITYA KANADE, Microsoft Research, India
VAGEESH D C, Microsoft Research, India
ARUN IYER, Microsoft Research, India
SURESH PARTHASARATHY, Microsoft Research, India
SRIRAM RAJAMANI, Microsoft Research, India
B. ASHOK, Microsoft Research, India
SHASHANK SHET, Microsoft Research, India

Các hoạt động kỹ thuật phần mềm như di chuyển gói, sửa lỗi báo cáo từ phân tích tĩnh hoặc kiểm thử, và thêm chú thích kiểu hoặc các đặc tả khác vào codebase, liên quan đến việc chỉnh sửa trên toàn bộ repository code. Chúng tôi công thức hóa các hoạt động này như các tác vụ lập trình cấp độ repository.

Các công cụ gần đây như GitHub Copilot, được hỗ trợ bởi Large Language Models (LLMs), đã thành công trong việc cung cấp các giải pháp chất lượng cao cho các vấn đề lập trình cục bộ. Các tác vụ lập trình cấp độ repository phức tạp hơn và không thể giải quyết trực tiếp bằng LLMs, vì code trong một repository có tính phụ thuộc lẫn nhau và toàn bộ repository có thể quá lớn để đưa vào prompt. Chúng tôi đặt khung lập trình cấp độ repository như một bài toán planning và trình bày một framework bất khả tri về tác vụ, gọi là CodePlan để giải quyết nó. CodePlan tổng hợp một chuỗi chỉnh sửa đa bước (plan), trong đó mỗi bước dẫn đến một lời gọi đến LLM trên một vị trí code với ngữ cảnh được suy ra từ toàn bộ repository, các thay đổi code trước đó và hướng dẫn cụ thể cho tác vụ. CodePlan dựa trên sự kết hợp mới của phân tích phụ thuộc tăng dần, phân tích may-impact thay đổi và thuật toán planning thích ứng.

Chúng tôi đánh giá hiệu quả của CodePlan trên hai tác vụ cấp độ repository: di chuyển gói (C#) và chỉnh sửa code theo thời gian (Python). Mỗi tác vụ được đánh giá trên nhiều repository code, mỗi repository yêu cầu các thay đổi phụ thuộc lẫn nhau đến nhiều file (từ 2–97 file). Các tác vụ lập trình với mức độ phức tạp này chưa được tự động hóa sử dụng LLMs trước đây. Kết quả của chúng tôi cho thấy CodePlan có sự khớp tốt hơn với ground truth so với baselines. CodePlan có thể làm cho 5/6 repository vượt qua các kiểm tra tính hợp lệ (ví dụ: build không có lỗi và thực hiện chỉnh sửa code đúng) trong khi các baselines (không có planning nhưng có cùng loại thông tin ngữ cảnh như CodePlan) không thể làm cho repository nào vượt qua chúng. Chúng tôi sẽ phát hành dữ liệu và scripts đánh giá tại https://aka.ms/CodePlan.

CCS Concepts: •Computing methodologies →Planning under uncertainty ;•Software and its engineering→Software maintenance tools ;Software evolution ;Automatic programming .

Additional Key Words and Phrases: Automated coding, repositories, LLMs, static analysis, plan, chain of edits

1 GIỚI THIỆU
Khả năng sinh tự nhiên đáng kinh ngạc của Large Language Models (LLMs) [24,28,30,35,57,73] đã mở ra những cách thức mới để tự động hóa các tác vụ lập trình. Các công cụ được xây dựng trên LLMs, như Amazon Code Whisperer [14], GitHub Copilot [38] và Replit [66], hiện được sử dụng rộng rãi để hoàn thành code dựa trên ý định ngôn ngữ tự nhiên và ngữ cảnh của code xung quanh, và cũng để thực hiện chỉnh sửa code dựa trên hướng dẫn ngôn ngữ tự nhiên [78]. Những chỉnh sửa như vậy thường được thực hiện cho các vùng code nhỏ như hoàn thành hoặc chỉnh sửa dòng hiện tại, hoặc toàn bộ body của method.

Trong khi những công cụ này giúp với "vòng lặp trong" của kỹ thuật phần mềm nơi nhà phát triển đang lập trình trong editor và chỉnh sửa một vùng code nhỏ, có một số tác vụ trong "vòng lặp ngoài" của kỹ thuật phần mềm liên quan đến toàn bộ repository code. Ví dụ, nếu repository code của chúng ta sử dụng thư viện L, và API của thư viện L thay đổi từ phiên bản vn sang phiên bản vn+1, chúng ta cần di chuyển repository code của mình để gọi đúng phiên bản đã sửa đổi. Một tác vụ di chuyển như vậy liên quan đến việc thực hiện chỉnh sửa không chỉ đến tất cả các vùng của repository thực hiện lời gọi đến các API liên quan trong thư viện L, mà còn đến các vùng của repository (qua ranh giới file) có các phụ thuộc cú pháp và ngữ nghĩa bắc cầu trên code đã cập nhật.

Điều này được minh họa trong Hình 1, cho thấy một thay đổi trong API cho thư viện Complex Numbers. Tác vụ của chúng ta là di chuyển repository code của chúng ta theo thay đổi này. Phía trái của Hình 3 cho thấy các phần liên quan của repository code của chúng ta sử dụng thư viện Complex Numbers. Cụ thể, file Create.cs có method func, gọi method create_complex từ thư viện, và Process.cs có method process gọi func.

Chúng ta có thể truyền mô tả tác vụ từ Hình 1 và body của func cho một LLM để tạo ra code đã sửa đổi cho func như được hiển thị ở phía bên phải của Hình 3. Như đã thấy, LLM đã chỉnh sửa đúng lời gọi đến API create_complex để nó trả về một đối tượng kiểu Complex thay vì một tuple của hai giá trị dấu phẩy động. Lưu ý rằng chỉnh sửa này đã dẫn đến thay đổi signature của method func – bây giờ nó trả về một đối tượng kiểu Complex. Điều này cần thiết các thay đổi đến những caller của method func như method process trong file Process.cs, được hiển thị ở phía trái-dưới của Hình 3. Không có thay đổi phù hợp đến body của method process, code của chúng ta không build được! Một thay đổi phù hợp đến method process làm cho repository đến trạng thái nhất quán, để nó build không có lỗi, được hiển thị ở phía dưới-phải của Hình 3.

Công thức hóa vấn đề. Tác vụ di chuyển ở trên đại diện cho một họ tác vụ liên quan đến chỉnh sửa toàn bộ repository code cho các mục đích khác nhau như sửa báo cáo lỗi từ phân tích tĩnh hoặc kiểm thử, sửa pattern lập trình có lỗi, refactoring, hoặc thêm chú thích kiểu hoặc các đặc tả khác. Mỗi tác vụ này liên quan đến một tập hợp các đặc tả seed như được hiển thị trong Hình 1, là các điểm khởi đầu cho tác vụ chỉnh sửa code. Những đặc tả seed này thường kích hoạt các yêu cầu chỉnh sửa khác trên code, và những yêu cầu như vậy cần được truyền bá qua các phụ thuộc trong repository code để thực hiện các chỉnh sửa khác qua repository để hoàn thành tác vụ lập trình. Thông thường, việc truyền bá các chỉnh sửa như vậy qua các phụ thuộc được thực hiện thủ công.

Mục tiêu của chúng tôi là xây dựng một hệ thống lập trình cấp độ repository, tự động tạo ra các đặc tả dẫn xuất cho các chỉnh sửa như được yêu cầu cho method process trong Hình 3, để đưa repository đến trạng thái hợp lệ. Ở đây, tính hợp lệ được định nghĩa theo một oracle, có thể được khởi tạo theo các cách khác nhau để thực thi các điều kiện đúng đắn cấp độ repository như build không có lỗi, vượt qua phân tích tĩnh, vượt qua hệ thống kiểu hoặc một tập hợp các test, hoặc vượt qua một công cụ xác minh. Chúng tôi định nghĩa một tác vụ lập trình cấp độ repository dẫn động bởi LLM như sau:

Tác vụ Lập trình Cấp độ Repository Dẫn động bởi LLM
Cho một trạng thái khởi đầu của repository Rstart, một tập hợp các đặc tả chỉnh sửa seed Δseeds, một oracle Θ sao cho Θ(Rstart)=True, và một LLM L, mục tiêu của một tác vụ lập trình cấp độ repository dẫn động bởi LLM là đạt đến trạng thái repository Rtarget =ExecuteEdits(L,Rstart,P) trong đó P là một chuỗi các đặc tả chỉnh sửa từ Δseeds∪Δderived trong đó Δderived là một tập hợp các đặc tả chỉnh sửa dẫn xuất để Θ(Rtarget)=True.

Giải pháp đề xuất. Trong bài báo này, chúng tôi đề xuất một phương pháp để tính toán các đặc tả dẫn xuất bằng cách đặt khung lập trình cấp độ repository (dẫn động bởi LLM) như một bài toán planning. Automated planning [37,67] nhằm giải quyết các vấn đề đa bước, trong đó mỗi bước thực hiện một hành động trong số nhiều lựa chọn hướng tới đạt được trạng thái mục tiêu. Nó được sử dụng trong một loạt các lĩnh vực như motion planning [47], autonomous driving [39], robotics [44] và theorem proving [26].

Chúng tôi trình bày một framework bất khả tri về tác vụ, gọi là CodePlan, tổng hợp một plan đa bước để giải quyết tác vụ lập trình cấp độ repository. Như được hiển thị trong Hình 2, đầu vào cho CodePlan là một repository, một tác vụ với các đặc tả seed được diễn đạt thông qua hướng dẫn ngôn ngữ tự nhiên hoặc một tập hợp các chỉnh sửa code ban đầu, một oracle đúng đắn và một LLM. CodePlan xây dựng một plan graph trong đó mỗi node trong graph xác định một nghĩa vụ chỉnh sửa code mà LLM cần thực hiện và một edge chỉ ra rằng target node cần được thực hiện do source node. CodePlan giám sát các chỉnh sửa code và mở rộng plan graph một cách thích ứng. Các chỉnh sửa Δseeds theo từ mô tả tác vụ, trong khi các chỉnh sửa Δderived được xác định và ngữ cảnh hóa dựa trên sự kết hợp mới của phân tích phụ thuộc tăng dần, phân tích change may-impact và thuật toán planning thích ứng. Khối merge hợp nhất code được tạo bởi LLM vào repository. Một khi tất cả các bước trong plan được hoàn thành, repository được phân tích bởi oracle. Tác vụ được hoàn thành nếu oracle xác nhận repository. Nếu nó tìm thấy lỗi, các báo cáo lỗi được sử dụng như các đặc tả seed cho vòng tạo và thực thi plan tiếp theo.

Xem xét lại, ví dụ tác vụ di chuyển API được chỉ định trong Hình 1 trên code trong Hình 3. CodePlan thực hiện chỉnh sửa method func sử dụng hướng dẫn trong Hình 1 như một đặc tả seed. Bằng cách phân tích thay đổi code giữa Hình 3(a)–(b), nó phân loại thay đổi như một escaping change vì nó ảnh hưởng đến signature của method func. Phân tích change may-impact xác định rằng (các) caller của func có thể bị ảnh hưởng và do đó, thuật toán planning thích ứng sử dụng các phụ thuộc caller-callee để suy ra một đặc tả dẫn xuất để chỉnh sửa method process, gọi func. Cả các thay đổi seed và dẫn xuất đều được thực hiện bằng cách tạo các prompt phù hợp cho một LLM và repository code kết quả vượt qua oracle, tức là build không có lỗi. Lưu ý rằng đây là một ví dụ đơn giản với chỉ one-hop change propagation. Trong thực tế, các thay đổi dẫn xuất có thể tự cần thiết các thay đổi khác một cách bắc cầu và CodePlan xử lý những trường hợp như vậy.

Một lựa chọn thay thế đơn giản hơn cho planning của chúng tôi là sử dụng oracle để suy ra các đặc tả dẫn xuất. Ví dụ, build system có thể tìm thấy lỗi trong method process sau khi thay đổi seed được thực hiện trong Hình 3. Điều này có những hạn chế quan trọng. Đầu tiên, không phải tất cả các thay đổi đều gây ra build errors mặc dù chúng dẫn đến các thay đổi hành vi, ví dụ, thay đổi giá trị trả về từ True thành False mà không thay đổi kiểu trả về. Thứ hai, build system không biết về mối quan hệ nguyên nhân-kết quả khi code bị hỏng. Ví dụ, nếu signature của một overriding method được thay đổi theo đặc tả seed thì một thay đổi tương tự cần thiết trong virtual method tương ứng. Tuy nhiên, build system (khi chạy trên snapshot trung gian, không nhất quán của repository) đổ lỗi cho overriding method vì không tuân thủ virtual method. Cố gắng sửa lỗi build một cách ngây thơ sẽ kết thúc việc revert thay đổi seed. Các thành phần phân tích tĩnh và planning của CodePlan vượt qua những hạn chế này.

Chúng tôi so sánh thực nghiệm CodePlan với một baseline sử dụng build system để lặp lại xác định các thay đổi phá vỡ và sử dụng LLM để sửa chúng. Kết quả định lượng và định tính của chúng tôi cho thấy CodePlan vượt trội so với loại kỹ thuật sửa chữa dẫn động bởi oracle này.

Đóng góp. Theo hiểu biết tốt nhất của chúng tôi, vấn đề giám sát hiệu ứng của các chỉnh sửa code được thực hiện bởi LLM đến repository và có hệ thống planning một chuỗi các chỉnh sửa phụ thuộc lẫn nhau chưa được xác định và giải quyết trước đây.

Trong không gian các tác vụ lập trình cấp độ repository, hai loại ngữ cảnh đã được tìm thấy là hữu ích cho việc prompting LLMs: (1) spatial context để cung cấp thông tin cross-file cho model sử dụng static analysis [9, 34, 51, 59, 61, 70, 71, 77] hoặc retrieval [81, 85], và (2) temporal context để conditioning các predictions trên lịch sử chỉnh sửa đến repository [23,40,64,76]. Vì CodePlan giám sát các thay đổi code và duy trì một dependency graph repository-wide, chúng tôi cung cấp cả hai dạng ngữ cảnh này trong một framework thống nhất. Các kỹ thuật hiện có giả định rằng vị trí chỉnh sửa tiếp theo được cung cấp bởi nhà phát triển và không tính đến hiệu ứng của một chỉnh sửa trên code phụ thuộc. Ngược lại, bằng cách suy ra tác động của mỗi thay đổi, CodePlan truyền bá các thay đổi đến code phụ thuộc, mở đường để tự động hóa các tác vụ lập trình cấp độ repository thông qua chuỗi chỉnh sửa.

Tóm lại, chúng tôi đóng góp như sau trong bài báo này:
(1) Chúng tôi là những người đầu tiên chính thức hóa vấn đề tự động hóa các tác vụ lập trình cấp độ repository sử dụng LLMs, yêu cầu phân tích hiệu ứng của các thay đổi code và truyền bá chúng qua repository. Hiện tại không có giải pháp có hệ thống và khả năng mở rộng cho vấn đề này.
(2) Chúng tôi đặt khung lập trình cấp độ repository như một bài toán planning và thiết kế một framework bất khả tri về tác vụ, gọi là CodePlan, dựa trên sự kết hợp mới của phân tích phụ thuộc tăng dần, phân tích change may-impact và thuật toán planning thích ứng. CodePlan tổng hợp một chuỗi chỉnh sửa đa bước (plan) để được thực hiện bởi LLM.
(3) Chúng tôi thực nghiệm với hai tác vụ lập trình cấp độ repository sử dụng model gpt-4-32k: di chuyển gói cho repositories C# và chỉnh sửa code theo thời gian cho repositories Python. Chúng tôi so sánh với baselines sử dụng oracles (build system cho C# và static type checker cho Python) để xác định các đặc tả chỉnh sửa dẫn xuất (trái ngược với planning được sử dụng trong CodePlan). Chúng tôi sử dụng cùng phương pháp ngữ cảnh hóa như CodePlan trong baselines.
(4) Kết quả của chúng tôi cho thấy CodePlan có sự khớp tốt hơn với ground truth so với baselines. CodePlan có thể làm cho 5/6 repositories vượt qua các kiểm tra tính hợp lệ, trong khi baselines không thể làm cho repository nào vượt qua chúng. Ngoại trừ 2 repositories có tính chất sở hữu, chúng tôi sẽ phát hành dữ liệu và evaluation scripts tại https://aka.ms/CodePlan.
